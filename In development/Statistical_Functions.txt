/* STATISTICAL FUNCTIONS */

QUANTILES = LAMBDA(range, [divisions], [mode], [precision],
    LET(
        mode, IF(OR(ISOMITTED(mode), mode > 1), 0, mode),
        divisions, IF(ISOMITTED(divisions), 10, divisions),
        precision, IF(ISOMITTED(precision), 3, precision),
        pctiles, SEQUENCE(divisions + 1, 1, 0) * 1 / divisions,
        pct_labels, TEXT(pctiles, "0%"),
        pct_vals, PERCENTILE.INC(range, pctiles),
        list, TEXTJOIN(" ", TRUE, pct_vals),
        outputs, TOCOL(ROUND(VALUE(TEXTSPLIT(list, " ")), precision)),
        SWITCH(mode, 0, outputs, 1, CHOOSE({1, 2}, pct_labels, VALUE(outputs)))
    )
);

STATS_TILES = LAMBDA(range, [divisions], [mode], [style], [precision],
    LET(
        mode, IF(OR(ISOMITTED(mode), mode > 2), 0, mode),
        divisions, IF(ISOMITTED(divisions), 10, divisions),
        precision, IF(ISOMITTED(precision), 3, precision),
        style, IF(OR(ISOMITTED(style), style > 2), 0, style),
        pctiles, SWITCH(
            style,
            0, SEQUENCE(divisions - 1, 1, 1) * 1 / divisions,
            1, SEQUENCE(divisions, 1, 0) * 1 / divisions,
            2, SEQUENCE(divisions + 1, 1, 0) * 1 / divisions,
            
        ),
        fmt, "0.00%",
        pct_labels, TEXT(pctiles, fmt),
        pct_vals, ROUND(PERCENTILE.INC(range, pctiles), precision),
        counts, BYROW(pct_vals, LAMBDA(x, COUNTIF(range, "<=" & x))),
        SWITCH(
            mode,
            0, pct_vals,
            1, CHOOSE({1, 2}, pct_labels, VALUE(pct_vals)),
            2, CHOOSE({1, 2, 3}, pct_labels, VALUE(pct_vals), VALUE(counts))
        )
    )
);


STATS_STDERR = LAMBDA(array, [mode], [precision],
    LET(
        precision, IF(ISOMITTED(precision), 3, precision),
        // style, if(OR(isomitted(style),style>1),0,style),
        mode, IF(OR(ISOMITTED(mode), mode > 1), 0, mode),
        // fmt, "0."&rept("0",precision)&"%",
        stderr, SWITCH(mode, 0, STDEV.P(array) / SQRT(COUNTA(array)), 1, STDEV.S(array) / SQRT(COUNTA(array))),
        result, ROUND(stderr, precision),
        result
    )
);

STATS_MINMAX = LAMBDA(array, [prec],

LET(
    prec, IF(ISOMITTED(prec), 3, prec),
    min, min(array),
    max, max(array),
    //size, trunc(abs(log(abs(max)))),
    //prec, size+1,
    min_out, round(min(array),prec),
    max_out, round(max(array),prec),
    list, textjoin("|",,min_out, max_out),
    tocol(value(textsplit(list,"|")))
    //prec
)
);

STATSLIST = LAMBDA(range, [mode], [prec],
    LET(
        mode, IF(OR(ISOMITTED(mode), mode > 6), 0, mode),
        prec, IF(ISOMITTED(prec), 3, prec),
        label_list, transpose({"Min",
                    "ς⁻",
                    "μ",
                    "ς⁺",
                    "Max",
                    "σ",
                    "Skew.P",
                    "Ct",
                    "Range",
                    "Midrange",
                    "Sum",
                    "ẋ"}),
        stats, TRANSPOSE(
                    CHOOSE(
                        {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12},
                        FIXED(MIN(range), prec), // min
                        FIXED(
                            AVERAGE(range) - STDEV.P(range),
                            prec
                        ), // -sigma
                        FIXED(AVERAGE(range), prec), // mean
                        FIXED(
                            AVERAGE(range) + STDEV.P(range),
                            prec
                        ), // +sigma
                        FIXED(MAX(range), prec), // max
                        FIXED(STDEV.P(range), prec), // sigma
                        FIXED(SKEW.P(range), prec), // skew
                        FIXED(COUNT(range), 0), // count
                        FIXED(MAX(range) - MIN(range), prec), // range
                        FIXED(AVERAGE(MIN(range),MAX(range)),prec), // midrange
                        FIXED(SUM(range), prec), // sum
                        FIXED(median(range), prec), // median
                        
                    )
                ),
        output, CHOOSE({1, 2}, label_list, VALUE(stats)),
        return, switch(mode,
            0, output,
            1, chooserows(output, 1, 5),
            2, Chooserows(output, 1, 3, 5),
            3, Chooserows(output, 1, 2, 3, 4, 5),
            4, Chooserows(output, 1, 2, 3, 4, 5, 11),
            5, Chooserows(output, 1, 2, 3, 4, 5, 6),
            6, Chooserows(output, 1, 2, 3, 4, 5, 6, 11)
            ),
        return
    )

);

STATS_PCT_CHG = LAMBDA(old, new, [mode], [precision],
    LET(
        precision, IF(ISOMITTED(precision), 3, precision),
        mode, IF(OR(ISOMITTED(mode), mode > 1), 0, mode),
        fmt, "0." & REPT("0", precision) & "%",
        diff, new - old,
        base, ABS(old),
        result, SWITCH(
            mode,
            0, ROUND(diff / base, precision),
            1, IF(
                (diff / base) > 0,
                "+" & TEXT(diff / base, fmt),
                TEXT(diff / base, fmt)
            )
        ),
        result
    )
);


STATS_PCT_DIF = LAMBDA(val_01, val_02, [mode], [precision],
    LET(
        precision, IF(ISOMITTED(precision), 3, precision),
        mode, IF(OR(ISOMITTED(mode), mode > 1), 0, mode),
        diff, ABS(val_02 - val_01),
        avg, ABS(AVERAGE(val_01, val_02)),
        fmt, "0." & REPT("0", precision) & "%",
        result, SWITCH(
            mode,
            0, ROUND(diff / avg, precision),
            1, TEXT(diff / avg, fmt)
        ),
        result
    )
);


STATS_PCT_ERR = LAMBDA(expected, actual, [mode], [precision],
    LET(
        precision, IF(ISOMITTED(precision), 3, precision),
        mode, IF(OR(ISOMITTED(mode), mode > 1), 0, mode),
        fmt, "0." & REPT("0", precision) & "%",
        diff, ABS(actual - expected),
        result, SWITCH(
            mode,
            0, ROUND(diff / ABS(expected), precision),
            1, TEXT(diff / ABS(expected), fmt)
        ),
        result
    )
);



STATS_SPAN = LAMBDA(array, MAX(array) - MIN(array));

MIDRANGE = LAMBDA(array, [prec],

LET(
    prec, IF(ISOMITTED(prec), 3, prec),
    min, min(array),
    max, max(array),
    midrange, average(min,max),
    midrange
)
);

LIST_WEIGHTS = LAMBDA(range,
    LET(
        headers, {"Values"; "Weights"; "Products"},
        u_range, SORT(UNIQUE(range)),
        weights, BYROW(u_range, LAMBDA(a, COUNTIF(range, a))),
        products, u_range * weights,
        col_1, VSTACK(INDEX(headers, 1), u_range),
        col_2, VSTACK(INDEX(headers, 2), weights),
        col_3, VSTACK(INDEX(headers, 3), products),
        CHOOSE({1, 2, 3}, col_1, col_2, col_3)
    )
);

WEIGHTED_AVERAGE = LAMBDA(wts, values,

    SUMPRODUCT(wts, values) / sum(wts)
);

SELF_WEIGHTED_AVERAGE = LAMBDA(range,
    SUMPRODUCT(range, range) / SUM(range)
);

/* RANGE_PERCENT_TRANSFER:

Transfers a percentage between two pairs of numbers

E.g. PERCENT_OF_LIST_XFR(3,11,5,2,19) = 6.25, which is:
    Find the percentage represented by 5 between 3 and 11
    Find the number between 2 and 19 which corresponds to
        that same percentage.

        i.e. 5 is 25% of the range 3 to 11;
        6.25 is 25% of the range 2 to 19
*/

RANGE_PERCENT_TRANSFER = LAMBDA(StartMin, StartMax, Target, EndMin, EndMax, [decprec],
    LET(
        decprec, IF(ISOMITTED(decprec), 15, decprec),
        pct, (Target - StartMin) / (StartMax - StartMin),
        calc, pct * (EndMax - EndMin) + EndMin,
        round(calc, decprec)
    )
);

/* RANGE_PERCENT_OF_VALUE:

Returns the percentage (as a decimal fraction) between min and max
    which is represented by a given value

E.g. The value 7 represents 0.44444... (44.4%) of the range 3 to 12
*/

RANGE_PERCENT_OF_VALUE = LAMBDA(min, max, value, [decprec],
    LET(
        decprec, IF(ISOMITTED(decprec), 15, decprec),
        calc, (value - min) / (max - min),
        round(calc, decprec)
    )
);

/* RANGE_VALUE_OF_PERCENT:

Returns the value which is the given percentage between MIN and MAX
pct is supplied as a decimal number between 0 and 100
    and converted internally to a decimal fraction
    i.e. pct = 40.65 -> 0.4065
*/

RANGE_VALUE_OF_PERCENT = LAMBDA(min, max, pct, [decprec],
    LET(
        decprec, IF(ISOMITTED(decprec), 15, decprec),
        // pct, pct / 100,
        calc, pct * (max - min) + min,
        round(calc, decprec)
    )
);

BENFORD = LAMBDA([null],
    LET(
        list, TOCOL({1, 2, 3, 4, 5, 6, 7, 8, 9}),
        output, BYROW(list, LAMBDA(x, LOG(1 + (1 / MOD(x, 10))))),
        output
    )
);

RANDBENFORD_SINGLE = LAMBDA([null],
    
    // generates a single digit with a probability based on the Benford Distribution
    LET(
        numlist, SEQUENCE(9, , 1, 1),
        problist, {0.301, 0.477, 0.602, 0.699, 0.778, 0.845, 0.903, 0.954, 1},
        prob, XLOOKUP(RAND(), problist, problist, , 1),
        prob_index, MATCH(prob, problist, 0),
        digit, INDEX(numlist, prob_index),
        VALUE(digit)
    )
);

RANDBENFORD = LAMBDA([digits],
    LET(
        digits, IF(ISOMITTED(digits), 3, digits),
        numlist, SEQUENCE(9, 1, 1, 1),
        problist, {0.301, 0.477, 0.602, 0.699, 0.778, 0.845, 0.903, 0.954, 1},
        random_numbers, RANDARRAY(digits, 1),
        generated_digits, INDEX(numlist, MATCH(XLOOKUP(random_numbers, problist, problist, , 1), problist, 1)),
        generated_number, TEXTJOIN("", TRUE, generated_digits),
        VALUE(generated_number)
    )
);

SEEDED_VALUE = LAMBDA(seed,
    LET(
        /* RANDBETWEEN(1,2^31-2) */
        output, MOD(48271 * seed, 2 ^ 31 - 1),
        output
    )
);


BRACKETS_TARGET = LAMBDA(TestArray, Target, [incl], [mode], [decprec],
    LET(
        decprec, IF(ISOMITTED(decprec), 3, decprec),
        mode, IF(OR(ISOMITTED(mode), mode > 2), 0, mode),
        incl, IF(OR(ISOMITTED(incl), incl > 1), 0, incl),

        // Compute bracketing values
        lower, MAX(FILTER(TestArray, TestArray < Target)),
        upper, MIN(FILTER(TestArray, TestArray > Target)),

        outList, IF(incl = 0, {lower, Target, upper}, {lower, upper}),
        
        output, SWITCH(
            mode,
            0, TOCOL(ROUND(outList, decprec)),
            1, TOROW(ROUND(outList, decprec)),
            2, "(" & TEXTJOIN(" : ", , FIXED(outList, decprec)) & ")"
        ),

        output
    )
);

BRACKETS_ARRAY = LAMBDA(LookupArray, ReturnArray, [Mode],
    LET(
        mode, IF(OR(ISOMITTED(Mode), Mode > 2), 0, Mode),
        Avg, AVERAGE(LookupArray),
        Least, MAX(FILTER(LookupArray, LookupArray < Avg)),
        Most, MIN(FILTER(LookupArray, LookupArray > Avg)),
        Least_index, XLOOKUP(Least, LookupArray, ReturnArray),
        Most_index, XLOOKUP(Most, LookupArray, ReturnArray),
        list, TEXTJOIN(" ", , Least_index, Avg, Most_index),
        output, SWITCH(
            mode,
            0, TOCOL(TEXTSPLIT(list, " ")),
            1, TOROW(TEXTSPLIT(list, " ")),
            2, CONCAT("(", TEXTJOIN(" : ", , FIXED(Least, 3), FIXED(Avg, 3), FIXED(Most, 3)), ")")
        ),
        output
    )
);

