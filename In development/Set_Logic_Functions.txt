VENN = LAMBDA(control, test,
    LET(
        control_count, COUNTA(control),
        test_count, COUNTA(test),
        x_list, XMATCH(test, control),
        xmatch_count, COUNT(x_list),
        xmatch_counta, COUNTA(x_list),
        xmatch_countu, COUNT(UNIQUE(x_list)),
        test00, xmatch_count = 0,
        test01, xmatch_countu = xmatch_count,
        test02, test_count = xmatch_count,
        test03, xmatch_count <= xmatch_counta,
        test04, test_count <= control_count,
        output, IF(
            AND(xmatch_count = 0, test_count = control_count, TRUE),
            "EQUIV",
            IFS(
                AND(
                    xmatch_countu = xmatch_count,
                    test_count = xmatch_count,
                    xmatch_count = xmatch_counta,
                    test_count = control_count
                ),
                "EQUAL",
                OR(
                    AND(
                        xmatch_countu < xmatch_count,
                        test_count = xmatch_count,
                        xmatch_count = xmatch_counta,
                        test_count <= control_count
                    ),
                    AND(
                        xmatch_countu <= xmatch_count,
                        test_count = xmatch_count,
                        xmatch_count = xmatch_counta,
                        test_count <= control_count
                    )
                ),
                "PRSUB",
                OR(
                    AND(
                        xmatch_countu <= xmatch_count,
                        test_count > xmatch_count,
                        xmatch_count < xmatch_counta,
                        test_count = control_count
                    ),
                    AND(
                        xmatch_countu <= xmatch_count,
                        test_count > xmatch_count,
                        xmatch_count < xmatch_counta,
                        test_count <> control_count
                    )
                ),
                "INTER",
                TRUE,
                "FAILURE"
            )
        ),
        output
    )
);

/* V_RELCOMP
Compares two ranges and returns a list of items in the
    first range which are missing from the second range
Returns the relative complement: listᶜ ⋂ check
*/

V_RELCOMP = LAMBDA(list, check, [mode],
    LET(
        mode, IF(OR(ISOMITTED(mode), mode > 1), 0, mode),
        a, SWITCH(mode, 0, TOCOL(list, 3), 1, TOCOL(check, 3), ),
        b, SWITCH(mode, 0, check, 1, list),
        result, ISNA(BYROW(a, LAMBDA(x, XLOOKUP(x, b, b)))),
        finlist, IFERROR(FILTER(a, result = TRUE), "NONE"),
        finlist
    )
);

/* V_INTERSECT
Returns a list of all elements common to two lists
Returns the intersection: list ⋂ check
*/

V_INTERSECT = LAMBDA(list, check, [mode],
    LET(
        mode, IF(OR(ISOMITTED(mode), mode > 1), 0, 1),
        last_check, ISNA(BYROW(check, LAMBDA(y, XLOOKUP(y, list, list)))),
        last_list, FILTER(check, last_check = FALSE, ""),
        output, SWITCH(mode, 0, last_list, 1, SORT(last_list)),
        output
    )
);

/* V_SYMDIFF
Returns a list of elements unique to two lists
Returns the symmetric difference: list △ check
    i.e. (list ⋃ check) - (list ⋂ check)
*/

V_SYMDIFF = LAMBDA(list, check,
    LET(
        first_check, ISNA(BYROW(list, LAMBDA(y, XLOOKUP(y, check, check)))),
        first_list, SORT(FILTER(list, first_check = TRUE, "")),
        last_check, ISNA(BYROW(check, LAMBDA(y, XLOOKUP(y, list, list)))),
        last_list, SORT(FILTER(check, last_check = TRUE, "")),
        fin_list, VSTACK(first_list, last_list),
        fin_list
    )
);

/* V_UNION
Returns a unique list of the items from two lists
Returns the union: list ⋃ check
*/

V_UNION = LAMBDA(list, check, [mode], [sort],
    LET(
        mode, IF(OR(ISOMITTED(mode), mode > 1), 0, mode),
        sort, IF(OR(ISOMITTED(sort), sort > 1), 0, sort),
        result, SWITCH(mode, 0, TOCOL(VSTACK(list, check), 3), 1, UNIQUE(TOCOL(VSTACK(list, check), 3))),
        SWITCH(sort, 0, result, 1, SORT(result))
    )
);

/* ISIN
*/

ISIN = LAMBDA(Target, TestArray,
    LET(
        Return, IF(ISNA(XLOOKUP(Target, TestArray, TestArray)), "FALSE", "TRUE"), Return
    )
);

/* LIST_DUPES
    Returns a list of items which appear more than once in a list
*/

LIST_DUPES = LAMBDA(list,
    LET(
        count_list, UNIQUE(BYROW(list, LAMBDA(x, x & ": " & COUNTIF(list, x)))),
        output, SORT(FILTER(count_list, VALUE(TEXTAFTER(count_list, ": ")) > 1)),
        output
    )
);

DUPELIST = LAMBDA(list,
    LET(
        count_list, UNIQUE(BYROW(list, LAMBDA(x, x & ": " & COUNTIF(list, x)))),
        output, SORT(FILTER(count_list, VALUE(TEXTAFTER(count_list, ": ")) > 1)),
        BYROW(output, LAMBDA(x, MATCH(x, output) & " " & x))
    )
);

COUNTEACH = LAMBDA(range,
    LET(
        test, COLUMNS(range),
        count_list, SORT(UNIQUE(BYROW(range, LAMBDA(x, x & ": " & COUNTIF(range, x))))),
        count_list
    )
);

COUNT_INSTANCE = LAMBDA(input, target,
    LET(
        target, IF(LEN(target) > 1, LEFT(target, 1), target),
        output, SUM(--ISNUMBER(SEARCH(MID(input, SEQUENCE(LEN(input)), 1), target))),
        output
    )
);

CONTAINS = LAMBDA(array, find, [position], [caseSensitive],
    LET(
        // Set default values for optional parameters
        position, IF(OR(ISOMITTED(position), position > 2, position < 0), 0, position),
        caseSensitive, IF(OR(ISOMITTED(caseSensitive), caseSensitive > 1, caseSensitive < 0), 0, caseSensitive),
        
        // Define search patterns based on position
        pattern, SWITCH(
            position,
            0, find,          // Match anywhere
            1, find & "*",    // Starts with
            2, "*" & find     // Ends with
        ),
        
        // Define filtering logic based on case sensitivity
        filtered, IF(
            caseSensitive = 0,
            // Case-insensitive search using SEARCH
            FILTER(array, ISNUMBER(SEARCH(pattern, array))),
            // Case-sensitive search using FIND
            FILTER(array, ISNUMBER(FIND(pattern, array)))
        ),
        
        // Return the filtered result or "None" if no match is found
        IFERROR(filtered, "None")
    )
);

COUNTEACHX = LAMBDA(range, [sortMode], [mode],
    LET(
        sortMode, IF(ISOMITTED(sortMode), 0, sortMode), // 0 = by value, 1 = by count
        mode, IF(ISOMITTED(mode), 0, mode), // 0 = values+counts, 1 = just labels
        values, UNIQUE(TOROW(range, 1)),
        counts, MAP(values, LAMBDA(x, COUNTIF(range, x))),
        sorted, SWITCH(
            sortMode,
            0, SORTBY(values, values, 1),
            1, SORTBY(values, counts, -1),
            values
        ),
        sortedCounts, XLOOKUP(sorted, values, counts),
        SWITCH(
            mode,
            1, sorted,
            0, CHOOSE({1, 2}, sorted, sortedCounts)
        )
    )
);

