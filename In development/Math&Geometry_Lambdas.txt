LCM_SCALED = LAMBDA(a, b,
    LET(
        scale, 10^6,
        ascale, a * scale,
        bscale, b * scale,
        prod, ascale * bscale,
        gcd, GCD(ascale,bscale),
        xlcm, prod / gcd,
        result, xlcm / scale,
        result
    )
);

LCM_SCALED_RANGE = LAMBDA(RANGE,
    LET(
    scale, 10^6,
    scaled, MAP(range, LAMBDA(x, ROUND(x * scale, 0))), /* Scale each value */
    scaledLCM, REDUCE(1, scaled, LAMBDA(acc, x, (acc * x) / GCD(acc, x))), /* LCM of scaled values */
    scaledLCM / scale /* Scale back down */
)
);

SPLITFRACTION = LAMBDA(input, [mode],
    LET(
        mode, IF(OR(ISOMITTED(mode), mode > 1), 0, mode),
        select, IF(OR(ISOMITTED(mode), mode > 2), 0, mode),
        numer, VALUE(TEXTBEFORE(input, "/")),
        denom, VALUE(TEXTAFTER(input, "/")),
        list, TEXTJOIN("|", , numer, denom),
        output, SWITCH(mode,
                0, TEXTSPLIT(list, "|"),
                1, TRANSPOSE(TEXTSPLIT(list, "|"))
                ),
        output
    )
);

/* FRAC_DIV
*/

FRAC_DIV = LAMBDA(input,
LET(
    numer, TEXTBEFORE(input, "/"),
    denom, TEXTAFTER(input, "/"),
    numer / denom
    )
);

/* SUM_AP:

Returns the sum of an arithmetic progression calculated from
    the lower bound
    the length of the sequence
    the increment between items in the sequence

E.g. SUM_AP(4,15,5) -> 585, which is:
    the sum of all integers starting with 4
    and incrementing by 5
    a total of 15 times,
    i.e. SUM(4, 9, 14, 19, 24, 29, 34, 39, 44, 49, 54, 59, 64, 69, 74) = 585
*/

SUM_AP = LAMBDA(lbound, length, [increment], [mode],
    LET(
        mode, IF(OR(ISOMITTED(mode), mode > 1), 0, mode),
        increment, IF(ISOMITTED(increment), 1, increment),
        ubound, lbound + (length - 1) * increment,
        total, (length / 2) * ((2 * lbound) + ((length - 1) * increment)),
        SWITCH(mode, 0, total, 1, ubound, )
    )
);



/* INTMANT:
Splits a number into its integer and decimal parts
if [sign] = 1 preserves the sign of the input in
    both the interger and decimal parts
*/

INTMANT = LAMBDA(input, [mode], [sign], [decimals], 
    LET(
        mode, IF(OR(ISOMITTED(mode), mode > 1), 0, mode),
        sign, IF(OR(ISOMITTED(sign), sign > 1), 0, sign),
        decimals, IF(OR(ISOMITTED(decimals), decimals = 0), 3, decimals),
        int_part, QUOTIENT(input, 1),
        dec_part, SWITCH(sign,
            0, ABS(ROUND(input - TRUNC(input), decimals)),
            1, ROUND(input - TRUNC(input), decimals),
            ),
        list, TEXTJOIN(" ", , int_part, dec_part),
        output, SWITCH(mode,
            0, TOROW(VALUE(TEXTSPLIT(list, " "))),
            1, TOCOL(VALUE(TEXTSPLIT(list, " ")))
            ),
        output
    )
);

/* MANT:

Returns the decimal fraction of the LookupArray
if [sign] = 1 preserves the sign of the input the result

E.g. MANT(3.1415) = 0.1415; MANT(-3.1415,1) = -0.1415
*/

MANT = LAMBDA(input, [precision], [sign],
    LET(
        sign, IF(OR(ISOMITTED(sign), sign > 1), 0, sign),
        precision, IF(ISOMITTED(precision), 3, precision),
        dec_part, SWITCH(
            sign,
            0, ABS(ROUND(input - TRUNC(input), precision)),
            1, ROUND(input - TRUNC(input), precision),
            
        ),
        dec_part
    )
);

DIGITAL_ROOT = LAMBDA(input,
    LET(
        mode, IF(input < 1, 1, 0),
        input, SWITCH(mode, 0, TRUNC(input), 1, VALUE(SUBSTITUTE(input, ".", "")), ),
        sub, SUMPRODUCT(--MID(input, SEQUENCE(LEN(input)), 1)),
        root, 1 + MOD(ABS(sub) - 1, 9),
        root
    )
);

/* DIGITAL_SUM:

Calculates the Digital Subroot (2-digit root) of the input
Returns the same result as SUMDIGITS
*/

DIGITAL_SUM = LAMBDA(input,
    LET(
        mode, IF(input < 1, 1, 0),
        input, SWITCH(mode, 0, TRUNC(input), 1, VALUE(SUBSTITUTE(input, ".", "")), ),
        IF(
            AND(input <> 11, input <> 22, input <> 33),
            SUMPRODUCT(--MID(input, SEQUENCE(LEN(input)), 1)),
            input
        )
    )
);


/* ROOT_NUMERO:

Calculates the numerological root of the input
*/

ROOT_NUMERO = LAMBDA(input,
    LET(
        TempTot, SUMPRODUCT(--MID(input, SEQUENCE(LEN(input)), 1)),
        fmt, "#",
        IF(
            input < 10,
            TEXT(input, fmt),
            TEXTJOIN(
                "/",
                ,
                IF(
                    (input = 11) + (input = 22) + (input = 33),
                    TEXT(input, fmt),
                    IF(TempTot < 10, "", TempTot)
                ),
                TEXT(1 + MOD(ABS(input) - 1, 9), fmt)
            )
        )
    )
);

/* SUM_INTEGERS:

Returns the sum of all integers up to and including the input value
*/

SUM_INTEGERS = LAMBDA(input, [mode],
    LET(
        mode, IF(OR(ISOMITTED(mode), mode > 2), 0, mode),
        even_ubound, IF(ISEVEN(input), input, input - 1),
        odd_ubound, IF(ISODD(input), input, input - 1),
        output, SWITCH(
            mode,
            0, (input * (input + 1)) / 2,
            1, (even_ubound * (even_ubound + 2)) / 4,
            2, ((odd_ubound + 1) / 2) ^ 2
        ),
        output
    )
);

POLYGONAL = LAMBDA(s, n,

((s - 2) * ((n ^ 2 - n) / 2)) + n

);

/* SUM_RANGE:

Returns the sum of an arithmetic progression between lbound and ubound
    incrementing each item by the specified increment

E.g. SUM_INC_RANGE(4,20,3) -> 69, which is:
    the sum of all integers starting with 4
    and incrementing by 3
    up to the largest item less-than-or-equal-ubound,
    i.e. SUM(4, 7, 10, 13, 16, 19) = 69
*/

SUM_RANGE = LAMBDA(lbound, [ubound], [increment],
    LET(
        u_bound, IF(ISOMITTED(ubound), lbound, ubound),
        lbound, IF(ISOMITTED(ubound), 1, lbound),
        increment, IF(ISOMITTED(increment), 1, increment),
        length, TRUNC((u_bound - lbound) / increment) + 1,
        total, (length / 2) * ((2 * lbound) + ((length - 1) * increment)),
        total
    )
);

/* POLYROOTS
Returns the roots of a polynomial
*/

POLYROOTS = LAMBDA(a, b, c,
    LET(
        discrim, b ^ 2 - 4 * a * c,
        x_1, IF(discrim >= 0, (-b + SQRT(discrim)) / (2 * a), ""),
        x_2, IF(discrim > 0, (-b - SQRT(discrim)) / (2 * a), ""),
        output, IF(
            discrim < 0,
            "NONE",
            IF(
                discrim = 0,
                x_1,
                TRANSPOSE(TEXTSPLIT(FIXED(x_1, 3) & IF(x_2 <> "", " " & FIXED(x_2, 3), ""), " "))
            )
        ),
        output
    )
);


TO_MANTISSA = LAMBDA(input, [precision],
    LET(
        precision, IF(ISOMITTED(precision), len(input)+3, precision),
        output, IF(input < 1,
            input,
            input/10^(trunc(log(input))+1)
        ),
        output
    )
);




FACTORS = LAMBDA(input,

    LET(
        x, SEQUENCE(
            input
        ),
        y, IF(
            MOD(
                input,
                x
            ) = 0,
            x,
            ""
        ),
        TEXTJOIN(",", TRUE, y)
    )
);





ROOT = LAMBDA(n, [x],

LET(
    result, IF(ISOMITTED(x),
    sqrt(n),
    n^(1/x)),
    result
)
);

APPROXIMATE_FRACTION = LAMBDA(input, [mode], [prec],
    LET(
        mode, IF((mode > 1) + (ISOMITTED(mode)), 0, mode),
        prec, IF(ISOMITTED(prec), 3, prec),
        fmt, CONCAT("?/", REPT("?", prec)),
        fraction, SWITCH(mode, 0, TEXT(input, fmt), 1, TEXT(MOD(input, 1), fmt)),
        output, SWITCH(
            mode,
            0, fraction,
            1, IF(QUOTIENT(input, 1) <> 0, TEXTJOIN("-", , QUOTIENT(input, 1), fraction), fraction)
        ),
        output
    )
);

FIND_PCT = LAMBDA(target, max, min, [prec],

LET(
    prec, if(
        (isomitted(prec))+
        (prec<0),
        3,
        prec
        ),
    result, round((target-min)/(max - min),prec),
    result
    )
);

LIST_DIVISORS = LAMBDA(input, [mode],
    
    /* lists the divisors of the input number
    mode:
        0 - spills results in multiple rows
        1 - spills results in multiple columns
        2 - formats results as an array constant: {x, y, z}

*/
    LET(
        mode, IF((ISOMITTED(mode) + (mode > 2) + (mode < 0)), 0, mode),
        list, SORT(FILTER(SEQUENCE(input, 1), MOD(input, SEQUENCE(input, 1)) = 0)),
        output, SWITCH(mode, 0, list, 1, TRANSPOSE(list), 2, "{" & TEXTJOIN(", ", , list) & "}", ),
        output
    )
);

METALLIC_MEAN = LAMBDA(input, [type], [precision],
    LET(
        type, IF((ISOMITTED(type)+(type<0)+(type>1)), 0, type),
        precision, IF(ISOMITTED(precision), 3, precision),
        return, SQRT(1 + ((TRUNC(input) ^ 2) / 4)) +
            (TRUNC(input) / 2),
        output, switch(type,
            0, return,
            1, 1/return
            ),
        output
    )
);

PCT_SOLVER= LAMBDA(one, two, three, [mode], [prec],

/* INPUT MODES
    0: target, upper, lower
    1: pct, upper, lower
    2: target, pct, upper
    3: target, pct, lower
*/

LET(
    prec, if(
    (isomitted(prec))+
    (prec<0),
    3,
    prec
    ),
    mode, if(
        (isomitted(mode)+
        (mode<0)+
        (mode>3)),
        0,
        mode
    ),
    output, switch(mode,
        0, round((one-three)/(two - three),prec),
        1, round((one*(two-three))+three, prec),
        2, round((one-(two*three))/(1-two), prec),
        3, round(((one-three)/two)+three, prec)
    ),
    output 
)
);

RECIP = LAMBDA(input, 1 / input);

TOFRAC = LAMBDA(input, [denom],
    LET(
        denom, IF(ISOMITTED(denom), 64, TRUNC(denom)),
        comfact, GCD(TRUNC(input * denom), denom),
        numfinal, TRUNC(input * denom / comfact),
        denomfinal, denom / comfact,
        output, IF(numfinal = 0, "#NONE!", TEXT(numfinal, "0") & "/" & TEXT(denomfinal, "0")),
        output
    )
);

ELLIPSE_ECC = LAMBDA(major, minor,

LET(
    a, IF(major < minor, minor, major),
    b, IF(a = minor, major, minor),
    ecc, SQRT(1 - (b / a) ^ 2),
    ecc
    )
);

ELLIPSE_SMINOR = LAMBDA(major, eccentricity,

    major * SQRT(1 - POWER(eccentricity, 2))
    
);

ELLIPSE_AE = LAMBDA(a, e, [precision],
    LET(
        precision, IF(ISOMITTED(precision), 3, precision),
        /*labels, transpose({"a}", "b:", "c:", "d:", "e}", "f:", "g:", "h:", "i:", "j:", "l:", "m:", "n:", "p~", "q:", "s:", "t:", "v:"}),*/
        labels, {
                "semi-major axis (a)->";
                "semi-minor axis (b)";
                "linear eccentricity (c)";
                "apoapsis (d)";
                "eccentricity (e)->";
                "flattening (f)";
                "periapsis (g)";
                "principal axis (h)";
                "major axis (i)";
                "minor axis (j)";
                "semi-latus rectum (l)";
                "directrix (m)";
                "focal parameter (n)";
                "perimeter (p)~";
                "latus rectum (q):";
                "ratio of apsides (r = d / g):";
                "s = n - g:"
                /*"t:",*/
                
            },

        b, a * SQRT(1 - e ^ 2),
        c, SQRT(a ^ 2 - b ^ 2),
        d, a * (1 + e),
        f, (a - b) / a,
        g, a * (1 - e),
        h, 2 * a * e,
        i, 2 * a,
        j, 2 * b,
        l, b ^ 2 / a,
        m, a / e,
        n, b ^ 2 / c,
        p, 2 * PI() * SQRT((a ^ 2 + b ^ 2) / 2),
        q, j ^ 2 / i,
        s, n - g,
        t, (1 - e) / (1 + e),
        r, (1 + e) / (1 - e),
        attribs, TEXTJOIN(",", , a, b, c, d, e, f, g, h, i, j, l, m, n, p, q, r, s),
        fmt, "0." & REPT("#", precision),
        values, TRANSPOSE(VALUE(TEXT(TEXTSPLIT(attribs, ","), fmt))),
        /*values, transpose(round(value((textsplit(attribs,","))), precision)),*/
        CHOOSE({1, 2}, labels, values)
    )
);

ELLIPSE_AB = LAMBDA(a, b, [precision],
    LET(
        precision, IF(ISOMITTED(precision), 3, precision),
        /*labels, transpose({"a}", "b:", "c:", "d:", "e}", "f:", "g:", "h:", "i:", "j:", "l:", "m:", "n:", "p~", "q:", "s:", "t:", "v:"}),*/
        labels, {
                "semi-major axis (a)->";
                "semi-minor axis (b)->";
                "linear eccentricity (c)";
                "apoapsis (d)";
                "eccentricity (e)";
                "flattening (f)";
                "periapsis (g)";
                "principal axis (h)";
                "major axis (i)";
                "minor axis (j)";
                "semi-latus rectum (l)";
                "directrix (m)";
                "focal parameter (n)";
                "perimeter (p)~";
                "latus rectum (q):";
                "ratio of apsides (r = d / g):";
                "s = n - g:"
                /*"t:",*/
                
            },

        e, SQRT(1 - (b ^ 2 / a ^ 2)),
        c, SQRT(a ^ 2 - b ^ 2),
        d, a * (1 + e),
        f, (a - b) / a,
        g, a * (1 - e),
        h, 2 * a * e,
        i, 2 * a,
        j, 2 * b,
        l, b ^ 2 / a,
        m, a / e,
        n, b ^ 2 / c,
        p, 2 * PI() * SQRT((a ^ 2 + b ^ 2) / 2),
        q, j ^ 2 / i,
        s, n - g,
        t, (1 - e) / (1 + e),
        r, (1 + e) / (1 - e),
        attribs, TEXTJOIN(",", , a, b, c, d, e, f, g, h, i, j, l, m, n, p, q, r, s),
        fmt, "0." & REPT("#", precision),
        values, TRANSPOSE(VALUE(TEXT(TEXTSPLIT(attribs, ","), fmt))),
        /*values, transpose(round(value((textsplit(attribs,","))), precision)),*/
        CHOOSE({1, 2}, labels, values)
    )
);

RADIUS_OF_SPHERE = LAMBDA(v, [prec],

LET(
    prec, if(
        (isomitted(prec))+
        (prec<0),
        3,
        prec),    
    radius, round(power((v*3)/(4*pi()),1/3), prec),
    radius
    )
);

VOLUME_OF_SPHERE = LAMBDA(r, [prec],
    LET(
        prec, IF(ISOMITTED(prec)+(prec<0), 3, prec),
        v, (4/3)*PI()*r^3,
        ROUND(v, prec)
    )
);


SERIES_SUM = LAMBDA(lbound, [ubound], [increment],
    LET(
        u_bound, IF(ISOMITTED(ubound), lbound, ubound),
        lbound, IF(ISOMITTED(ubound), 1, lbound),
        increment, IF(ISOMITTED(increment), 1, increment),
        length, TRUNC((u_bound - lbound) / increment) + 1,
        total, (length / 2) * ((2 * lbound) + ((length - 1) * increment)),
        total
    )
);

FIBSEQ = LAMBDA(n,
    IF(n < 1,
        {},
        IF(n = 1,
            {0},
            LET(
                fibSeq, REDUCE({0, 1}, SEQUENCE(n - 2),
                    LAMBDA(acc, i,
                        LET(
                            next, INDEX(acc, i) + INDEX(acc, i + 1),
                            HSTACK(acc, next)
                        )
                    )
                ),
                fibSeq
            )
        )
    )
);

SUM_AP_UBOUND = LAMBDA(lbound, length, increment,

    LET(ubound, lbound + (length - 1) * increment,
    ubound)    
);

METALS_LIST = LAMBDA([max], [precision],
    LET(
        max, IF(ISOMITTED(max), 9, max),
        precision, IF(ISOMITTED(precision), 5, precision),
        prec, "#." & REPT("0", precision),
        list, SEQUENCE(max, , 1),
        output, VALUE(
            TEXT(
                BYROW(
                    list,
                    LAMBDA(x,
                        SQRT(1 + (x ^ 2) / 4) + (x / 2)
                    )
                ),
                prec
            )
        ),
        output
    )
);

