/* ASTRO_HAB_INDEX:
   Purpose: Calculates a normalized habitability index based on a planet's orbital distance
            relative to a star's nucleal (habitable zone anchor) radius.
   Returns: A scalar habitability index (number), or "U/I" if uninhabitable

   Parameters:
   - orbital_dist (required): Orbital distance (in AU)
   - nucleal_radius (optional): Nucleal zone radius (in AU); defaults to 1.0
   - prec (optional): Number of decimal places to round the output (default = 3)

   Notes:
   - Index ≈ 1.0 indicates ideal alignment with habitable zone.
   - Values < 1 are inside the optimal band (potentially too hot).
   - Values > 1 are outside the optimal band (potentially too cold).
   - If the orbit is too deep inside the inner boundary, returns "U/I".
   - Uses a piecewise function for smooth falloff across boundary.

   Example:
   ASTRO_HAB_INDEX(1.0)              → 1.000  (assumes nucleal_radius = 1)
   ASTRO_HAB_INDEX(0.75, 1.0)        → 0.500
   ASTRO_HAB_INDEX(2.5, 1.0)         → 1.628
   ASTRO_HAB_INDEX(0.25, 1.0)        → "U/I"
*/

ASTRO_HAB_INDEX = LAMBDA(orbital_dist, [nucleal_radius], [prec],
    LET(
        rounding_precision, IF(ISOMITTED(prec), 3, prec),             /* Default to 3 decimals */
        nucleal_radius, IF(ISOMITTED(nucleal_radius), 1, nucleal_radius), /* Default to 1 AU if omitted */

        is_inner_orbit, IF(orbital_dist < nucleal_radius, TRUE, FALSE),  /* Determine position */

        habitability_index,                                           /* Piecewise function */
            IF(
                is_inner_orbit,
                (2 * orbital_dist / nucleal_radius) - 1,              /* Inside HZ model */
                (orbital_dist / (-3.85 * nucleal_radius)) + (4.85 / 3.85)  /* Outside HZ model */
            ),

        final_result,                                                 /* Handle invalid/valid cases */
            IF(habitability_index <= 0, "U/I", ROUND(habitability_index, rounding_precision)),

        final_result
    )
);

/* ASTRO_SPECTRAL_DISTRIBUTION
   ------------------------------------------
   Distributes a total stellar population across the seven primary spectral classes
   (O, B, A, F, G, K, M) based on inverse population factors. Returns a two-column
   array of class labels and calculated star counts.

   Syntax:
     ASTRO_SPECTRAL_DISTRIBUTION(total, [precision])

   Parameters:
     total      : Total number of stars to be distributed.
     precision  : Optional (default = 3). Number of decimal places to round each count.

   Returns:
     A vertical array with two columns:
       - Column 1: Spectral class labels (Total, O, B, A, F, G, K, M)
       - Column 2: Number of stars in each class (rounded to the specified precision)

   Examples:
     ASTRO_SPECTRAL_DISTRIBUTION(1000)
       → {"Total", "O", "B", "A", "F", "G", "K", "M"} paired with {1000, 0.333, 1.25, ...}

     ASTRO_SPECTRAL_DISTRIBUTION(5000, 0)
       → {"Total", "O", "B", "A", "F", "G", "K", "M"} paired with rounded integers

   Notes:
     - The distribution is based on inverse weighting factors:
         O: 1/3000000
         B: 1/800
         A: 1/160
         F: 1/33
         G: 1/13
         K: 1/8
         M: 1/1.3153...
     - These values approximate relative frequency and abundance of star types.
     - "Total" is included as the first row of the output for easy summation/audit.
     - Intended for use in modeling star system populations, galaxy seeding, or teaching the distribution of stellar types.
*/


ASTRO_SPECTRAL_DISTRIBUTION = LAMBDA([anchor_class], [anchor_count], [decimal_places],
    LET(
        // === Default parameters ===
        anchor_class, IF(ISOMITTED(anchor_class), "$", UPPER(anchor_class)),
        anchor_count, IF(ISOMITTED(anchor_count), 1, anchor_count),
        decimal_places, IF(ISOMITTED(decimal_places), 3, decimal_places),

        // === Spectral class array and base frequencies (empirical) ===
        arr_classes, {"O"; "B"; "A"; "F"; "G"; "K"; "M"},
        arr_base_pct, {0.00003; 0.13; 0.6; 3.0; 7.6; 12.1; 76.27},
        arr_base_frac, BYROW(arr_base_pct, LAMBDA(x, x / 100)),

        // === Lookup scaling factor for a specific anchor type
        anchor_freq, XLOOKUP(anchor_class, arr_classes, arr_base_frac, 1),
        scaling_factor, anchor_count / anchor_freq,

        // === Scaled distribution — normalize or apply user-defined scale
        scaled, IF(anchor_class = "$", arr_base_frac, BYROW(arr_base_frac, LAMBDA(x, x * scaling_factor))),

        // === Final output
        output, HSTACK(arr_classes, ROUND(scaled, decimal_places)),
        output
    )
);


/* ASTRO_CALC_TEMP:
   Purpose: Returns the interpolated effective temperature (in Kelvin) for a given stellar subclass
            (e.g. "G7.3"), using hardcoded high-temperature anchors and span values between subclasses.

   Returns: A numeric temperature in Kelvin, interpolated using linear scaling within the specified subclass.

   Parameters:
   - subclass (required): A string representing a spectral subclass. Accepts formats like "F5", "K2.6", "M8.9", etc.

   Notes:
   - Temperature data is based on empirical subclass anchors for types O3 through M9.
   - The function supports fractional subclass input and assumes linear falloff between subclass temperature anchors.
   - The high temperature (`T_high`) is retrieved for the base subclass (e.g., "G7"), and interpolation uses:
       T = T_high - (fraction * span)
   - Handles inputs with or without a decimal point (e.g., "F6" = "F6.0").
   - Internally uses XLOOKUP over a matrix built from hardcoded subclass labels, temperatures, and spans.

   Example:
   ASTRO_CALC_TEMP("G7.3")   → 5529
   ASTRO_CALC_TEMP("O4.4")   → 42300
   ASTRO_CALC_TEMP("F8.45")  → 6121.5
   ASTRO_CALC_TEMP("M8.6")   → 2456
*/


ASTRO_CALC_TEMP = LAMBDA(subclass,
  LET(
    // --- Hardcoded spectral subclass arrays ---

    arrTypes, {
      "O3"; "O4"; "O5"; "O6"; "O7"; "O8"; "O9";
      "B0"; "B1"; "B2"; "B3"; "B4"; "B5"; "B6"; "B7"; "B8"; "B9";
      "A0"; "A1"; "A2"; "A3"; "A4"; "A5"; "A6"; "A7"; "A8"; "A9";
      "F0"; "F1"; "F2"; "F3"; "F4"; "F5"; "F6"; "F7"; "F8"; "F9";
      "G0"; "G1"; "G2"; "G3"; "G4"; "G5"; "G6"; "G7"; "G8"; "G9";
      "K0"; "K1"; "K2"; "K3"; "K4"; "K5"; "K6"; "K7"; "K8"; "K9";
      "M0"; "M1"; "M2"; "M3"; "M4"; "M5"; "M6"; "M7"; "M8"; "M9"
    },

    // High effective temperatures (K) for each subclass
    arrTHigh, {
      44900; 42900; 41400; 39500; 37100; 35100; 33300;
      31400; 26000; 20600; 17000; 16400; 15700; 14500; 14000; 12300; 10700;
      9700; 9300; 8800; 8600; 8250; 8100; 7910; 7760; 7590; 7400;
      7220; 7020; 6820; 6750; 6670; 6550; 6350; 6280; 6180;
      6050; 5930; 5860; 5770; 5720; 5680; 5660; 5600; 5550; 5480;
      5380; 5270; 5170; 5100; 4830; 4600; 4440; 4300; 4100; 3990;
      3930; 3850; 3660; 3560; 3430; 3210; 3060; 2810; 2680; 2570; 2380
    },

    // Temperature span to the next subclass (K)
    arrSpan, {
      2000; 1500; 1900; 2400; 2000; 1800; 1900;
      5400; 5400; 3600; 600; 700; 1200; 500; 1700; 1600; 1000;
      400; 500; 200; 350; 150; 190; 150; 170; 190; 180;
      200; 200; 70; 80; 120; 200; 70; 100; 130;
      120; 70; 90; 50; 40; 20; 60; 50; 70; 100;
      110; 100; 70; 270; 230; 160; 140; 200; 110; 60;
      80; 190; 100; 130; 220; 150; 250; 130; 110; 190; 280
    },

    // Bundle into a single matrix for clean lookup
    mtxStars, HSTACK(arrTypes, arrTHigh, arrSpan),

    // --- Input normalization and parsing ---

    no_space, SUBSTITUTE(subclass, " ", ""),                  // Trim whitespace
    dot_pos, FIND(".", no_space & ".0"),                      // Ensure fractional part is detected even for whole subclasses
    base, LEFT(no_space, dot_pos - 1),                        // Extract root subclass, e.g., "G7" from "G7.3"
    f, VALUE("0." & MID(no_space, dot_pos + 1, LEN(no_space))), // Convert decimal string to numeric (e.g., 0.3)

    // --- Lookup high temp and span from matrix ---

    T_high, XLOOKUP(base, INDEX(mtxStars,,1), INDEX(mtxStars,,2)), // e.g. 5550 for "G7"
    span,   XLOOKUP(base, INDEX(mtxStars,,1), INDEX(mtxStars,,3)), // e.g. 70 for "G7"

    // --- Interpolation: T = T_high - f * span ---

    result, T_high - (f * span),

    result
  )
);

/* ASTRO_TYPE_FROM_TEMP:
   Purpose: Returns the interpolated stellar spectral subclass (e.g. "G7.3") for a given effective temperature in Kelvin.

   Returns: A string representing the estimated spectral subclass, optionally with decimal precision.

   Parameters:
   - temp (required): A numeric temperature in Kelvin.
   - decimals (optional): Number of decimal places to include in the subclass (default = 3).

   Notes:
   - The function matches the temperature to the correct spectral subclass range by checking which high-temp band it falls within.
   - It then linearly interpolates the decimal portion of the subclass using:
       fractional = (T_high - temp) / span
   - Uses hardcoded temperature anchors and spans across spectral types O3–M9.
   - Supports high precision and normalization for fractional subclasses like "K4.376".

   Example:
   ASTRO_TYPE_FROM_TEMP(42300)   → "O4.400"
   ASTRO_TYPE_FROM_TEMP(5529)    → "G7.300"
   ASTRO_TYPE_FROM_TEMP(6121.5)  → "F8.450"
   ASTRO_TYPE_FROM_TEMP(2456, 1) → "M8.6"

   Dependencies:
   - Uses XMATCH + MAP for logical range detection.
   - Assumes temperature decreases monotonically across subclass sequence.
*/


ASTRO_TYPE_FROM_TEMP = LAMBDA(temp, [decimals],
  LET(
    // --- Hardcoded spectral subclass data ---
    arrTypes, {
      "O3"; "O4"; "O5"; "O6"; "O7"; "O8"; "O9";
      "B0"; "B1"; "B2"; "B3"; "B4"; "B5"; "B6"; "B7"; "B8"; "B9";
      "A0"; "A1"; "A2"; "A3"; "A4"; "A5"; "A6"; "A7"; "A8"; "A9";
      "F0"; "F1"; "F2"; "F3"; "F4"; "F5"; "F6"; "F7"; "F8"; "F9";
      "G0"; "G1"; "G2"; "G3"; "G4"; "G5"; "G6"; "G7"; "G8"; "G9";
      "K0"; "K1"; "K2"; "K3"; "K4"; "K5"; "K6"; "K7"; "K8"; "K9";
      "M0"; "M1"; "M2"; "M3"; "M4"; "M5"; "M6"; "M7"; "M8"; "M9"
    },

    arrTHigh, {
      44900; 42900; 41400; 39500; 37100; 35100; 33300;
      31400; 26000; 20600; 17000; 16400; 15700; 14500; 14000; 12300; 10700;
      9700; 9300; 8800; 8600; 8250; 8100; 7910; 7760; 7590; 7400;
      7220; 7020; 6820; 6750; 6670; 6550; 6350; 6280; 6180;
      6050; 5930; 5860; 5770; 5720; 5680; 5660; 5600; 5550; 5480;
      5380; 5270; 5170; 5100; 4830; 4600; 4440; 4300; 4100; 3990;
      3930; 3850; 3660; 3560; 3430; 3210; 3060; 2810; 2680; 2570; 2380
    },

    arrSpan, {
      2000; 1500; 1900; 2400; 2000; 1800; 1900;
      5400; 5400; 3600; 600; 700; 1200; 500; 1700; 1600; 1000;
      400; 500; 200; 350; 150; 190; 150; 170; 190; 180;
      200; 200; 70; 80; 120; 200; 70; 100; 130;
      120; 70; 90; 50; 40; 20; 60; 50; 70; 100;
      110; 100; 70; 270; 230; 160; 140; 200; 110; 60;
      80; 190; 100; 130; 220; 150; 250; 130; 110; 190; 280
    },

    // --- Determine match index ---
    temp_in_range,
      MAP(SEQUENCE(ROWS(arrTHigh)),
        LAMBDA(i,
          AND(
            INDEX(arrTHigh, i) >= temp,
            temp > INDEX(arrTHigh, i) - INDEX(arrSpan, i)
          )
        )
      ),
    idx, XMATCH(TRUE, temp_in_range),

    // --- Lookup type and compute fraction ---
    full_type, INDEX(arrTypes, idx),
    T_high, INDEX(arrTHigh, idx),
    span, INDEX(arrSpan, idx),
    f, (T_high - temp) / span,

    // --- Format fractional part ---
    dec, IF(ISOMITTED(decimals), 3, decimals),
    format_string, "." & REPT("0", dec),
    subclass, full_type & TEXT(f, format_string),

    subclass
  )
);


/* ASTRO_DISPLAY_SPECTRAL:
   Purpose: Displays spectral subclass temperature and span data across stellar classifications.
            Can return either the full spectral matrix (O3–M9) or a filtered two-column view.

   Returns: 
   - If type is omitted: Wide matrix of spectral classes (O to M), 10 subclasses each
   - If type is provided: Two-column table with Temperature and Span for the requested class

   Parameters:
   - type (optional): One of {"O","B","A","F","G","K","M"} to limit output to that spectral group

   Notes:
   - Temperatures are high-end values for each subclass (real-world inspired, smoothed data).
   - Span is the Kelvin difference between a subclass and the next cooler one.
   - If no type is specified, output is organized as a visual reference table.
   - Uses VSTACK and HSTACK internally for clean structure; replaces previous separated versions.
   - This function supersedes: ASTRO_DISPLAY_BASE_DATA, _SEPARATED, and _BY_TYPE.

   Example:
   ASTRO_DISPLAY_SPECTRAL()        → Returns full O3–M9 subclass chart
   ASTRO_DISPLAY_SPECTRAL("G")     → Returns temperature and span for G0–G9
   ASTRO_DISPLAY_SPECTRAL("F")     → F0–F9 classification metrics
*/

ASTRO_DISPLAY_SPECTRAL = LAMBDA([type],
  LET(
    // --- Define spectral types and build helpers ---
    Types, {"O";"B";"A";"F";"G";"K";"M"},
    Headers, TRANSPOSE(VSTACK(" ", Types)),
    FindCol, MAKEARRAY(COUNTA(Types), 2, LAMBDA(r, c, IF(c = 1, INDEX(Types, r), r))),

    // --- Raw star subclass data ---
    arrTypes, {
      "O"; "O"; "O"; "O3"; "O4"; "O5"; "O6"; "O7"; "O8"; "O9";
      "B0"; "B1"; "B2"; "B3"; "B4"; "B5"; "B6"; "B7"; "B8"; "B9";
      "A0"; "A1"; "A2"; "A3"; "A4"; "A5"; "A6"; "A7"; "A8"; "A9";
      "F0"; "F1"; "F2"; "F3"; "F4"; "F5"; "F6"; "F7"; "F8"; "F9";
      "G0"; "G1"; "G2"; "G3"; "G4"; "G5"; "G6"; "G7"; "G8"; "G9";
      "K0"; "K1"; "K2"; "K3"; "K4"; "K5"; "K6"; "K7"; "K8"; "K9";
      "M0"; "M1"; "M2"; "M3"; "M4"; "M5"; "M6"; "M7"; "M8"; "M9"
    },

    arrTHigh, {
      ""; ""; ""; 44900; 42900; 41400; 39500; 37100; 35100; 33300;
      31400; 26000; 20600; 17000; 16400; 15700; 14500; 14000; 12300; 10700;
      9700; 9300; 8800; 8600; 8250; 8100; 7910; 7760; 7590; 7400;
      7220; 7020; 6820; 6750; 6670; 6550; 6350; 6280; 6180;
      6050; 5930; 5860; 5770; 5720; 5680; 5660; 5600; 5550; 5480;
      5380; 5270; 5170; 5100; 4830; 4600; 4440; 4300; 4100; 3990;
      3930; 3850; 3660; 3560; 3430; 3210; 3060; 2810; 2680; 2570; 2380
    },

    arrSpan, {
      ""; ""; ""; 2000; 1500; 1900; 2400; 2000; 1800; 1900;
      5400; 5400; 3600; 600; 700; 1200; 500; 1700; 1600; 1000;
      400; 500; 200; 350; 150; 190; 150; 170; 190; 180;
      200; 200; 70; 80; 120; 200; 70; 100; 130;
      120; 70; 90; 50; 40; 20; 60; 50; 70; 100;
      110; 100; 70; 270; 230; 160; 140; 200; 110; 60;
      80; 190; 100; 130; 220; 150; 250; 130; 110; 190; 280
    },

    // --- If no type is specified, display full table ---
    formattedData, BYROW(HSTACK(arrTypes, arrTHigh, arrSpan),
      LAMBDA(row, TEXTJOIN("; ", TRUE, TEXT(INDEX(row, 2), "0"), TEXT(INDEX(row, 3), "0")))
    ),

    Numbers, SEQUENCE(10,1,0,1),
    O_Stars, FILTER(formattedData, LEFT(arrTypes,1)="O"),
    B_Stars, FILTER(formattedData, LEFT(arrTypes,1)="B"),
    A_Stars, FILTER(formattedData, LEFT(arrTypes,1)="A"),
    F_Stars, FILTER(formattedData, LEFT(arrTypes,1)="F"),
    G_Stars, FILTER(formattedData, LEFT(arrTypes,1)="G"),
    K_Stars, FILTER(formattedData, LEFT(arrTypes,1)="K"),
    M_Stars, FILTER(formattedData, LEFT(arrTypes,1)="M"),

    fullTable, VSTACK(Headers, HSTACK(Numbers,O_Stars, B_Stars, A_Stars, F_Stars, G_Stars, K_Stars, M_Stars)),

    // --- If type is specified, just return two-column breakdown ---
    temps, FILTER(arrTHigh, LEFT(arrTypes, 1) = type),
    spans, FILTER(arrSpan, LEFT(arrTypes, 1) = type),
    typeHead, HSTACK(type, "span"),
    slimTable, VSTACK(typeHead, HSTACK(temps, spans)),

    // --- Final output: full table or filtered columns
    result, IF(ISBLANK(type), fullTable, slimTable),

    result
  )
);

/* ASTRO_STAR_ATTRIBUTES

   Purpose:
   Calculates all key stellar parameters from a single known value — temperature, mass, radius,
   luminosity, or lifetime — using empirical power-law scaling relationships based on the Sun.

   Parameters:
   - mode     (required): A string indicating the input attribute type:
       "K" — Effective temperature (Kelvin)
       "T" — Normalized temperature (T / 5770 K)
       "M" — Mass (solar units)
       "R" — Radius (solar units)
       "L" — Luminosity (solar units)
       "V" — Main-sequence lifetime (solar units)
   - input    (required): A numeric value representing the input attribute (must match the mode).
   - precision (optional): Number of decimal places to round output values. Default = 6.

   Returns:
   A two-column array with labeled stellar parameters (K, T, M, R, L, V),
   with the input attribute flagged with a ➔ arrow for clarity.

   Method:
   The function normalizes the input value to a solar-relative temperature (`Tnorm`)
   and derives the remaining parameters from empirical exponents:

   - K = Tnorm × 5770
   - M = Tnorm²
   - R = Tnorm^1.8
   - L = Tnorm^7.6
   - V = Tnorm^(-5)

   Example:
   ASTRO_STAR_ATTRIBUTES("K", 9170.6052, 3)

   Output:
     K ➔   9170.605
     T     1.588
     M     2.523
     R     2.296
     L     33.006
     V     0.101

   Notes:
   - Based on simplified stellar scaling laws used in astrophysics and worldbuilding.
   - Effective temperature is scaled to 5770 K for the Sun (standard solar reference).
   - Lifetime is approximated as a power inverse of temperature: V ∝ T⁻⁵.
   - Designed for educational, speculative, and modeling purposes.

*/

ASTRO_STAR_ATTRIBUTES = LAMBDA(mode, input, [precision],
  LET(
    // Set default rounding precision
    prec, IF(ISOMITTED(precision), 6, precision),

    // Normalize input mode to upper-case for consistency
    mode, UPPER(mode),

    // Normalize input to solar-relative temperature (Tnorm)
    Tnorm, SWITCH(
      mode,
      "T", input,
      "K", input / 5770,
      "M", SQRT(input),
      "R", input ^ (1 / 1.8),
      "L", input ^ (1 / 7.6),
      "V", input ^ (-1 / 5),
      NA()
    ),

    // Now derive all other attributes from Tnorm
    K, Tnorm * 5770,
    M, Tnorm ^ 2,
    R, Tnorm ^ 1.8,
    L, Tnorm ^ 7.6,
    V, Tnorm ^ -5,

    // Round everything and format as strings
    labels, TRANSPOSE({"K", "T", "M", "R", "L", "V"}),
        output_values, VSTACK(
        ROUND(K, prec),
        ROUND(Tnorm, prec),
        ROUND(M, prec),
        ROUND(R, prec),
        ROUND(L, prec),
        ROUND(V, prec)
        ),

    // --- Labels with arrow on selected mode ---
        flagged_labels, BYROW(labels, LAMBDA(row, IF(row = mode, row & " ➔", row))),


    // Return labeled table
    CHOOSE({1, 2}, flagged_labels, output_values)
  )
);


/* ASTRO_HABITABLE_ZONES:
   Purpose: Returns habitable zone data based on stellar luminosity.

   Modes:
   - "TABLE"    → Returns a full table of inner/outer/avg/span distances for zones Z0–Z5.
   - "VERTICAL" → Returns a vertical list of scaled distances, with N-> marking the nucleal radius.
   - "HORIZONTAL" → Returns a horizontal row of the same values for use in inline display.

   Parameters:
   - mode (required): One of "TABLE", "VERTICAL", or "HORIZONTAL".
   - lum (optional): Stellar luminosity in solar units. Required for VERTICAL and HORIZONTAL.
   - precision (optional): Number of decimal places (default = 3)

   Zones (Z0–Z5) represent nested circumstellar habitability bands:
   - Z0: (too hot)
   - Z1: (inner edge)
   - Z2: (inner temperate)
   - Z3: (outer temperate)
   - Z4: (outer edge)
   - Z5: (too cold)

   Example usage:
   ASTRO_HABITABLE_ZONES("TABLE")            → Returns base reference chart
   ASTRO_HABITABLE_ZONES("VERTICAL", 1.25)   → Returns vertical distances scaled to star with L = 1.25
   ASTRO_HABITABLE_ZONES("HORIZONTAL", 1.25) → Returns same as row

   Notes:
   - Nucleal radius is sqrt(L) and used as anchor between Z2–Z3.
   - Input is ignored for mode "TABLE".
*/

ASTRO_HABITABLE_ZONES = LAMBDA(mode, [lum], [precision],
  LET(
    mode, UPPER(mode),
    prec, IF(ISOMITTED(precision), 3, precision),

    // Zone coefficients
    zone_labels, {"Z0"; "Z1"; "Z2"; "Z3"; "Z4"; "Z5"},
    inner_factors, {0; 0.5; 0.75; 0.95; 1.385; 1.77},
    outer_factors, {0.5; 0.75; 0.95; 1.385; 1.77; 4.85},

    // Precompute average and span
    avg_factors, (inner_factors + outer_factors) / 2,
    span_factors, outer_factors - inner_factors,

    // Nucleal (for scaling)
    nucleal, SQRT(IF(ISOMITTED(lum), 1, lum)),

    // Compute scaled distances
    inner_scaled, ROUND(nucleal * inner_factors, prec),
    outer_scaled, ROUND(nucleal * outer_factors, prec),
    avg_scaled, ROUND(nucleal * avg_factors, prec),
    span_scaled, ROUND(nucleal * span_factors, prec),

    // Formatted output
    vertical_labels, {"0: ", "1: ", "2: ", "N ➔", "3: ", "4: ", "5: "},
    vertical_values, VSTACK(
    ROUND(INDEX(inner_factors, 2) * nucleal, prec),
    ROUND(INDEX(inner_factors, 3) * nucleal, prec),
    ROUND(INDEX(inner_factors, 4) * nucleal, prec),
    ROUND(nucleal, prec),
    ROUND(INDEX(outer_factors, 4) * nucleal, prec),
    ROUND(INDEX(outer_factors, 5) * nucleal, prec),
    ROUND(INDEX(outer_factors, 6) * nucleal, prec)
    ),

    // Return logic
    result,
      SWITCH(
        mode,
        "STANDARD", CHOOSE(
          {1, 2, 3, 4, 5},
          VSTACK("Zone", zone_labels),
          VSTACK("Inner", inner_factors),
          VSTACK("Outer", outer_factors),
          VSTACK("Average", avg_factors),
          VSTACK("Span", span_factors)
        ),
        "VERTICAL", 
          LET(
            labels, {"0:", "1:", "2:", "N ➔", "3:", "4:", "5:"},
            scaled_values, ROUND(nucleal * {0.5, 0.75, 0.95, 1, 1.385, 1.77, 4.85}, prec),
            TRANSPOSE(VSTACK(labels, scaled_values))
        ),
        "HORIZONTAL", HSTACK(
        ROUND(INDEX(inner_factors, 2) * nucleal, prec),
        ROUND(INDEX(inner_factors, 3) * nucleal, prec),
        ROUND(INDEX(inner_factors, 4) * nucleal, prec),
        ROUND(nucleal, prec),
        ROUND(INDEX(outer_factors, 4) * nucleal, prec),
        ROUND(INDEX(outer_factors, 5) * nucleal, prec),
        ROUND(INDEX(outer_factors, 6) * nucleal, prec)
        ),
        "Invalid mode"
      ),

    result
  )
);

/* NASTRO_HABITABLE_ZONES:
   Purpose: Provides information about stellar habitable zones across multiple display modes:
            - STANDARD: Returns a fixed table of inner/outer bounds for Z0–Z5 zones in AU
            - TABLE: Scales the STANDARD zones based on stellar luminosity
            - VERTICAL: Returns a vertical list of zone labels and distances based on luminosity
            - HORIZONTAL: Returns a single-row summary of scaled distances

   Parameters:
   - mode (required): "STANDARD", "TABLE", "VERTICAL", or "HORIZONTAL"
   - lum (optional): Stellar luminosity in solar units (only required for TABLE, VERTICAL, or HORIZONTAL modes)
   - prec (optional): Number of decimal places to round distances to (default = 3)

   Example:
   ASTRO_HABITABLE_ZONES("STANDARD")
   ASTRO_HABITABLE_ZONES("TABLE", 3)
   ASTRO_HABITABLE_ZONES("VERTICAL", 3)
   ASTRO_HABITABLE_ZONES("HORIZONTAL", 3)
*/

NASTRO_HABITABLE_ZONES = LAMBDA(mode, [lum], [prec],
  LET(
    // --- Defaults ---
    dec, IF(ISOMITTED(prec), 3, prec),
    L, IF(ISOMITTED(lum), 1, lum),
    nuc, SQRT(L),

    // --- Zone base data ---
    zone_labels, {"Z0", "Z1", "Z2", "Z3", "Z4", "Z5"},
    inner_factors, {0, 0.5, 0.75, 0.95, 1.385, 1.77},
    outer_factors, {0.5, 0.75, 0.95, 1.385, 1.77, 4.85},
    avg_factors,   {0.25, 0.625, 0.85, 1.1675, 1.5775, 3.31},
    span_factors,  {0.5, 0.25, 0.2, 0.435, 0.385, 3.08},

    // --- Scaled values ---
    inner_scaled, ROUND(nuc * inner_factors, dec),
    outer_scaled, ROUND(nuc * outer_factors, dec),
    avg_scaled,   ROUND(nuc * avg_factors, dec),
    span_scaled,  ROUND(nuc * span_factors, dec),

    // --- Table: STANDARD and TABLE modes ---
    row_1, VSTACK("Zone", zone_labels),
    row_2, VSTACK("Inner", IF(mode="STANDARD", inner_factors, inner_scaled)),
    row_3, VSTACK("Outer", IF(mode="STANDARD", outer_factors, outer_scaled)),
    row_4, VSTACK("Average", IF(mode="STANDARD", avg_factors, avg_scaled)),
    row_5, VSTACK("Span", IF(mode="STANDARD", span_factors, span_scaled)),

    // --- Vertical mode output ---
    vertical_labels, {"0:", "1:", "2:", "N ➔", "3:", "4:", "5:"},
    vertical_values, ROUND({0.5, 0.75, 0.95, 1, 1.385, 1.77, 4.85} * nuc, dec),

    // --- Horizontal mode output ---
    horizontal_values, HSTACK(
      ROUND(0.5 * nuc, dec),
      ROUND(0.75 * nuc, dec),
      ROUND(0.95 * nuc, dec),
      ROUND(1 * nuc, dec),
      ROUND(1.385 * nuc, dec),
      ROUND(1.77 * nuc, dec),
      ROUND(4.85 * nuc, dec)
    ),

    // --- Final output based on mode ---
    SWITCH(
      UPPER(mode),
      "STANDARD", HSTACK(row_1, row_2, row_3, row_4, row_5),
      "TABLE",    HSTACK(row_1, row_2, row_3, row_4, row_5),
      "VERTICAL", HSTACK(vertical_labels, vertical_values),
      "HORIZONTAL", horizontal_values,
      "Invalid mode"
    )
  )
)
;

/* ASTRO_STAR_DENSITY_VOLUME
   Purpose: Given a spherical volume (or radius), calculate how many stars fit at 1 star per 250 cubic light-years.

   Parameters:
   - input (required): Either a spherical radius or a volume, depending on mode.
   - prec (optional): Decimal places for output precision (default = 3).
   - mode (optional): 
       0 = input is a volume in cubic light-years (default),
       1 = input is a radius in light-years.

   Returns:
   - A vertical array containing either:
       • [number of stars; radius] if mode = 0
       • [number of stars; volume] if mode = 1

   Example:
   ASTRO_STAR_DENSITY_VOLUME(1000)          → {4.000; 6.203}
   ASTRO_STAR_DENSITY_VOLUME(5, 2, 1)       → {2.62; 523.60}
*/

ASTRO_STAR_DENSITY_VOLUME = LAMBDA(input, [prec], [mode],
  LET(
    mode, IF(ISOMITTED(mode) + (mode < 0) + (mode > 1), 0, mode),
    prec, IF(ISOMITTED(prec) + (prec < 0), 3, prec),

    volume, IF(mode = 0, input, (4/3) * PI() * input ^ 3),
    radius, IF(mode = 1, input, ROUND(((3 * volume) / (4 * PI())) ^ (1/3), prec)),
    stars, ROUND(volume / 250, prec),

    output, SWITCH(mode,
      0, TOCOL(TEXTSPLIT(TEXTJOIN("; ", , "Stars: "&stars, "Radius: "&radius), "; ")),
      1, TOCOL(TEXTSPLIT(TEXTJOIN("; ", , "Stars: "&stars, "Volume: "&volume), "; "))
    ),

    output
  )
);

/* ASTRO_PLANET_METRICS_SAFETY
   Purpose: Calculates planetary mass, radius, density, surface gravity, and escape velocity
            from any valid pair of two known parameters.

   Parameters:
   - mode (required): A string indicating the known input pair. Acceptable values:
       "md" = Mass + Density
       "mr" = Mass + Radius
       "mg" = Mass + Gravity
       "rd" = Radius + Density
       "rg" = Radius + Gravity
       "dg" = Density + Gravity
       "dv" = Density + Escape Velocity
       "gv" = Gravity + Escape Velocity
       "mv" = Mass + Escape Velocity
       "rv" = Radius + Escape Velocity
   - param_1 (required): The first numeric input, meaning depends on mode
   - param_2 (required): The second numeric input, meaning depends on mode
   - prec (optional): Decimal precision for output rounding (default = 5)

   Returns:
   - A labeled 5-row table with values for: Mass (M), Radius (R), Density (d),
     Gravity (g), Escape Velocity (v)
*/

ASTRO_PLANET_METRICS_SAFETY = LAMBDA(mode, param_1, param_2, [prec],
  LET(
    // Default precision
    prec, IF(ISOMITTED(prec), 5, prec),

    // Normalize input mode to lowercase
    mode, LOWER(mode),

    // Compute based on selected mode
    output, SWITCH(
      mode,
      
      // Mass + Density
      "md", LET(
        M, param_1,
        d, param_2,
        R, (M / d) ^ (1/3),
        g, (M * d^2) ^ (1/3),
        v, (M * SQRT(d)) ^ (1/3),
        HSTACK(M, R, d, g, v)
      ),

      // Mass + Radius
      "mr", LET(
        M, param_1,
        R, param_2,
        d, M / R^3,
        g, M / R^2,
        v, SQRT(M / R),
        HSTACK(M, R, d, g, v)
      ),

      // Mass + Gravity
      "mg", LET(
        M, param_1,
        g, param_2,
        R, SQRT(M / g),
        d, SQRT(g^3 / M),
        v, (M * g) ^ 0.25,
        HSTACK(M, R, d, g, v)
      ),

      // Radius + Density
      "rd", LET(
        R, param_1,
        d, param_2,
        M, d * R^3,
        g, d * R,
        v, R * SQRT(d),
        HSTACK(M, R, d, g, v)
      ),

      // Radius + Gravity
      "rg", LET(
        R, param_1,
        g, param_2,
        M, g * R^2,
        d, g / R,
        v, SQRT(g * R),
        HSTACK(M, R, d, g, v)
      ),

      // Density + Gravity
      "dg", LET(
        d, param_1,
        g, param_2,
        R, g / d,
        M, g^3 / d^2,
        v, g / SQRT(d),
        HSTACK(M, R, d, g, v)
      ),

      // Density + Escape Velocity
      "dv", LET(
        d, param_1,
        v, param_2,
        R, v / SQRT(d),
        M, v^3 / SQRT(d),
        g, v * SQRT(d),
        HSTACK(M, R, d, g, v)
      ),

      // Gravity + Escape Velocity
      "gv", LET(
        g, param_1,
        v, param_2,
        R, v^2 / g,
        M, v^4 / g,
        d, (g / v)^2,
        HSTACK(M, R, d, g, v)
      ),

      // Mass + Escape Velocity
      "mv", LET(
        M, param_1,
        v, param_2,
        R, M / v^2,
        g, v^4 / M,
        d, v^6 / M^2,
        HSTACK(M, R, d, g, v)
      ),

      // Radius + Escape Velocity
      "rv", LET(
        R, param_1,
        v, param_2,
        g, v^2 / R,
        M, R * v^2,
        d, (v / R)^2,
        HSTACK(M, R, d, g, v)
      ),

      // Default fallback
      NA()
    ),

    // Format with headers and rounding
    headers, {"M", "R", "d", "g", "v"},
    values, ROUND(output, prec),
    CHOOSE({1, 2}, TRANSPOSE(headers), TRANSPOSE(values))
  )
);

/* ASTRO_PLANET_METRICS
   Purpose:
   Calculates planetary mass, radius, density, surface gravity, and escape velocity
   based on any two known values, and flags the provided inputs with an arrow (➔).

   Parameters:
   - mode (required): A string indicating the two known values. Accepted values:
       "md" = Mass + Density
       "mr" = Mass + Radius
       "mg" = Mass + Gravity
       "rd" = Radius + Density
       "rg" = Radius + Gravity
       "dg" = Density + Gravity
       "dv" = Density + Escape Velocity
       "gv" = Gravity + Escape Velocity
       "mv" = Mass + Escape Velocity
       "rv" = Radius + Escape Velocity
   - param_1 (required): First known parameter (meaning depends on mode)
   - param_2 (required): Second known parameter (meaning depends on mode)
   - prec (optional): Decimal precision for output (default = 5)

   Returns:
   - A 2-column vertical table with headers {"M", "R", "d", "g", "v"} and calculated values.
     Input values are flagged with a ➔ to indicate their origin.
     Units are assumed to be consistent and relative (e.g., Earth = 1.0).

   Notes:
   - Designed for use in modeling, planetary physics simulations, and educational applications.
   - Outputs are internally calculated based on basic physical relationships:
       - M = mass
       - R = radius
       - d = density
       - g = surface gravity
       - v = escape velocity
   - Handles input permutations flexibly via mode string parsing.

   Example:
   ASTRO_PLANET_METRICS_FLAGGED("rd", 1.2, 0.75)
     →
       M      0.675
       R ➔    1.2
       d ➔    0.75
       g      0.9
       v      1.039

*/


ASTRO_PLANET_METRICS = LAMBDA(mode, param_1, param_2, [prec],
  LET(
    // Default precision
    prec, IF(ISOMITTED(prec), 5, prec),

    // Normalize input mode to lowercase
    mode, LOWER(mode),

    // Compute based on selected mode
    output, SWITCH(
      mode,
      
      // Mass + Density
      "md", LET(
        M, param_1,
        d, param_2,
        R, (M / d) ^ (1/3),
        g, (M * d^2) ^ (1/3),
        v, (M * SQRT(d)) ^ (1/3),
        HSTACK(M, R, d, g, v)
      ),

      // Mass + Radius
      "mr", LET(
        M, param_1,
        R, param_2,
        d, M / R^3,
        g, M / R^2,
        v, SQRT(M / R),
        HSTACK(M, R, d, g, v)
      ),

      // Mass + Gravity
      "mg", LET(
        M, param_1,
        g, param_2,
        R, SQRT(M / g),
        d, SQRT(g^3 / M),
        v, (M * g) ^ 0.25,
        HSTACK(M, R, d, g, v)
      ),

      // Radius + Density
      "rd", LET(
        R, param_1,
        d, param_2,
        M, d * R^3,
        g, d * R,
        v, R * SQRT(d),
        HSTACK(M, R, d, g, v)
      ),

      // Radius + Gravity
      "rg", LET(
        R, param_1,
        g, param_2,
        M, g * R^2,
        d, g / R,
        v, SQRT(g * R),
        HSTACK(M, R, d, g, v)
      ),

      // Density + Gravity
      "dg", LET(
        d, param_1,
        g, param_2,
        R, g / d,
        M, g^3 / d^2,
        v, g / SQRT(d),
        HSTACK(M, R, d, g, v)
      ),

      // Density + Escape Velocity
      "dv", LET(
        d, param_1,
        v, param_2,
        R, v / SQRT(d),
        M, v^3 / SQRT(d),
        g, v * SQRT(d),
        HSTACK(M, R, d, g, v)
      ),

      // Gravity + Escape Velocity
      "gv", LET(
        g, param_1,
        v, param_2,
        R, v^2 / g,
        M, v^4 / g,
        d, (g / v)^2,
        HSTACK(M, R, d, g, v)
      ),

      // Mass + Escape Velocity
      "mv", LET(
        M, param_1,
        v, param_2,
        R, M / v^2,
        g, v^4 / M,
        d, v^6 / M^2,
        HSTACK(M, R, d, g, v)
      ),

      // Radius + Escape Velocity
      "rv", LET(
        R, param_1,
        v, param_2,
        g, v^2 / R,
        M, R * v^2,
        d, (v / R)^2,
        HSTACK(M, R, d, g, v)
      ),

      // Default fallback
      NA()
    ),

    // Format with headers and rounding
    headers, SWITCH(
        mode,
        "md", {"M ➔", "R", "d ➔", "g", "v"},
        "mr", {"M ➔", "R ➔", "d", "g", "v"},
        "mg", {"M ➔", "R", "d", "g ➔", "v"},
        "rd", {"M", "R ➔", "d ➔", "g", "v"},
        "rg", {"M", "R ➔", "d", "g ➔", "v"},
        "dg", {"M", "R", "d ➔", "g ➔", "v"},
        "dv", {"M", "R", "d ➔", "g", "v ➔"},
        "gv", {"M", "R", "d", "g ➔", "v ➔"},
        "mv", {"M ➔", "R", "d", "g", "v ➔"},
        "rv", {"M", "R ➔", "d", "g", "v ➔"},
        {"M", "R", "d", "g", "v"}  // fallback
        ),
    values, ROUND(output, prec),
    CHOOSE({1, 2}, TRANSPOSE(headers), TRANSPOSE(values))
  )
);

// ASTRO_SYNODIC = 
// LAMBDA(p, q, prec,
//   LET(
//     result,
//     IF(p = q,
//        NA(),
//        LET(
//          num, p * q,
//          den, ABS(p - q),
//          raw, num / den,
//          ROUND(raw, prec)
//        )
//     ),
//     result
//   )
// );

// ASTRO_SYNODIC_SOLVED =
// LAMBDA(val_1, val_2, [mode], [prec],
//   LET(
//     mode, IF(ISOMITTED(mode), "pq", IF(mode = "", "pq", mode)),
//     prec, IF(ISOMITTED(prec), 4, prec),

//     p, IF(OR(mode="pq", mode="ps"), val_1, NA()),
//     q, IF(mode="pq", val_2, IF(mode="qs", val_1, NA())),
//     s, IF(OR(mode="ps", mode="qs"), val_2, NA()),

//     a, IF(AND(ISNUMBER(p), ISNUMBER(q)), MAX(p, q), p),
//     b, IF(AND(ISNUMBER(p), ISNUMBER(q)), MIN(p, q), q),

//     result,
//       SWITCH(
//         mode,
//         "pq", IF(a = b, NA(), ROUND((a * b) / (a - b), prec)),
//         "ps", IF(OR(NOT(ISNUMBER(a)), NOT(ISNUMBER(s))), NA(),
//                  ROUND((a * s) / (a - s), prec)),
//         "qs", IF(OR(NOT(ISNUMBER(b)), NOT(ISNUMBER(s))), NA(),
//                  ROUND((b * s) / (b - s), prec)),
//         NA()
//       ),
//     result
//   )
// );

/* ASTRO_SYNODIC_SOLVER
   Purpose:
   A comprehensive synodic period solver that calculates the third value (P, Q, or S)
   when any two of the three are provided. Supports multiple input/output modes for
   scientific modeling, pedagogical use, and flexible presentation.

   Parameters:
   - val_1 (required): First input value. Meaning depends on the selected mode.
   - val_2 (required): Second input value. Meaning depends on the selected mode.
   - mode (optional): 2-letter string indicating known inputs. Accepts any case or order.
       - "pq" = solve for S (synodic period)
       - "ps" = solve for Q (outer sidereal orbit)
       - "qs" = solve for P (inner sidereal orbit)
     Default is "pq" if omitted or invalid.
   - format (optional): Output format (default = "bare")
       - "bare"    → returns the solved value only
       - "labeled" → returns "P = 365.25", "S = 779.88", etc., depending on mode
       - "verbose" → returns inline text of all three values with ☞ on solved value
       - "row"     → returns 1x3 array with P, Q, and S labels and values
       - "col"     → returns 3x2 vertical array: {"P =", 365.25; "Q =", 687; "S ☞", 779.88}
   - prec (optional): Decimal precision to round results (default = 4)

   Returns:
   - A scalar value or a labeled/spill array depending on selected format.
   - In all cases, the calculated (solved) value is flagged with a right arrow (☞).

   Notes:
   - Synodic period formula: S = (P * Q) / |P - Q|
   - Inverse solutions:
       - Q = (P * S) / |P - S|
       - P = (Q * S) / |Q - S|
   - Inputs are auto-ordered as needed for stability (e.g., P = max(val1, val2) in "pq" mode).
   - Mode is case-insensitive and auto-normalized (e.g., "QS", "sq", and "sQ" all → "qs").
   - Output formats support human-readable results and structured table integration.
   - Designed as a general-purpose engine for use in astronomy models and educational tools.

   Example 1:
     ASTRO_SYNODIC_SOLVER(365.25, 687, "pq", "bare", 4)
       → 779.8811

   Example 2:
     ASTRO_SYNODIC_SOLVER(365.25, 687, "pq", "verbose")
       → "P = 365.25, Q = 687, S = ☞ 779.8811"

   Example 3:
     ASTRO_SYNODIC_SOLVER(687, 779.8811, "qs", "col")
       →
         P ☞    365.25
         Q =    687
         S =    779.8811

   Recommendation:
   - For general users, consider using one of the simpler wrapper functions:
       - ASTRO_SYNODIC_PQ(P, Q)
       - ASTRO_SYNODIC_PS(P, S)
       - ASTRO_SYNODIC_QS(Q, S)
   - This function is intended for advanced use cases and UI-integrated output.

*/


ASTRO_SYNODIC_SOLVER =
LAMBDA(val_1, val_2, [mode], [format], [prec],
  LET(
    // Handle optional arguments
    raw_mode, IF(ISOMITTED(mode) + (mode = ""), "PQ", mode),
    norm_mode, TEXTJOIN("",,SORT(MID(LOWER(raw_mode),SEQUENCE(LEN(raw_mode)),1))),
    mode, norm_mode,

    format, IF(ISOMITTED(format) + (format = ""), "bare", LOWER(format)),
    prec, IF(ISOMITTED(prec), 4, prec),

    // Input unpacking by mode
    P_in, IF(OR(mode="pq", mode="ps"), val_1, NA()),
    Q_in, IF(mode="pq", val_2, IF(mode="qs", val_1, NA())),
    S_in, IF(OR(mode="ps", mode="qs"), val_2, NA()),

    // P and Q ordering only used in 'pq' mode
    P, IF(AND(ISNUMBER(P_in), ISNUMBER(Q_in)), MAX(P_in, Q_in), P_in),
    Q, IF(AND(ISNUMBER(P_in), ISNUMBER(Q_in)), MIN(P_in, Q_in), Q_in),

    // Synodic period calculation
    S_calc, IF(P = Q, NA(), ROUND((P * Q) / (P - Q), prec)),

    // Direction-aware inverse calculations
    Q_calc, IF(OR(NOT(ISNUMBER(P)), NOT(ISNUMBER(S_in))), NA(),
                ROUND((P * S_in) / ABS(P - S_in), prec)),

    P_calc, IF(OR(NOT(ISNUMBER(Q)), NOT(ISNUMBER(S_in))), NA(),
                ROUND((Q * S_in) / ABS(Q - S_in), prec)),

    // Selected result values
    P_val, IF(mode = "qs", P_calc, P),
    Q_val, IF(mode = "ps", Q_calc, Q),
    S_val, IF(mode = "pq", S_calc, S_in),

    // Solved label
    label, SWITCH(mode, "pq", "S", "ps", "Q", "qs", "P", "?"),

    // Primary scalar result
    result, SWITCH(mode, "pq", S_calc, "ps", Q_calc, "qs", P_calc, NA()),

    // Verbose text output
    verbose_out,
      "P = " & IF(ISNUMBER(P_val), IF(mode = "qs", "☞ " & P_val, P_val), "—") & ", " &
      "Q = " & IF(ISNUMBER(Q_val), IF(mode = "ps", "☞ " & Q_val, Q_val), "—") & ", " &
      "S = " & IF(ISNUMBER(S_val), IF(mode = "pq", "☞ " & S_val, S_val), "—"),

    // Spillable tabular outputs
    row_out,
      VSTACK(
        HSTACK(
          IF(mode="qs", "P ☞", "P ="),
          IF(mode="ps", "Q ☞", "Q ="),
          IF(mode="pq", "S ☞", "S =")
        ),
        HSTACK(P_val, Q_val, S_val)
      ),

    col_out,
      VSTACK(
        HSTACK(IF(mode="qs", "P ☞", "P ="), P_val),
        HSTACK(IF(mode="ps", "Q ☞", "Q ="), Q_val),
        HSTACK(IF(mode="pq", "S ☞", "S ="), S_val)
      ),

    // Final switch for return type
    output,
      SWITCH(format,
        "bare", result,
        "labeled", label & " = " & result,
        "verbose", verbose_out,
        "row", row_out,
        "col", col_out,
        "Invalid format"
      ),

    output
  )
);

/* ASTRO_SYNODIC_PQ
   Purpose:
   Calculates the synodic period (S) between two planetary bodies
   based on their sidereal orbital periods P and Q.

   Parameters:
   - P (required): Sidereal orbital period of the inner (faster) body
   - Q (required): Sidereal orbital period of the outer (slower) body
   - output (optional): Output format. 
       - "bare" = Returns synodic period only (default)
       - "verbose" = Returns a 2-column vertical table: P, Q, S, with the result flagged (☞)
   - prec (optional): Decimal precision (default = 4)

   Returns:
   - Synodic period (bare), or
   - Verbose 2-column array with labeled P, Q, and S values
     (S is flagged with a ☞ to indicate it's the solved value)

   Notes:
   - S = (P × Q) / |P − Q|, assuming P ≠ Q
   - Inputs may be provided in any order; the function internally assigns P/Q for correct calculation
   - Useful for predicting conjunction intervals or orbital resonance modeling

   Example:
   ASTRO_SYNODIC_PQ(365.25, 687, "verbose", 4)
     →
       P =      365.25
       Q =      687
       S ☞ =    779.8811
*/


ASTRO_SYNODIC_PQ =
LAMBDA(P, Q, [output], [prec],
  LET(
    // Handle optional arguments
    mode, IF(ISOMITTED(output) + (output = ""), "bare", LOWER(output)),
    digits, IF(ISOMITTED(prec), 4, prec),

    // Sort for stability in synodic calculation
    A, MAX(P, Q),
    B, MIN(P, Q),

    // Calculate synodic period
    S, ROUND((A * B) / (A - B), digits),

    // Two-column verbose output (labels preserved)
    verbose,
      VSTACK(
        HSTACK("P =", P),
        HSTACK("Q =", Q),
        HSTACK("S ☞", S)
      ),

    // Output selection
    result, IF(mode = "verbose", verbose, S),

    result
  )
);

/* ASTRO_SYNODIC_PS
   Purpose:
   Calculates the sidereal orbital period Q of the outer body
   based on the synodic period (S) and the known inner orbital period (P).

   Parameters:
   - P (required): Sidereal orbital period of the inner (faster) body
   - S (required): Synodic period (observed interval between conjunctions)
   - output (optional): Output format. 
       - "bare" = Returns Q only (default)
       - "verbose" = Returns a 2-column vertical table: P, Q, S, with Q flagged (☞)
   - prec (optional): Decimal precision (default = 4)

   Returns:
   - Sidereal period Q (bare), or
   - Verbose 2-column array with labeled P, Q, and S values
     (Q is flagged with ☞ to indicate it's the solved value)

   Notes:
   - Q = (P × S) / (P − S)
   - Assumes S < P (synodic period must be shorter than slower body's orbit)
   - Designed for systems where synodic intervals are measured and inner body is known

   Example:
   ASTRO_SYNODIC_PS(365.25, 779.8811, "verbose", 4)
     →
       P =      365.25
       Q ☞ =    687
       S =      779.8811
*/


ASTRO_SYNODIC_PS =
LAMBDA(P, S, [output], [prec],
  LET(
    // Optional argument handling
    mode, IF(ISOMITTED(output) + (output = ""), "bare", LOWER(output)),
    digits, IF(ISOMITTED(prec), 4, prec),

    // Compute Q (outer orbit)
    Q, ROUND((P * S) / ABS(P - S), digits),

    // Verbose spill output
    verbose,
      VSTACK(
        HSTACK("P =", P),
        HSTACK("Q ☞", Q),
        HSTACK("S =", S)
      ),

    // Output choice
    result, IF(mode = "verbose", verbose, Q),

    result
  )
);

/* ASTRO_SYNODIC_QS
   Purpose:
   Calculates the sidereal orbital period P of the inner (faster) body
   based on the synodic period (S) and the known outer orbital period (Q).

   Parameters:
   - Q (required): Sidereal orbital period of the outer (slower) body
   - S (required): Synodic period (observed interval between conjunctions)
   - output (optional): Output format. 
       - "bare" = Returns P only (default)
       - "verbose" = Returns a 2-column vertical table: P, Q, S, with P flagged (☞)
   - prec (optional): Decimal precision (default = 4)

   Returns:
   - Sidereal period P (bare), or
   - Verbose 2-column array with labeled P, Q, and S values
     (P is flagged with ☞ to indicate it's the solved value)

   Notes:
   - P = (Q × S) / (Q + S)
   - Used when the synodic period and slower orbit are known (e.g., observational astronomy)
   - Output layout is consistent across all synodic solver functions

   Example:
   ASTRO_SYNODIC_QS(687, 779.8811, "verbose", 4)
     →
       P ☞ =    365.25
       Q =      687
       S =      779.8811
*/


ASTRO_SYNODIC_QS =
LAMBDA(Q, S, [output], [prec],
  LET(
    mode, IF(ISOMITTED(output) + (output = ""), "bare", LOWER(output)),
    digits, IF(ISOMITTED(prec), 4, prec),

    // Correct formula: P = (Q * S) / (Q + S)
    P, ROUND((Q * S) / (Q + S), digits),

    verbose,
      VSTACK(
        HSTACK("P ☞", P),
        HSTACK("Q =", Q),
        HSTACK("S =", S)
      ),

    result, IF(mode = "verbose", verbose, P),
    result
  )
);

/* ASTRO_APPARENT_SOLAR_SIZE
   Purpose:
   Calculates the apparent angular diameter of a star (or other object) as seen from a specified distance,
   expressed as a multiple of the Sun’s apparent size from Earth.

   Inputs:
   - radius (required): Radius of the object, in solar radii (R☉)
   - distance (required): Distance to the object, in astronomical units (AU)
   - format (optional): Output mode.
       "raw"       → returns numeric scalar (e.g., 1.545)
       "formatted" → returns string formatted as (e.g., "1.545☉")
       Default     → "formatted"
   - prec (optional): Number of decimal places to round to (default = 4)

   Returns:
   - Apparent angular size of the object as a multiple of the Sun’s.
     1.0 means the object appears exactly the same size as the Sun in Earth's sky.
     >1.0 means larger; <1.0 means smaller.

   Notes:
   - Assumes that inputs are in solar radii and AU, which cancel naturally to a unitless ratio.
   - Useful for worldbuilding, visual storytelling, and comparative astronomy.
   - May be expanded in future to support true angular units (arcmin, degrees, etc.)
*/

ASTRO_APPARENT_SOLAR_SIZE =
LAMBDA(radius, distance, [format], [prec],
  LET(
    // Set default precision if omitted
    p, IF(ISOMITTED(prec), 4, prec),

    // Core calculation: ratio of radius to distance
    raw, radius / distance,

    // Conditional output formatting
    result,
      IF(
        OR(ISOMITTED(format), format = "formatted"),
        TEXT(raw, "0." & REPT("0", p)) & "☉",  // e.g., "1.5450☉"
        raw                                     // return scalar
      ),

    result
  )
);


/* ASTRO_ORBIT_CONFIGURATION_INDEX
   Purpose:
   Computes a dimensionless index that characterizes the configuration
   of a two-body orbital system based on mass asymmetry. This index
   predicts whether orbits will be nested, tangential, or crossing.

   Inputs:
   - mass1: First body mass (solar masses)
   - mass2: Second body mass (solar masses)

   Returns:
   - Configuration index ¤p = |m1 − m2| / (m1 + m2), range [0, 1)

   Interpretation:
   - < 0.4142 (√2 − 1) → Crossing orbits
   - = 0.4142          → Tangential boundary (silver ratio)
   - > 0.4142          → Nested orbits

   Notes:
   - This index is scale-invariant and symmetric.
   - Useful in worldbuilding, classification, and binary system modeling.
*/

ASTRO_ORBIT_CONFIGURATION_INDEX =
LAMBDA(mass1, mass2,
  ABS(mass1 - mass2) / (mass1 + mass2)
);


/* ASTRO_SPHERICAL_TO_CARTESIAN
   Purpose:
   Converts spherical coordinates to Cartesian (x, y, z),
   assuming phi is inclination from the vertical axis and theta is azimuth.

   Inputs:
   - phi:    Inclination angle (degrees), 0 = north pole, 90 = equator, 180 = south pole
   - theta:  Azimuthal angle (degrees), 0 = prime meridian, 90 = east
   - r:      Radial distance
   - prec (optional): Decimal precision (default = 3)

   Returns:
   - 1×3 array: {x, y, z}, rounded to [prec] digits

   Notes:
   - Compatible with mapping and simulation systems using spherical geometry.
   - Assumes standard right-handed coordinate system.
*/

ASTRO_SPHERICAL_TO_CARTESIAN =
LAMBDA(phi, theta, r, prec,
  LET(
    // Handle default precision
    prec, IF(ISOMITTED(prec) + (prec < 0), 3, prec),

    // Convert degrees to radians
    phi_rad, RADIANS(phi),
    theta_rad, RADIANS(theta),

    // Trig calculations
    x_raw, r * SIN(phi_rad) * COS(theta_rad),
    y_raw, r * SIN(phi_rad) * SIN(theta_rad),
    z_raw, r * COS(phi_rad),

    // Round and return as 1×3 array
    x, ROUND(x_raw, prec),
    y, ROUND(y_raw, prec),
    z, ROUND(z_raw, prec),

    HSTACK(x, y, z)
  )
);

/* ASTRO_CARTESIAN_TO_SPHERICAL
   Purpose:
   Converts Cartesian coordinates (x, y, z) into spherical coordinates:
   inclination (phi), azimuth (theta), and radius (r).

   Inputs:
   - x, y, z: Cartesian coordinates
   - prec (optional): Decimal precision (default = 3)

   Returns:
   - 1×3 array: {phi, theta, r}, rounded to [prec] digits

   Notes:
   - phi = inclination from vertical (0 = pole, 90 = equator)
   - theta = azimuthal direction from x-axis, 0–360°
*/

ASTRO_CARTESIAN_TO_SPHERICAL =
LAMBDA(x, y, z, prec,
  LET(
    // Handle default rounding precision
    prec, IF(ISOMITTED(prec) + (prec < 0), 3, prec),

    // Compute radial distance from origin
    r, SQRT(x^2 + y^2 + z^2),

    // Compute inclination angle from vertical axis (z)
    phi, DEGREES(ACOS(z / r)),

    // Compute azimuthal angle in x-y plane, normalized to [0, 360)
    theta, MOD(DEGREES(ATAN2(y, x)), 360),

    // Round all outputs
    phi_out, ROUND(phi, prec),
    theta_out, ROUND(theta, prec),
    r_out, ROUND(r, prec),

    // Return as 1×3 array
    HSTACK(phi_out, theta_out, r_out)
  )
);


DEG_DEC_DMS = LAMBDA(DecimalDegrees,
    LET(
        Deg, TRUNC(DecimalDegrees),
        FracPortion, ABS(DecimalDegrees - Deg),
        Minutes, FracPortion * 60,
        Min_part, TRUNC(Minutes) / 100,
        IntMin, INT(Minutes),
        FracMin, ABS(Minutes - IntMin),
        Seconds, FracMin * 60,
        sec_part, Seconds / 10000,
        output, Deg + Min_part + sec_part,
        FIXED(output, 7)
    )
);

DEG_DMS = LAMBDA(DecimalDegrees, [precision],

LET(
    decprec, IF(ISOMITTED(Precision), 3, Precision),
    Deg, TRUNC(DecimalDegrees),
    FracPortion, ABS(DecimalDegrees - Deg),
    Minutes, FracPortion * 60,
    IntMin, INT(Minutes),
    FracMin, ABS(Minutes - IntMin),
    Seconds, FracMin * 60,
    Deg & "° " & IntMin & CHAR(39) & CHAR(32) & FIXED(Seconds, decprec) & CHAR(34)
)
);

DEG_DMS_DEC = LAMBDA(input,
    LET(
        degrees, TRUNC(input),
        minutes, TRUNC((input - degrees) * 100),
        fractional_seconds, ((input * 100) - TRUNC(input * 100)) / 0.6,
        /*  */
        result, degrees + ((minutes + fractional_seconds) / 60),
        result
    )
);

/* ASTRO_ORBIT_AXIS
   Purpose:
   Computes the semi-major axis (in AU) of a two-body system
   based on total mass (in solar masses) and orbital period (in years).

   Inputs:
   - mass1: Primary mass (in solar masses)
   - mass2 (optional): Secondary mass (in solar masses; defaults to 0 if omitted or = 1)
   - period: Orbital period (in years)

   Returns:
   - Orbital axis in astronomical units (AU)

   Notes:
   - Uses Newtonian form of Kepler's Third Law.
   - mass2 is converted from solar masses if present.
*/

ASTRO_ORBIT_AXIS = LAMBDA(mass1, mass2, period,
  LET(
    m_2, IF((ISOMITTED(mass2)) + (mass2 = 1), 0, mass2 * 3.003E-6),
    axis, POWER((POWER(period, 2) * (mass1 + m_2)), 1 / 3),
    axis
  )
);


/* ASTRO_ORBIT_PERIOD
   Purpose:
   Computes the orbital period (in years) of a two-body system
   based on total mass (in solar masses) and semi-major axis (in AU).

   Inputs:
   - mass1: Primary mass (in solar masses)
   - mass2 (optional): Secondary mass (in solar masses; defaults to 0 if omitted or = 1)
   - axis: Orbital axis (in AU)

   Returns:
   - Orbital period in years
*/

ASTRO_ORBIT_PERIOD = LAMBDA(mass1, mass2, axis,
  LET(
    m_2, IF((ISOMITTED(mass2)) + (mass2 = 1), 0, mass2 * 3.00273E-6),
    period, SQRT(POWER(axis, 3) / (mass1 + m_2)),
    period
  )
);


/* ASTRO_ORBIT_SUM_MASSES
   Purpose:
   Computes the combined mass (in solar masses) of a two-body system
   from orbital axis (in AU) and period (in years).

   Inputs:
   - axis: Semi-major axis (AU)
   - period: Orbital period (years)

   Returns:
   - Total system mass (in solar masses)
*/

ASTRO_ORBIT_SUM_MASSES = LAMBDA(axis, period,
  POWER(axis, 3) / POWER(period, 2)
);


/* ASTRO_ORBIT_SOLVER
   Purpose:
   Unified solver for orbital axis, period, or total mass in a two-body system.
   Selects appropriate formula based on mode.

   Inputs:
   - mode: One of "axis", "period", or "mass"
   - val_1: First known value (depends on mode)
   - val_2: Second known value (depends on mode)
   - mass2 (optional): Secondary mass (in solar masses; defaults to 0 if omitted or = 1)
   - precision (optional): Decimal places for formatted output (default = 4)

   Returns:
   - Result as a number or labeled string, depending on mode and format

   Notes:
   - mass2 is only relevant for "axis" and "period" modes.
*/

ASTRO_ORBIT_SOLVER =
LAMBDA(mode, val_1, val_2, mass2, precision,
  LET(
    m_2, IF(ISOMITTED(mass2) + (mass2 = 1), 0, mass2 * 3.003E-6),
    prec, IF(ISOMITTED(precision), 4, precision),

    result,
      SWITCH(LOWER(mode),
        "axis", POWER((POWER(val_2, 2) * (val_1 + m_2)), 1 / 3),
        "period", SQRT(POWER(val_2, 3) / (val_1 + m_2)),
        "mass", POWER(val_1, 3) / POWER(val_2, 2),
        NA()
      ),

    label,
      SWITCH(LOWER(mode),
        "axis", "Axis = ",
        "period", "Period = ",
        "mass", "Mass = ",
        "?"
      ),

    TEXT(result, "0." & REPT("0", prec)) & " " & label
  )
);

/* ASTRO_DEGREES_TO_DMS_NUM
   Purpose:
   Converts decimal degrees into a compact D.MMSS numeric representation.

   Input:
   - DecimalDegrees: Angle in decimal degrees

   Returns:
   - Numeric result in D.MMSS format
*/

ASTRO_DEGREES_TO_DMS_NUM =
LAMBDA(DecimalDegrees,
  LET(
    Deg, TRUNC(DecimalDegrees),                         // Whole degrees
    FracPortion, ABS(DecimalDegrees - Deg),             // Fractional part
    Minutes, FracPortion * 60,                          // Convert to minutes
    Min_part, TRUNC(Minutes) / 100,                     // Integer minutes / 100
    IntMin, INT(Minutes),
    FracMin, ABS(Minutes - IntMin),                     // Remainder minutes
    Seconds, FracMin * 60,                              // Convert to seconds
    sec_part, Seconds / 10000,                          // Seconds / 10000
    output, Deg + Min_part + sec_part,                  // Add all together
    FIXED(output, 7)                                    // Return fixed decimal text
  )
);


/* ASTRO_DEGREES_TO_DMS_TEXT
   Purpose:
   Converts decimal degrees into a formatted D° M' S" string.

   Inputs:
   - DecimalDegrees: Angle in decimal degrees
   - precision (optional): Decimal places for seconds (default = 3)

   Returns:
   - String in "D° M' S.SS\"" format
*/

ASTRO_DEGREES_TO_DMS_TEXT =
LAMBDA(DecimalDegrees, precision,
  LET(
    decprec, IF(ISOMITTED(precision), 3, precision),
    Deg, TRUNC(DecimalDegrees),
    FracPortion, ABS(DecimalDegrees - Deg),
    Minutes, FracPortion * 60,
    IntMin, INT(Minutes),
    FracMin, ABS(Minutes - IntMin),
    Seconds, FracMin * 60,
    Deg & "° " & IntMin & CHAR(39) & CHAR(32) & FIXED(Seconds, decprec) & CHAR(34)
  )
);


/* ASTRO_DMS_NUM_TO_DEGREES
   Purpose:
   Converts a D.MMSS-style numeric format into decimal degrees.

   Input:
   - input: Angle in D.MMSS format (e.g., 123.3015)

   Returns:
   - Decimal degrees
*/

ASTRO_DMS_NUM_TO_DEGREES =
LAMBDA(input,
  LET(
    degrees, TRUNC(input),                             // Whole degrees
    minutes, TRUNC((input - degrees) * 100),           // Minutes portion
    fractional_seconds, ((input * 100) - TRUNC(input * 100)) / 0.6, // Convert from decimal minutes to seconds
    result, degrees + ((minutes + fractional_seconds) / 60),
    result
  )
);

/* CONVERT_TEMP_C_TO_F
   Purpose:
   Converts a Celsius temperature value to Fahrenheit.

   Returns:
   A numeric value representing the equivalent temperature in Fahrenheit,
   optionally rounded to a given number of decimal places.

   Parameters:
   - C (required): Temperature in degrees Celsius
   - precision (optional): Number of decimal places (default = 3)

   Notes:
   - Automatically defaults to 3 decimal places if none provided or invalid input
   - Output is numeric, suitable for further computation or display
   - Uses standard formula: F = (C × 9/5) + 32

   Examples:
     CONVERT_TEMP_C_TO_F(0) → 32
     CONVERT_TEMP_C_TO_F(100, 1) → 212.0
     CONVERT_TEMP_C_TO_F(-40) → -40.000
*/

CONVERT_TEMP_C_TO_F = LAMBDA(C, [precision],
    LET(
        // Validate or default the precision value
        precision, IF(ISOMITTED(precision) + (precision < 0), 3, precision),

        // Conversion formula
        fahrenheit, C * (9 / 5) + 32,

        // Final output
        ROUND(fahrenheit, precision)
    )
);


/* CONVERT_TEMP_F_TO_C:
   Purpose:
   Converts a temperature from degrees Fahrenheit to degrees Celsius.

   Returns:
   A numeric value in degrees Celsius, optionally rounded to a specified number of decimal places.

   Parameters:
   - F (required): A temperature in degrees Fahrenheit
   - precision (optional): Number of decimal places to round the result to (default = 3)

   Notes:
   - If precision is omitted or invalid (e.g., negative), it defaults to 3.
   - Uses the standard formula: C = (F − 32) × 5⁄9
   - Handles negative and fractional temperatures correctly.
   - Useful for unit conversions in data cleanup, display, or reporting.

   Examples:
   CONVERT_TEMP_F_TO_C(32) → 0
   CONVERT_TEMP_F_TO_C(212, 2) → 100.00
   CONVERT_TEMP_F_TO_C(-40) → -40.000
*/

CONVERT_TEMP_F_TO_C = LAMBDA(F, [precision],
    LET(
        // Default precision to 3 if omitted or invalid
        precision, IF(OR(ISOMITTED(precision), precision < 0), 3, precision),

        // Conversion calculation
        celsius, (F - 32) * (5 / 9),

        // Round result
        ROUND(celsius, precision)
    )
);

/* FORMAT_FEET_AND_INCHES:
   Purpose:
   Converts a decimal foot value into feet and inches,
   either as a decimal-inch format or as feet with fractional inches.

   Returns:
   A formatted string like "6' 5.25"" or "6' 5-1/4""

   Parameters:
   - input (required): A decimal value in feet (e.g., 6.4375)
   - style (optional):
       0 = use decimal inches (default)
       1 = use fractional inches (e.g., 5-1/4")
   - denom (optional): Denominator for fractional inches (default = 16)
   - precision (optional): Decimal places for style 0 (default = 3)

   Notes:
   - The `precision` parameter is only used for `style = 0`
     and has no effect when displaying fractional inches.
   - Fractions are automatically simplified.
   - Output always includes feet (e.g., "6'" prefix).
   - Compatible with both positive and fractional inputs.

   Examples:
     FORMAT_FEET_AND_INCHES(6.4375)
     → "6' 5.25""

     FORMAT_FEET_AND_INCHES(6.4375, 1)
     → "6' 5-1/4""

     FORMAT_FEET_AND_INCHES(6.4375, 0, , 4)
     → "6' 5.2500""
*/


FORMAT_FEET_AND_INCHES = LAMBDA(input, [style], [denom], [precision],
    LET(
        // === Parameter defaults and validation ===
        style, IF((ISOMITTED(style)) + (style > 1), 0, style),
        denom, IF(ISOMITTED(denom), 16, TRUNC(denom)),
        precision, IF(ISOMITTED(precision), 3, precision),

        // === Extract integer and decimal parts of feet ===
        feet, QUOTIENT(input, 1),
        feet_mant, MOD(input, 1),

        // === Convert decimal portion to inches ===
        decimal_inch, ROUND(feet_mant * 12, precision),
        inch_int, TRUNC(decimal_inch),
        inch_dec, decimal_inch - inch_int,

        // === Calculate simplified fraction ===
        inch_numer, TRUNC(inch_dec * denom),
        comfact, GCD(inch_numer, denom),
        numerfinal, inch_numer / comfact,
        denomfinal, denom / comfact,
        test, MOD(inch_numer, denom),

        // === Assemble formatted components ===
        frac_inch, IF(test <> 0, numerfinal & "/" & denomfinal, ""),
        int_inch, IF(inch_int = 0, "", inch_int),

        // === Combined formatting logic ===
        combo, IFS(
            AND(int_inch = "", frac_inch = ""),
            feet & CHAR(39),
            AND(int_inch = "", frac_inch <> ""),
            feet & CHAR(39) & CHAR(32) & frac_inch & CHAR(34),
            AND(int_inch <> "", frac_inch <> ""),
            feet & CHAR(39) & CHAR(32) & int_inch & "-" & frac_inch & CHAR(34),
            TRUE,
            feet & CHAR(39) & CHAR(32) & int_inch & CHAR(34)
        ),

        // === Standard decimal formatting ===
        standard, feet & CHAR(39) & CHAR(32) & decimal_inch & CHAR(34),

        // === Return based on style selection ===
        output, SWITCH(style, 0, standard, 1, combo),
        output
    )
);


/* FORMAT_INCH_FRACTION:
   Purpose:
   Converts a decimal inch measurement into a string formatted as inches and simplified fractional inches.
   Useful for construction, cabinetry, and any application using imperial units.

   Returns:
   A text string like `2-3/8"` or `5"`

   Parameters:
   - input (required): A decimal inch value (e.g., 2.375)
   - denom (optional): Denominator to round to (e.g., 16, 32). Defaults to 32.

   Notes:
   - Automatically reduces fractional component to lowest terms.
   - Omits fractional part if the remainder is 0.
   - Always returns properly formatted inch symbol (")
   - Handles edge cases like 0", pure fractions, or whole inches.

   Example:
     FORMAT_INCH_FRACTION(2.375, 16) → "2-3/8\""
     FORMAT_INCH_FRACTION(5) → "5\""
*/

FORMAT_INCH_FRACTION = LAMBDA(input, [denom],
    LET(
        // Default to 32 if no denominator provided
        denom, IF(ISOMITTED(denom), 32, TRUNC(denom)),

        // Separate whole inches and fractional part
        inch, QUOTIENT(input, 1),
        inch_mant, MOD(input, 1),

        // Calculate fractional numerator and simplify
        inch_numer, TRUNC(inch_mant * denom),
        comfact, GCD(inch_numer, denom),
        numerfinal, inch_numer / comfact,
        denomfinal, denom / comfact,

        // Format fractional part
        has_fraction, MOD(inch_numer, denom) <> 0,
        frac_inch, IF(has_fraction, numerfinal & "/" & denomfinal, ""),

        // Construct output string
        output, IF(
            inch_numer = 0,
            inch & CHAR(34),                         // e.g., 5"
            inch & "-" & frac_inch & CHAR(34)        // e.g., 2-3/8"
        ),
        output
    )
);


/* SEQ_SPAN:
   Purpose:
   Returns a fixed-length sequence of evenly spaced numbers
   between a lower and upper bound. Both bounds are always included.

   Returns:
   A horizontal array of `count` values from `lbound` to `ubound`, inclusive.

   Parameters:
   - lbound (required): Starting value of the sequence.
   - ubound (required): Ending value of the sequence.
   - count (required): Total number of values in the sequence (must be ≥ 2).

   Notes:
   - Uses simple linear interpolation to determine spacing.
   - Step size = (ubound - lbound) / (count - 1)
   - Built on Excel’s native SEQUENCE function.
   - Ideal when exact endpoints and total number of values are known.

   Example:
   SEQ_SPAN(0, 10, 6) → {0, 2, 4, 6, 8, 10}
*/

SEQ_SPAN = LAMBDA(lbound, ubound, count,
    LET(
        // Calculate evenly spaced step size
        stp, (ubound - lbound) / (count - 1),

        // Generate sequence of 'count' values starting at lbound with step size 'stp'
        sequence(count, , lbound, stp)
    )
);



/* SEQ_STEP:
   Purpose:
   Returns a dynamic-length sequence between two bounds using a
   specified step size. Direction is inferred automatically.

   Returns:
   A horizontal or vertical array of values incremented by `step`,
   starting from `lbound` and stopping at or before `ubound`.

   Parameters:
   - lbound (required): Starting value of the sequence.
   - ubound (required): Ending threshold of the sequence.
   - step (optional): Increment between values (default = 1).
   - mode (optional): Output shape (0 = row [default], 1 = column).

   Notes:
   - Handles negative steps for descending sequences.
   - Length varies depending on bounds and step size.
   - If ubound is not a multiple of step, the last value will be the
     last one before ubound.

   Example:
   SEQ_STEP(3, 11, 2) → {3, 5, 7, 9, 11}
   SEQ_STEP(10, 0, -2, 1) → vertical list from 10 to 0
*/

SEQ_STEP = LAMBDA(lbound, ubound, [step], [mode],
    LET(
        // === Handle optional parameters ===
        mode, IF(ISOMITTED(mode), 0, mode),      // 0 = horizontal (default), 1 = vertical
        step, IF(ISOMITTED(step), 1, step),      // Default step = 1

        // === Calculate number of steps ===
        // Ensures full coverage between lbound and ubound with given step
        count, ABS((ubound - (lbound - ABS(step))) / step),

        // === Choose correct direction ===
        // If stepping backward (negative), start at upper bound
        start, IF(step < 0, ubound, lbound),

        // === Generate the sequence ===
        list, SEQUENCE(count, , start, step),

        // === Format output orientation ===
        output, IF(mode = 0, list, TRANSPOSE(list)),

        output
    )
);




/* SEQ_BOUND:
   Purpose:
   Returns a sequence of evenly spaced values between two bounds,
   with precise control over inclusion/exclusion of each bound.

   Returns:
   A horizontal array of values with interval spacing,
   based on inclusion mode and rounding precision.

   Parameters:
   - lbound (required): Lower bound of the interval.
   - ubound (required): Upper bound of the interval.
   - count (required): Number of segments (not points) if both bounds included.
   - mode (optional):
       0 = include both bounds (default)
       1 = exclude upper bound only
       2 = exclude lower bound only
       3 = exclude both bounds
   - rnd (optional): Rounding precision (default = 3 decimals)

   Notes:
   - The number of returned values is typically count + 1 if bounds are included.
   - Uses SWITCH to adjust sequence range based on inclusion/exclusion.
   - Useful for trimmed interpolation or controlled midpoint generation.

   Example:
   SEQ_BOUND(0, 1, 4, 0) → {0.000, 0.250, 0.500, 0.750, 1.000}
   SEQ_BOUND(0, 1, 4, 3) → {0.200, 0.400, 0.600}
*/

SEQ_BOUND = LAMBDA(lbound, ubound, count, [mode], [rnd],
    LET(
        // === Handle optional arguments ===
        rnd, IF(ISOMITTED(rnd), 3, rnd),     // Decimal places to round to (default = 3)
        mode, IF(ISOMITTED(mode), 0, mode),  // 0 = inclusive, 1–3 = variations on endpoint inclusion

        // === Core step math ===
        stp, (ubound - lbound) / count,      // Step size based on count
        rng, (ubound - lbound) / stp,        // Number of steps (non-rounded count)

        // === Mode switch for sequence bounds ===
        list, SWITCH(mode,
            0, ROUND(SEQUENCE(rng + 1, , lbound, stp), rnd),          // Inclusive: [lbound, ..., ubound]
            1, ROUND(SEQUENCE(rng, , lbound, stp), rnd),              // Right-exclusive: [lbound, ..., ubound)
            2, ROUND(SEQUENCE(rng, , lbound + stp, stp), rnd),        // Left-exclusive: (lbound, ..., ubound]
            3, ROUND(SEQUENCE(rng - 1, , lbound + stp, stp), rnd)     // Fully-exclusive: (lbound, ..., ubound)
        ),

        list
    )
);


/* SEQ_REPEAT:
   Purpose:
   Returns a sequence in which either each value or the entire sequence is
   repeated a specified number of times. Supports ascending or descending sequences.

   Returns:
   A vertical array of values based on repeat mode and bounds.

   Parameters:
   - start (required): The first value in the sequence.
   - end (required): The last value in the sequence.
   - repeat (required): Number of times to repeat values or the full sequence.
                        Must be a positive number greater than 0.
   - repeatMode (optional):
       0 = Repeat each value individually (default)
       1 = Repeat the entire sequence as a block

   Notes:
   - Mode 0: Each value between start and end is repeated `repeat` times.
     e.g. 1,1,2,2,3,3
   - Mode 1: The entire sequence from start to end is repeated `repeat` times.
     e.g. 1,2,3,1,2,3
   - Supports both ascending and descending sequences.
   - Validates that `repeat` is a positive number; otherwise returns an error message.
   - Built using MAKEARRAY for performance and scalability.

   Example:
   SEQ_REPEAT(1, 3, 2, 0) → {1;1;2;2;3;3}
   SEQ_REPEAT(1, 3, 2, 1) → {1;2;3;1;2;3}
*/

SEQ_REPEAT = LAMBDA(start, end, repeat, [repeatMode],
    LET(
        // === Normalize parameters ===
        n, IF(ISNUMBER(repeat), repeat, 1),                            // How many times to repeat each number
        repeatMode, IF(ISOMITTED(repeatMode), 0, repeatMode),         // 0 = repeat each value n times (block-wise), 1 = cycle the sequence n times

        // === Sequence characteristics ===
        len, ABS(end - start) + 1,                                    // Number of unique values in the base sequence
        step, IF(end > start, 1, -1),                                 // Step direction (+1 or -1)

        // === Validation ===
        errorMessage, "Invalid input: 'repeat' must be a positive number greater-than 0",

        // === Sequence generator based on mode ===
        result, IF(
            NOT(AND(ISNUMBER(n), n > 0)),                             // Check for valid repeat count
            errorMessage,
            IF(
                repeatMode = 0,
                // Block-wise repeat: e.g. 1,1,1,2,2,2,...
                MAKEARRAY(len * n, 1, LAMBDA(r, c, start + step * INT((r - 1) / n))),
                // Cycle repeat: e.g. 1,2,3,1,2,3,...
                MAKEARRAY(len * n, 1, LAMBDA(r, c, start + step * MOD(r - 1, len)))
            )
        ),

        result
    )
);


/* EPOCH_GREG_TO_HOLO
   ------------------
   Converts a Gregorian calendar year (BC/BCE/AD/CE or signed integer)
   into the corresponding Holocene Era (HE) year.

   Inputs:
   - input : A Gregorian year in one of two formats:
       → As a number (e.g., -9600, 2024)
       → As a text label (e.g., "753 BC", "2024 CE", "44 AD")

   Behavior:
   - Interprets "BC", "BCE", "AD", "CE" suffixes (case- and space-insensitive)
   - If input is a plain number: positive = CE, negative = BCE
   - If input is a valid string: parses numeric value and suffix
   - Returns HE = Gregorian + 10,000
   - Invalid or malformed strings return #VALUE!

   Examples:
     EPOCH_GREG_TO_HOLO(2024)          → 12024
     EPOCH_GREG_TO_HOLO(-9600)         → 401
     EPOCH_GREG_TO_HOLO("2024 CE")     → 12024
     EPOCH_GREG_TO_HOLO("9600 BCE")    → 401
     EPOCH_GREG_TO_HOLO("753 BC")      → 12454
*/

EPOCH_GREG_TO_HOLO = LAMBDA(input,
  LET(
    isNum, ISNUMBER(input),

    // === NUMERIC CASE ===
    rawYear, IF(isNum, input, 
      LET(
        txt, UPPER(SUBSTITUTE(input, " ", "")),
        hasBCE, OR(RIGHT(txt, 3) = "BCE", RIGHT(txt, 2) = "BC"),
        hasCE,  OR(RIGHT(txt, 2) = "CE", RIGHT(txt, 2) = "AD"),

        // Strip suffix
        stripped, IF(
          hasBCE, LEFT(txt, LEN(txt) - IF(RIGHT(txt, 3) = "BCE", 3, 2)),
          IF(hasCE, LEFT(txt, LEN(txt) - 2), "#ERR")
        ),

        // Attempt to coerce numeric part
        y, VALUE(stripped),

        // Apply sign if BCE/BC
        IF(ISNUMBER(y),
          IF(hasBCE, -y, y),
          "#VALUE!"
        )
      )
    ),

    // === FINAL OUTPUT ===
    IF(ISNUMBER(rawYear),
      rawYear + 10000,
      rawYear // already an error like "#VALUE!"
    )
  )
);


EPOCH_HOLO_TO_GREG = LAMBDA(input, [mode],
  LET(
    // Default mode to "BC" (for labeled output) unless explicitly "NUM"
    mode, IF(ISOMITTED(mode), "BC", UPPER(mode)),

    // Convert HE year to signed Gregorian year
    raw, input - 10000,
    
    // Handle year 0 (no such year in Gregorian calendar)
    gregorian, IF(raw = 0, -1, raw),

    // Generate labeled output
    result,
      IF(mode = "NUM",
        // Numeric output if mode = "NUM"
        gregorian,
        // Labeled BCE/CE output (default)
        IF(
          gregorian < 1,
          ABS(gregorian) & " BCE",
          gregorian & " CE"
        )
      ),

    result
  )
);

/* EPOCH_GREG_TO_BP
   ----------------
   Converts a Gregorian calendar year (signed or labeled) into years BP (Before Present).

   Inputs:
   - input (required):
       → A signed integer (e.g., 2024, -9600)
       → A labeled text string with suffix (e.g., "753 BC", "9600 BCE", "44 AD")

   - mode (optional):
       "TXT"       → Output as labeled string (e.g., "3442 BP")
       "TXT;RND"   → Labeled string, rounded to fuzzy magnitude (e.g., "21000 BP") ← Default
       "NUM"       → Raw integer output (e.g., 3442)
       "NUM;RND"   → Rounded numeric output (e.g., 21000)

   Notes:
   - Assumes "Present" = 1950 CE.
   - Input is case-insensitive; suffixes "BCE", "BC", "CE", and "AD" are recognized.
   - Rounding uses logarithmic magnitude logic (e.g., 21412 → 21000).
   - Output is automatically labeled unless "NUM" is specified.

   ⚠️ INPUT FORMATTING:
   When entering labeled dates in spreadsheet cells, **do not use quotes**.
   For example:
       ✅  1492 BCE     ← Correct
       ❌  "1492 BCE"   ← Incorrect (will break suffix parsing)

   Examples:
     B2 := 1492 CE           → typed directly (no quotes); not ="1492 CE"
     EPOCH_GREG_TO_BP(B2)    → "3442 BP"

     EPOCH_GREG_TO_BP("1492 BCE")         → "3442 BP"
     EPOCH_GREG_TO_BP(2024, "NUM")        → -74
     EPOCH_GREG_TO_BP("9600 BCE", "TXT")  → "11550 BP"
     EPOCH_GREG_TO_BP("44 AD", "NUM")     → 1906
*/


EPOCH_GREG_TO_BP = LAMBDA(input, [mode],
  LET(
    // Default mode
    m, IF(ISOMITTED(mode), "TXT;RND", UPPER(mode)),

    // Determine if input is number or string
    isNum, ISNUMBER(input),

    // === NUMERIC CASE ===
    rawYear, IF(isNum, input,
      LET(
        txt, UPPER(SUBSTITUTE(input, " ", "")),
        hasBCE, OR(RIGHT(txt, 3) = "BCE", RIGHT(txt, 2) = "BC"),
        hasCE,  OR(RIGHT(txt, 2) = "CE", RIGHT(txt, 2) = "AD"),

        stripped, IF(
          hasBCE, LEFT(txt, LEN(txt) - IF(RIGHT(txt, 3) = "BCE", 3, 2)),
          IF(hasCE, LEFT(txt, LEN(txt) - 2), "#ERR")
        ),
        y, VALUE(stripped),
        IF(ISNUMBER(y),
          IF(hasBCE, -y, y),
          "#VALUE!"
        )
      )
    ),

    // === CALCULATE BP ===
    bp_val, IF(ISNUMBER(rawYear), 1950 - rawYear, rawYear),

    // === FUZZY ROUNDING ===
    mag, IF(ISNUMBER(bp_val), 10 ^ (INT(LOG10(ABS(bp_val))) - 1), 1),
    fuzzy, IF(ISNUMBER(bp_val), MROUND(bp_val, mag), bp_val),

    // === OUTPUT SWITCH ===
    out, IFS(
        AND(ISNUMBER(bp_val), m = "TXT"), bp_val & " BP",
        AND(ISNUMBER(bp_val), m = "TXT;RND"), fuzzy & " BP",
        AND(ISNUMBER(bp_val), m = "NUM"), bp_val,
        AND(ISNUMBER(bp_val), m = "NUM;RND"), fuzzy,
        TRUE, "#VALUE!"
        ),

    out
  )
);

/* EPOCH_BP_TO_GREG
   ----------------
   Converts a year expressed in BP (Before Present, where "Present" = 1950 CE)
   into its Gregorian calendar equivalent.

   Inputs:
   - input : A BP value, either as:
       → A number (e.g., 3442, -100)
       → A string with suffix (e.g., "3442 BP", "21000 BP")

   - [mode] : Optional output format switch
       "NUM"        → returns signed Gregorian year (e.g., -1492, 44)
       "TXT"        → returns labeled year (e.g., "1492 BCE", "44 CE")
       "TXT;APP"    → returns approximate labeled year (e.g., "ca. 1492 BCE") ← default

   Behavior:
   - Computes: Gregorian year = 1950 − BP
   - Negative BP inputs represent years *after* 1950 CE (e.g., -100 → 2050 CE)
   - Approximates output with a "ca." prefix when using "TXT;APP"
   - Uses signed integers for "NUM" output (no prefix)
   - Returns "BCE" for negative years, "CE" for 1 and above
   - If year = 0, returns "1 BCE" (skips historical year zero)

   Notes:
   - Accepts numeric or labeled input values (e.g., "3000 BP")
   - Output format is determined by optional mode switch
   - If using "NUM" mode, the returned year may still be approximate
     depending on the BP input — but no "ca." prefix is shown.
   - Supports post-1950 projections via negative BP values.
   - Edge cases like 1950 BP (= year 0) are handled to avoid LOG10 domain errors.

   Examples:
     B2 := 1492 CE     → EPOCH_GREG_TO_BP(B2)        → "3442 BP"
     EPOCH_BP_TO_GREG("3442 BP")                     → "ca. 1492 BCE"
     EPOCH_BP_TO_GREG(3442, "TXT")                   → "1492 BCE"
     EPOCH_BP_TO_GREG(3442, "NUM")                   → -1492
     EPOCH_BP_TO_GREG(-100)                          → "ca. 2050 CE"
     EPOCH_BP_TO_GREG(44, "NUM")                     → 1906
*/

EPOCH_BP_TO_GREG = LAMBDA(input, [mode],
  LET(
    // === Normalize mode and input ===
    mode_norm, IF(ISOMITTED(mode), "TXT;APP", UPPER(mode)),

    // Handle numeric or labeled text input
    input_clean, IF(
      ISNUMBER(input),
      input,
      VALUE(SUBSTITUTE(UPPER(SUBSTITUTE(input, " ", "")), "BP", ""))
    ),

    // === Compute Gregorian year ===
    raw_year, 1950 - input_clean,

    // === Safe rounding factor (avoid LOG10(0) error) ===
        round_factor,
        IF(
            AND(ISNUMBER(raw_year), raw_year <> 0),
            10 ^ (ROUNDDOWN(LOG10(ABS(raw_year)), 0) - 1),
            1
        ),

    approx_year, MROUND(raw_year, SIGN(raw_year) * round_factor),

    // === Format output ===
    use_round, ISNUMBER(SEARCH("APP", mode_norm)),
    y, IF(use_round, approx_year, raw_year),

    // Historical year label handling
    label_year,
      IF(
        y = 0, "1 BCE",  // No historical year zero
        IF(
          y < 0,
          TEXT(ABS(y), "0") & " BCE",
          TEXT(y, "0") & " CE"
        )
      ),

    prefix, IF(use_round, "ca. ", ""),
    labeled, prefix & label_year,

    // === Output mode switch ===
    result, SWITCH(
      TRUE,
      mode_norm = "NUM", y,
      mode_norm = "TXT", label_year,
      mode_norm = "TXT;APP", labeled,
      labeled  // fallback
    ),

    result
  )
);


/* RECIP:
   Purpose:
   Returns the reciprocal (multiplicative inverse) of a number.

   Returns:
   A single decimal value equal to 1 divided by the input.

   Parameters:
   - input (required): Any nonzero numeric value.

   Notes:
   - Returns `#DIV/0!` if input is zero.
   - Useful for flipping fractions, converting rates (e.g., Hz ↔ seconds), or inverting ratios.

   Example:
     RECIP(4) → 0.25
     RECIP(0.2) → 5
*/


RECIP = LAMBDA(input, 1 / input);

/* FRAC:
   Purpose:
   Returns the fractional (non-integer) part of a number.

   Returns:
   A scalar decimal between 0 and 1 (or -1 and 0 if sign is preserved).

   Parameters:
   - input (required): The number to extract the fractional part from.
   - mode (optional): Output mode (default = 0)
       - 0: Always return positive fractional part
       - 1: Preserve sign of input (e.g., -3.25 → -0.25)

   Notes:
   - Complements Excel’s TRUNC and QUOTIENT functions.
   - Useful for detecting decimal remainders and analyzing offsets from whole values.
   - Sign-preserving mode can indicate whether a value is just above or just below an integer.

   Examples:
   FRAC(-3.25)       → 0.25  
   FRAC(-3.25, 1)    → -0.25
*/


FRAC = LAMBDA(input, [mode],
    LET(
        // Default mode to 0 if omitted or invalid
        mode, IF(OR(ISOMITTED(mode), mode > 1), 0, mode),

        // Compute fractional part by subtracting integer portion
        frac_part, input - TRUNC(input),

        // Return signed or absolute value depending on mode
        IF(mode = 1, frac_part, ABS(frac_part))
    )
);

/* ROOT:
   Purpose:
   Returns the x-th root of a number (or square root if no degree is specified).

   Returns:
   A real decimal number representing the root of `n`.

   Parameters:
   - n (required): The number to take the root of.
   - x (optional): The root degree. Defaults to 2 (square root).

   Notes:
   - Rejects all negative input values for `n`, regardless of root.
   - Mimics Excel's behavior (returns #NUM! if root would be complex).
   - Use Excel’s `IMPOWER` or `IMSQRT` for complex number support.

   Examples:
   ROOT(16)       → 4
   ROOT(27, 3)    → 3
   ROOT(9, 0.5)   → 81
   ROOT(-5, 3)    → #NUM!
*/

ROOT = LAMBDA(n, [x],
    LET(
        root_degree, IF(ISOMITTED(x), 2, x),
        IF(n < 0,
            SQRT(-1),  // Triggers #NUM! error for negative base
            n ^ (1 / root_degree)
        )
    )
);

/* FORMULA_TEXT
   --------------------------
   Returns a one-line, labeled version of the formula in the given cell,
   omitting the leading equal sign and prepending the cell reference.

   Syntax:
     FORMULA_TEXT(cell)

   Parameters:
     cell : A reference to a cell containing a formula.

   Returns:
     A single-line string in the format "A1:= FORMULA(...)"
     Useful for auditing, documentation, dashboards, or teaching tools.

   Examples:
     FORMULA_TEXT(B3)  → "B3:= RECIP(ROOT(PI(),3))"
     FORMULA_TEXT(C5)  → "C5:= ROUND_FIX(PI(),3)"

   Notes:
     - The result is equivalent to: CELL("address", cell) & ":= " & TEXTAFTER(FORMULATEXT(cell), "=")
     - If the referenced cell does not contain a formula, an error will occur.
     - This function does not evaluate or alter the formula—only formats it for display.
*/

FORMULA_TEXT=LAMBDA(
  formula_cell,  // A reference to a cell containing a formula

  LET(
    raw, FORMULATEXT(formula_cell),                        // "=RECIP(ROOT(PI(),3))"
    clean, TEXTAFTER(raw, "="),                            // "RECIP(ROOT(PI(),3))"
    label, SUBSTITUTE(CELL("address", formula_cell), "$", "") & ":= ",
    label & clean
  )
);


/* ROUND_FIX
   --------------------------
   Rounds or truncates a number to a specified number of decimal places.
   Optionally returns the result as a fixed-width text string, preserving trailing zeros.

   Syntax:
     ROUND_FIX(number, places, [as_text], [use_round])

   Parameters:
     number      : The numeric value to process.
     places      : Number of decimal places to retain.
     as_text     : Optional (default = FALSE). If TRUE, returns output as text (e.g., "3.140").
     use_round   : Optional (default = FALSE). If TRUE, applies rounding. Otherwise, truncates.

   Returns:
     A number or text string representing the rounded or truncated value to fixed decimal places.

   Examples:
     ROUND_FIX(PI(), 2)                     → 3.14
     ROUND_FIX(PI(), 3, TRUE)               → "3.141"
     ROUND_FIX(PI(), 4, TRUE, FALSE)        → "3.1415"
     ROUND_FIX(PI(), 12, FALSE)             → 3.141592654   (capped to 9 decimals)
     ROUND_FIX(PI(), 12, TRUE)              → "3.141592653590"

   Notes:
     - Excel limits numeric display precision to ~9 decimal places. When as_text = FALSE,
       output is capped at 9 digits for consistency.
     - To display full precision or preserve trailing zeros, set as_text = TRUE.
     - Supports both rounding and truncation modes.
     - Ideal for formatting constants, visual display control, or ensuring clean outputs in reports.
*/


ROUND_FIX=LAMBDA(
  number,         // Required: the number to round or truncate
  places,         // Required: number of decimal places to retain
  [as_text],      // Optional: if TRUE, return result as text with fixed decimal places
  [use_round],    // Optional: if TRUE, round; if FALSE or omitted, truncate

  LET(
    n, N(number),                        // Ensure numeric input
    raw_p, N(places),                   // Raw input for places
    round_flag, IF(ISBLANK(use_round), FALSE, use_round),
    return_text, IF(ISBLANK(as_text), FALSE, as_text),

    // Excel only reliably displays up to 9 decimals as numeric
    max_places, IF(return_text, raw_p, MIN(raw_p, 9)),

    pwr_10, 10 ^ max_places,             // Power of 10 for rounding/truncation

    // Perform rounding or truncation
    result,
      IF(round_flag,
        ROUND(n, max_places),
        TRUNC(n * pwr_10) / pwr_10
      ),

    // Optionally format as fixed-length string
    final,
      IF(return_text,
        TEXT(result, "0." & REPT("0", max_places)),
        result
      ),

    final
  )
);

/* LIST_REMOVE_BLANKS
   Purpose:
   Removes blank or empty values from a vertical list (single-column range or array).

   Inputs:
   - col : A single-column array or range

   Behavior:
   - Returns all non-blank (non-`""`) values from the column
   - Does not remove entries containing only whitespace (e.g., `" "`)

   Notes:
   - Input must be a vertical list (single column)
   - Use LIST_REMOVE_BLANK_ROWS for multi-column or full-table whitespace handling
*/

LIST_REMOVE_BLANKS = LAMBDA(col,
    FILTER(col, col <> "")
);

/* LIST_REMOVE_BLANK_ROWS
   Purpose:
   Removes fully blank rows from a 2D table (or single-column list).
   A row is considered blank if all cells are empty or contain only whitespace.

   Inputs:
   - tbl : A 2D array (or single-column range) representing a table

   Behavior:
   - Uses BYROW to evaluate each row's total non-whitespace content
   - Keeps rows where the sum of trimmed cell lengths is greater than zero
   - Returns the table with all empty rows removed

   Notes:
   - Works with tables of any width
   - Can safely be used on single-column lists as a more general alternative to LIST_REMOVE_BLANKS
*/

LIST_REMOVE_BLANK_ROWS = LAMBDA(tbl,
    LET(
        // Determine which rows contain any non-whitespace characters
        keep, BYROW(tbl, LAMBDA(r, SUM(LEN(TRIM(r))) > 0)),
        // Filter out rows where all columns are empty or whitespace-only
        FILTER(tbl, keep)
    )
)
;


/* LIST_FILTER_WILDCARD
   Purpose:
   Filters items from an array using a partial match string (with or without wildcards).

   Inputs:
   - array : The array to filter (can be 1D or 2D)
   - find  : The search string to match against items in the array
   - mode  : [optional] Match mode (defaults to 0)
       0 = match if 'find' appears anywhere in the value (SEARCH-based, case-insensitive)
       1 = match if value starts with 'find'
       2 = match if value contains 'find' using wildcard logic (asterisk-match)

   Behavior:
   - Mode 0 uses SEARCH(find, value): good for case-insensitive "contains"
   - Mode 1 and 2 use XLOOKUP with wildcard patterns via BYROW to handle
     complex matches in structured arrays
   - Returns "None" if no matches found

   Notes:
   - Mode 2 supports more precise wildcard matching (e.g., "x*ing")
   - Works on both vertical and horizontal arrays (internally row-wise)
   - Match is not case-sensitive

   Examples:
   LIST_FILTER_WILDCARD(A2:A20, "cat")         → returns all items containing "cat"
   LIST_FILTER_WILDCARD(A2:A20, "cat", 1)      → returns all items starting with "cat"
   LIST_FILTER_WILDCARD(A2:A20, "cat", 2)      → returns all wildcard matches like "cat*", "*cat*", etc.
*/

LIST_FILTER_WILDCARD = LAMBDA(array, find, [mode],
  LET(
    // Normalize and validate mode input
    mode, IF(OR(ISOMITTED(mode), mode > 2), 0, mode),

    // Determine output based on mode
    output, IFERROR(
      SWITCH(
        mode,
        // Mode 0: general partial match using SEARCH
        0, FILTER(array, ISNUMBER(SEARCH(find, array))),

        // Mode 2: wildcard pattern match (contains)
        2, FILTER(array, (BYROW(array,
              LAMBDA(x, XLOOKUP("*" & find, x, x, "", 2))
            ) <> "")),

        // Mode 1: wildcard "starts with"
        1, FILTER(array, (BYROW(array,
              LAMBDA(x, XLOOKUP(find & "*", x, x, "", 2))
            ) <> ""))
      ),
      // Fallback result if no matches
      "None"
    ),

    output
  )
)
;


/* LIST_DUPES_TABLE
   Purpose:
   Returns a two-column array of values that appear more than once in a list,
   along with their counts.

   Inputs:
   - list : A 1D or 2D range of values

   Behavior:
   - Flattens the input to a single-column list
   - Counts each unique value
   - Filters only those with a count > 1
   - Output format: {value, count}

   Example:
   LIST_DUPES_TABLE(A1:C10) →
     {"apple", 2;
      "banana", 3}
*/

LIST_DUPES_TABLE = LAMBDA(list,
  LET(
    flat, TOCOL(list, 3),
    arr_unique, UNIQUE(flat),
    arr_counts, MAP(arr_unique, LAMBDA(x, COUNTIF(flat, x))),
    arr_dupes, HSTACK(arr_unique, arr_counts),
    output, FILTER(arr_dupes, INDEX(arr_dupes,,2) > 1),
    output
  )
)
;


/* LIST_COUNTEACH_MODE
   Purpose:
   Counts how many times each unique item appears in the list.
   Optional parameters allow sorting and selective output formatting.

   Inputs:
   - range      : Array to analyze
   - [sortMode] : Optional. How to sort the result
       0 = by label ascending (default)
       1 = by count descending
       2 = no sorting
   - [outputMode]: Optional. Controls format
       0 = {label, count} (default)
       1 = labels only
       2 = counts only

   Output:
   - By default, returns a two-column array: {value, count}
   - Can also return just the values or just the counts

   Example:
   LIST_COUNTEACH_MODE(A1:A10)                  → {"apple", 3; "banana", 2}
   LIST_COUNTEACH_MODE(A1:A10, 1)               → sorted by count
   LIST_COUNTEACH_MODE(A1:A10, 1, 2)            → counts only, sorted by frequency
*/

LIST_COUNTEACH_MODE = LAMBDA(range, [sortMode], [outputMode],
  LET(
    sortMode, IF(ISOMITTED(sortMode), 0, sortMode),
    outputMode, IF(ISOMITTED(outputMode), 0, outputMode),

    // Get unique values and their counts
    values, UNIQUE(TOROW(range, 1)),
    counts, MAP(values, LAMBDA(x, COUNTIF(range, x))),

    // Sort as specified
    sortedValues, SWITCH(
      sortMode,
      0, SORTBY(values, values, 1),
      1, SORTBY(values, counts, -1),
      2, values,
      values
    ),
    sortedCounts, XLOOKUP(sortedValues, values, counts),

    // Choose output format
    output, SWITCH(
      outputMode,
      1, sortedValues,
      2, sortedCounts,
      CHOOSE({1,2}, sortedValues, sortedCounts)
    ),

    output
  )
)
;


/* LIST_FORMAT_AS_STRING
   Purpose:
   Formats a list as a delimited string with optional control over uniqueness, sorting, and braces.

   Inputs:
   - range      : Array or list to format
   - delimiter  : The character to place between items (e.g., ",", ";", ":", "|")
   - opts       : [optional] Semicolon-delimited key=value string of flags

   Supported Options (case-insensitive):
   - unique=true|false     : Return only unique values (default: false)
   - sort=true|false       : Sort values alphabetically (default: false)
   - braces=true|false     : Wrap result in curly braces (default: true)

   Examples:
   LIST_FORMAT_AS_STRING(A1:A10, ",", "unique=true;sort=true;braces=false")
   LIST_FORMAT_AS_STRING(B1:B5, ";", "sort=true")
   LIST_FORMAT_AS_STRING(C1:C20, ":", "")        // default options with colon separator
*/

LIST_FORMAT_AS_STRING = LAMBDA(range, delimiter, [opts],
  LET(
    opts, IF(ISOMITTED(opts), "", LOWER(opts)),

    // Option parsing
    do_sort, ISNUMBER(SEARCH("sort=true", opts)),
    do_unique, ISNUMBER(SEARCH("unique=true", opts)),
    show_braces, NOT(ISNUMBER(SEARCH("braces=false", opts))),

    // Prepare the list
    list_raw, TOCOL(range, 3),
    list_filtered, IF(do_unique, UNIQUE(list_raw), list_raw),
    list_final, IF(do_sort, SORT(list_filtered), list_filtered),

    // Assemble result
    joined, TEXTJOIN(delimiter, , list_final),
    output, IF(show_braces, "{" & joined & "}", joined),

    output
  )
)
;


/* LIST_COPY_REVERSE
   Purpose:
   Reverses a list vertically (default) or horizontally using keyword-based mode input.

   Inputs:
   - range : List or array to reverse
   - opts  : [optional] Mode string ("horizontal=true", "mode=horizontal", etc.)

   Behavior:
   - Default: reverses a single-column array (vertical mode)
   - If "horizontal=true" or "mode=horizontal" is detected in opts, reverses row-style list
   - Does NOT skip last item in horizontal mode (fixed from prior logic)

   Examples:
   LIST_COPY_REVERSE(A1:A10)
   LIST_COPY_REVERSE(1:1, "horizontal=true")
*/

LIST_COPY_REVERSE = LAMBDA(range, [opts],
  LET(
    opts, IF(ISOMITTED(opts), "", LOWER(opts)),
    is_horizontal, OR(
      ISNUMBER(SEARCH("horizontal=true", opts)),
      ISNUMBER(SEARCH("mode=horizontal", opts))
    ),

    // Determine count of elements
    n, COUNTA(range),

    // Build reversed sequence
    reversed, IF(
      is_horizontal,
      HSTACK(INDEX(range, SEQUENCE(1, n, n, -1))),
      VSTACK(INDEX(range, SEQUENCE(n, , n, -1)))
    ),

    reversed
  )
)
;


/* LIST_REPEAT_VALUES
   Purpose:
   Repeats each item in a given list a fixed number of times, in order.

   Inputs:
   - inputRange   : A 1D array or range of values to repeat
   - repeatCount  : Number of times each item should be repeated

   Output:
   - A single-column array with each item repeated `repeatCount` times

   Example:
   LIST_REPEAT_VALUES({"A", "B", "C"}, 3) → {"A"; "A"; "A"; "B"; "B"; "B"; "C"; "C"; "C"}
*/

LIST_REPEAT_VALUES = LAMBDA(inputRange, repeatCount,
  LET(
    totalItems, COUNTA(inputRange) * repeatCount,
    // Generate the repeated sequence using a ceiling-based row index pattern
    output, MAKEARRAY(totalItems, 1,
      LAMBDA(row, col, INDEX(inputRange, CEILING(row / repeatCount, 1)))
    ),
    output
  )
)
;

/* LIST_SEQUENCE_REPEAT
   Purpose:
   Creates a numeric sequence from start to end, repeating each number a specified number of times.

   Inputs:
   - start  : Starting value of the sequence (inclusive)
   - end    : Ending value of the sequence (inclusive)
   - repeat : Number of times to repeat each item in the sequence

   Output:
   - A single-column array containing each number repeated `repeat` times

   Example:
   LIST_SEQUENCE_REPEAT(1, 3, 2) → {1; 1; 2; 2; 3; 3}
*/

LIST_SEQUENCE_REPEAT = LAMBDA(start, end, repeat,
  LET(
    len, ABS(end - start) + 1,
    step, IF(end >= start, 1, -1),
    base, SEQUENCE(len,,start,step),
    total, len * repeat,
    // Repeat each value in the sequence using a repeating index pattern
    output, MAKEARRAY(total, 1,
      LAMBDA(row, col, INDEX(base, CEILING(row / repeat, 1)))
    ),
    output
  )
);



/* LIST_SPLIT_DIGITS
   Purpose:
   Extracts all digit characters (0–9) from a text string and returns them as a numeric array.

   Inputs:
   - input : Text string potentially containing digit characters
   - [mode]: Optional. Output orientation
       0 (default) = vertical array
       1 = horizontal array

   Behavior:
   - Non-digit characters are ignored (not replaced with zero or NA)
   - Digits are returned as numbers (not strings)
   - Output orientation controlled by [mode]

   Examples:
   LIST_SPLIT_DIGITS("Room 42B")         → {4; 2}
   LIST_SPLIT_DIGITS("abc123", 1)        → {1, 2, 3}
   LIST_SPLIT_DIGITS("abc")              → {} (empty array)

   See also:
   - STR_GETDIGITS for a compact string output of the digits
*/

LIST_SPLIT_DIGITS = LAMBDA(input, [mode],
  LET(
    mode, IF(OR(ISOMITTED(mode), mode > 1), 0, mode),
    arr_chars, MID(input, SEQUENCE(LEN(input)), 1),
    arr_digits, IF(ISNUMBER(VALUE(arr_chars)), VALUE(arr_chars), NA()),
    arr_filtered, FILTER(arr_digits, ISNUMBER(arr_digits)),
    result, SWITCH(mode, 1, arr_filtered, 0, TRANSPOSE(arr_filtered)),
    result
  )
)
;

/* LIST_FROM_STRING
   Purpose:
   Converts a delimited text string into a list (vertical or horizontal array).

   Inputs:
   - text      : The input string to split
   - delimiter : The character or string used to separate values
   - [mode]    : Optional. Output orientation
       0 (default) = vertical array
       1 = horizontal array

   Behavior:
   - Uses TEXTSPLIT to parse the input into values
   - Supports horizontal or vertical output shape
   - Trims and preserves order of values

   Examples:
   LIST_FROM_STRING("apple,banana,carrot", ",")    → {"apple"; "banana"; "carrot"}
   LIST_FROM_STRING("1;2;3;4", ";", 1)             → {1, 2, 3, 4}

   See also:
   - LIST_FORMAT_AS_STRING (inverse operation)
   - STR_SPLITCHARS (character-level splitting)
*/

LIST_FROM_STRING = LAMBDA(text, delimiter, [mode],
  LET(
    mode, IF(OR(ISOMITTED(mode), mode = 0), "C", "R"),
    split, TEXTSPLIT(text, delimiter),
    IF(mode = "R", split, TRANSPOSE(split))
  )
)
;

/* LIST_ENUMERATE
   Purpose:
   Returns a two-column array pairing each item in a list with its index.

   Inputs:
   - list : A vertical or horizontal array of values

   Output:
   - A two-column array:
       Column 1 = index (1-based)
       Column 2 = corresponding value from the list

   Behavior:
   - Preserves the order of items
   - Automatically flattens the input to a single column for enumeration

   Examples:
   LIST_ENUMERATE({"A", "B", "C"}) →
     {1, "A";
      2, "B";
      3, "C"}

   LIST_ENUMERATE(HSTACK("apple", "banana", "cherry")) →
     {1, "apple";
      2, "banana";
      3, "cherry"}
*/

LIST_ENUMERATE = LAMBDA(list,
  LET(
    arr, TOCOL(list, 3),
    count, ROWS(arr),
    indexes, SEQUENCE(count),
    HSTACK(indexes, arr)
  )
)
;

/* LIST_ZIP
   Purpose:
   Combines two lists into a two-column array, pairing elements by position.

   Inputs:
   - arr_1 : First array or list (vertical or horizontal)
   - arr_2 : Second array or list (vertical or horizontal)
   - [mode]: Optional. Pairing mode:
       "PAD" (default) = pad shorter array with NA() to match longer
       "TRC"           = truncate both arrays to shortest length

   Behavior:
   - Automatically flattens both arrays into columns
   - Preserves order
   - Ensures both arrays are the same length using selected mode

   Examples:
   LIST_ZIP({"A", "B"}, {1, 2}) →
     {"A", 1;
      "B", 2}

   LIST_ZIP({"A", "B", "C"}, {1, 2}, "PAD") →
     {"A", 1;
      "B", 2;
      "C", #N/A}

   LIST_ZIP({"A", "B", "C"}, {1, 2}, "TRC") →
     {"A", 1;
      "B", 2}
*/

LIST_ZIP = LAMBDA(arr_1, arr_2, [mode],
  LET(
    mode, IF(ISOMITTED(mode), "PAD", UPPER(mode)),
    a_1, TOCOL(arr_1, 3),
    a_2, TOCOL(arr_2, 3),
    len_1, ROWS(a_1),
    len_2, ROWS(a_2),

    padCount, IF(mode = "PAD", MAX(len_1, len_2), MIN(len_1, len_2)),

    // Pad shorter array with NA() if needed
    pada_1, IF(len_1 < padCount, VSTACK(a_1, MAKEARRAY(padCount - len_1, 1, LAMBDA(r,c, NA()))), a_1),
    pada_2, IF(len_2 < padCount, VSTACK(a_2, MAKEARRAY(padCount - len_2, 1, LAMBDA(r,c, NA()))), a_2),

    zipped, HSTACK(
      IF(mode = "PAD", pada_1, INDEX(a_1, SEQUENCE(padCount))),
      IF(mode = "PAD", pada_2, INDEX(a_2, SEQUENCE(padCount)))
    ),

    zipped
  )
)
;


/* LIST_GRID
   Purpose:
   Returns the Cartesian product of two lists as a two-column array,
   pairing every item in the first list with every item in the second.

   Inputs:
   - arr_1 : First array or list (horizontal or vertical)
   - arr_2 : Second array or list (horizontal or vertical)

   Output:
   - A two-column array with every combination of arr_1 × arr_2

   Behavior:
   - Flattens both arrays to 1D columns
   - Preserves order
   - Output will have ROWS(arr_1) × ROWS(arr_2) total rows

   Example:
   LIST_GRID({"A", "B"}, {1, 2, 3}) →
     {"A", 1;
      "A", 2;
      "A", 3;
      "B", 1;
      "B", 2;
      "B", 3}
*/

LIST_GRID = LAMBDA(arr_1, arr_2,
  LET(
    arr_1_flat, TOCOL(arr_1, 3),
    arr_2_flat, TOCOL(arr_2, 3),
    len_1, ROWS(arr_1_flat),
    len_2, ROWS(arr_2_flat),
    total, len_1 * len_2,

    // Use MAKEARRAY to construct the Cartesian product
    output, MAKEARRAY(total, 2,
      LAMBDA(r, c,
        LET(
          i_1, QUOTIENT(r - 1, len_2) + 1,
          i_2, MOD(r - 1, len_2) + 1,
          IF(c = 1, INDEX(arr_1_flat, i_1), INDEX(arr_2_flat, i_2))
        )
      )
    ),

    output
  )
)
;

/* LIST_INVERT
   Purpose:
   Flips a 2D table by rows, columns, or both (mirror-like inversion).

   Inputs:
   - table : A 2D array or range
   - [mode]: Optional. Inversion mode (default: "ROWS")
       "ROWS" → Flip vertically (top-to-bottom)
       "COLS" → Flip horizontally (left-to-right)
       "BOTH" → Flip both rows and columns

   Behavior:
   - Preserves 2D shape
   - Flips based on the selected direction
   - Does not flatten or transpose

   Examples:
   LIST_INVERT({{"A","B";"C","D"}}, "ROWS") →
     {"C","D";
      "A","B"}

   LIST_INVERT({{"A","B";"C","D"}}, "COLS") →
     {"B","A";
      "D","C"}

   LIST_INVERT({{"A","B";"C","D"}}, "BOTH") →
     {"D","C";
      "B","A"}
*/

LIST_INVERT = LAMBDA(table, [mode],
  LET(
    mode, IF(ISOMITTED(mode), "ROWS", UPPER(mode)),
    rows, ROWS(table),
    cols, COLUMNS(table),

    flipped, SWITCH(
      mode,
      "ROWS", INDEX(table, SEQUENCE(rows, , rows, -1), SEQUENCE(1, cols)),
      "COLS", INDEX(table, SEQUENCE(rows), SEQUENCE(1, cols, cols, -1)),
      "BOTH", INDEX(table, SEQUENCE(rows, , rows, -1), SEQUENCE(1, cols, cols, -1)),
      table
    ),

    flipped
  )
)
;

/* LIST_WRAP
   Purpose:
   Rotates a list by N positions with wraparound, preserving all values.

   Inputs:
   - list : A vertical or horizontal array to wrap
   - n    : Number of positions to wrap
       Positive → wrap right/down
       Negative → wrap left/up

   Behavior:
   - Flattens the list to a 1D array
   - Wraps elements circularly by N positions
   - Output orientation matches input

   Examples:
   LIST_WRAP({"A","B","C","D"}, 1) → {"D","A","B","C"}
   LIST_WRAP({1,2,3,4}, -2) → {3,4,1,2}

   See also:
   - LIST_COPY_REVERSE
   - LIST_ROTATE (alternate name)
*/

LIST_WRAP = LAMBDA(list, n,
  LET(
    flat, TOCOL(list, 3),
    len, ROWS(flat),
    steps, MOD(n, len),
    wrapped, INDEX(flat, SEQUENCE(len,,len - steps + 1, 1)),
    IF(COLUMNS(list) > 1, TRANSPOSE(wrapped), wrapped)
  )
)
;


/* LIST_N
   Purpose:
   Returns a list of a single repeated value.

   Inputs:
   - value : The value to repeat
   - count : Number of times to repeat it
   - [mode]: Optional. Output orientation
       0 (default) = vertical list
       1 = horizontal list

   Behavior:
   - Works with text, numbers, logicals, and error values
   - Returns a uniform list of the specified length
   - Supports output as a column or row

   Examples:
   LIST_N("X", 3)       → {"X"; "X"; "X"}
   LIST_N(1, 4, 1)      → {1, 1, 1, 1}
   LIST_N(TRUE, 2)      → {TRUE; TRUE}
*/

LIST_N = LAMBDA(value, count, [mode],
  LET(
    mode, IF(ISOMITTED(mode), 0, mode),
    vector, INDEX(SEQUENCE(1,,1,0)+0*SEQUENCE(count),1)*0+value,
    IF(mode = 1, TRANSPOSE(vector), vector)
  )
)
;

/* LIST_FILTER_INDEXED
   Purpose:
   Returns items from a list based on a list of index positions (1-based).

   Inputs:
   - list    : A 1D array or range of values
   - indexes : A list of numeric positions (1-based)

   Behavior:
   - Retrieves elements from `list` at the specified index positions
   - Ignores list orientation (automatically flattens)
   - Output matches index order

   Examples:
   LIST_FILTER_INDEXED({"A","B","C","D"}, {1,3}) → {"A"; "C"}
   LIST_FILTER_INDEXED(A1:A10, {2,4,6}) → values from those rows

   See also:
   - LIST_ENUMERATE
   - LIST_DUPES_TABLE
   - INDEX
*/

LIST_FILTER_INDEXED = LAMBDA(list, indexes,
  LET(
    flat, TOCOL(list, 3),
    result, INDEX(flat, indexes),
    result
  )
)
;


/* LIST_IS_DISTINCT
   Purpose:
   Returns TRUE if all values in the list are unique (no duplicates), FALSE otherwise.

   Inputs:
   - list : A 1D or 2D range of values

   Behavior:
   - Flattens input to a single column
   - Compares count of total vs. unique items
   - Returns TRUE if they match, FALSE if duplicates exist

   Examples:
   LIST_IS_DISTINCT({"A","B","C"}) → TRUE
   LIST_IS_DISTINCT({"A","B","A"}) → FALSE

   See also:
   - LIST_DUPES_TABLE
   - LIST_FILTER_INDEXED
   - UNIQUE
*/

LIST_IS_DISTINCT = LAMBDA(list,
  LET(
    flat, TOCOL(list, 3),
    result, COUNTA(flat) = COUNTA(UNIQUE(flat)),
    result
  )
);

/* NUMNOTE_ENGINEERING:
   Purpose:
   Converts a number into **engineering notation** (i.e., exponent is always a multiple of 3).

   Returns:
   A text string in the form of `X.XXE+YY`, where `YY` is a multiple of 3.

   Parameters:
   - input (required): A numeric value to convert.
   - prec (optional): Number of decimal places to show (default = 2)

   Notes:
   - Useful for scientific/engineering fields where SI-prefix alignment matters.
   - Similar to scientific notation, but exponent is constrained to multiples of 3.
   - Automatically rounds the mantissa to the specified precision.

   Example:
     NUMNOTE_ENGINEERING(1234567)
     → "1.23E+06"

     NUMNOTE_ENGINEERING(0.000478, 3)
     → "478.000E-06"
*/

NUMNOTE_ENGINEERING = LAMBDA(input, [prec],
    LET(
        // Precision default to 2 if omitted
        prec, IF(ISOMITTED(prec), 2, prec),

        // Compute exponent (rounded down to nearest multiple of 3)
        power, TRUNC(LOG10(ABS(input))),
        divisor, power - MOD(power, 3),

        // Normalize input value to mantissa
        adjust, 10 ^ divisor,
        value, ROUND(input / adjust, prec),

        // Format suffix as E+03 style
        suff, "E" & IF(divisor >= 0, "+", "") & TEXT(divisor, "00"),

        // Compose formatted output
        output, TEXT(value, "0." & REPT("0", prec)) & suff,
        output
    )
);

/* NUMNOTE_MAGNITUDE
   Purpose:
   Converts a numeric value into a human-readable string using
   metric SI-style suffixes (e.g., "k", "M", "G").

   Parameters:
   - input (required): Numeric value to convert.
   - decprec (optional): Decimal precision to round the output (default = 3).

   Returns:
   A string with the number scaled and suffixed using common metric notation.

   Notes:
   - Supports scaling up to 10^30.
   - Suffix progression: "k", "M", "G", "T", "P", "E", "Z", "Y", "R", "Q"
   - Values under 10^3 return the raw value with a dash: `"—"`
   - Extremely large values are capped at the highest known suffix.
   - Decimal rounding is optional and defaults to 3 digits.

   Examples:
     NUMNOTE_MAGNITUDE(123456)         → "123.456 k"
     NUMNOTE_MAGNITUDE(987654321, 2)   → "987.65 M"
     NUMNOTE_MAGNITUDE(0.015)          → "0.015 —"
*/

NUMNOTE_MAGNITUDE = LAMBDA(input, [decprec],
    LET(
        max, 30,  // Maximum power of ten to avoid overflow
        decprec, IF(ISOMITTED(decprec), 3, decprec),  // Default precision
        input, ABS(input),  // Absolute value for magnitude calculation

        // Calculate the order of magnitude
        power, TRUNC(LOG(input)),
        category, MOD(power, 3),
        divisor, SWITCH(category, 0, power, 1, power - 1, 2, power - 2),
        adjust, IF(divisor <= max, 10 ^ divisor, 10 ^ max),
        
        // Scaled value and suffix
        value, input / adjust,
        suff, SWITCH(
            divisor,
            0, "—", 3, "k", 6, "M", 9, "G", 12, "T",
            15, "P", 18, "E", 21, "Z", 24, "Y", 27, "R",
            30, "Q", "??"
        ),
        
        // Final output
        output, FIXED(value, decprec, TRUE) & " " & suff,
        output
    )
);

/* NUMNOTE_POWERTAG:
   Purpose:
   Returns only the exponent tag portion of a number’s scientific or power-of-ten notation.
   This does not include the coefficient — just the symbolic representation of the scale.

   Returns:
   - Either an "E+nn" tag or a "10^n" label representing the power of 10.

   Parameters:
   - input (required): A positive numeric value.
   - mode (optional):
       0 (default): "E+nn" format (e.g., "E+03")
       1         : "10^n" format (e.g., "10^3")

   Notes:
   - This function is intended for labeling, formatting, or annotation — not for math.
   - The coefficient (mantissa) is not included in the result.
   - Equivalent to extracting the exponent from scientific notation.
   - Mode 2 from earlier versions has been removed as redundant (Excel supports it via TEXT(..., "0.00E+00"))

   Examples:
     NUMNOTE_POWERTAG(4560)       → "E+03"
     NUMNOTE_POWERTAG(0.00123, 1) → "10^-3"
     TEXTJOIN("", , coeff, NUMNOTE_POWERTAG(x)) → Full label

   See also:
   - NUMNOTE_MAGNITUDE — adds metric suffixes like "k", "M", etc.
   - NUMNOTE_ENGINEERING — includes the coefficient with a fixed exponent
*/


NUMNOTE_POWERTAG = LAMBDA(input, [mode],
    LET(
        // === Set default output mode ===
        // mode = 0 → "E+nn" (default)
        // mode = 1 → "10^n"
        mode, IF(ISOMITTED(mode), 0, mode),

        // === Calculate the base-10 exponent ===
        // TRUNC(LOG10(...)) gives us the order-of-magnitude power
        mag, TRUNC(LOG10(input)),

        // === Format based on mode ===
        // Mode 0 → scientific tag (e.g., E+03)
        // Mode 1 → math expression (e.g., 10^3)
        result, SWITCH(
            mode,
            0, "E+" & TEXT(mag, "00"),
            1, "10^" & mag,
            "Invalid mode"
        ),

        // === Return result ===
        result
    )
);


/* PCT_OF:
   Purpose:
   Calculates a given percentage of a value.

   Returns:
   A scalar value equal to the percentage of the input.

   Parameters:
   - value (required): The base amount (e.g., total or reference value)
   - percent (required): The percent to apply. Can be:
       - A decimal (e.g., 0.25 for 25%)
       - A whole number (e.g., 25, which will be treated as 0.25)
   - precision (optional): Number of decimal places to round the result (default = 3)

   Notes:
   - If `percent` > 1, it's treated as a whole-number percent and divided by 100.
   - Due to this, inputs like 0.333 and 33 will not return exactly the same result.
   - Use to compute percentage-based values with intuitive input handling.

   Example:
   PCT_OF(80, 25) → 20  
   PCT_OF(80, 0.25) → 20  
   PCT_OF(100, 0.333) → 33.3  
   PCT_OF(100, 33) → 33
*/

PCT_OF = LAMBDA(value, percent, [precision],
    LET(
        precision, IF(ISOMITTED(precision) + (precision < 0), 3, precision),
        pct_adj, IF(ABS(percent) > 1, percent / 100, percent),
        ROUND(value * pct_adj, precision)
    )
);



/* PCT_POSITION:
   Purpose: Calculates the relative position of a target value within a range.
   Returns: A decimal value between 0 and 1 (or outside that range if target exceeds bounds).

   Parameters:
   - target (required): The value whose position is being evaluated.
   - max (required): The upper bound of the range.
   - min (required): The lower bound of the range.
   - prec (optional): Number of decimal places to round the result (default = 3).

   Notes:
   - Returns values < 0 or > 1 if `target` is outside the specified range.
   - Equivalent to normalized interpolation: `(target - min) / (max - min)`.
   - Useful for scaling values to a unit range (0–1) for comparisons, gradients, or progress indicators.

   Example:
   PCT_POSITION(7, 10, 0) → 0.7
*/

PCT_POSITION = LAMBDA(min, max, target, [prec],
    LET(
        precision, IF(OR(ISOMITTED(prec), prec < 0), 3, prec),
        position, (target - min) / (max - min),
        result, ROUND(position, precision),
        result
    )
);

/* PCT_INTERPOLATE:
   Purpose: Calculates a value within or beyond a range using interpolation.
   Returns: The interpolant at a given percentage between lbound and ubound.

   Parameters:
   - lbound (required): The lower bound of the range.
   - ubound (required): The upper bound of the range.
   - percentage (required): Decimal representing position between bounds (e.g., 0.25 = 25%)
   - precision (optional): Decimal places to round result (default = 3)

   Notes:
   - Accepts values < 0 or > 1 for extrapolation.
*/

PCT_INTERPOLATE = LAMBDA(lbound, ubound, percentage, [precision],
    LET(
        precision, IF(ISOMITTED(precision)+(precision<0), 3, precision),
        result, ROUND(lbound + (ubound - lbound) * percentage, precision),
        result
    )
);

/* PCT_LBOUND:
   Purpose: Solves for the lower bound given interpolant, upper bound, and percentage.
   Returns: A decimal representing lbound.

   Parameters:
   - interpolant (required): Known value somewhere along the range.
   - ubound (required): The upper bound of the range.
   - percentage (required): Relative position from lbound to ubound.
   - precision (optional): Decimal places to round result (default = 3)

   Notes:
   - Assumes linear relationship between bounds.
*/

PCT_LBOUND = LAMBDA(interpolant, ubound, percentage, [precision],
    LET(
        precision, IF(ISOMITTED(precision)+(precision<0), 3, precision),
        result, ROUND((interpolant - (percentage * ubound))/(1 - percentage),precision),
        result
    )
);

/* PCT_UBOUND:
   Purpose: Solves for the upper bound given lbound, interpolant, and percentage.
   Returns: A decimal representing ubound.

   Parameters:
   - lbound (required): The lower bound of the range.
   - interpolant (required): Known value within the range.
   - percentage (required): Relative position from lbound to ubound.
   - precision (optional): Decimal places to round result (default = 3)

   Notes:
   - Works bidirectionally for extrapolation if percentage < 0 or > 1.
*/

PCT_UBOUND = LAMBDA(lbound, interpolant, percentage, [precision],
    LET(
        precision, IF(ISOMITTED(precision)+(precision<0), 3, precision),
        result, ROUND((interpolant - lbound) / percentage + lbound, precision),
        result
    )
);

/* PCT_REMAP:
   Purpose: Translates a value from one numerical range to its equivalent position in another range 
            by preserving its relative percentage.

   Returns: A decimal value representing the remapped interpolant, rounded to the specified precision.

   Parameters:
   - init_lbound (required): Lower bound of the original range.
   - init_ubound (required): Upper bound of the original range.
   - init_interpolant (required): Value within the original range to be remapped.
   - fin_lbound (required): Lower bound of the target range.
   - fin_ubound (required): Upper bound of the target range.
   - precision (optional): Number of decimal places to round to (default = 3).

   Notes:
   - Performs normalized interpolation: maps a value from one range to its proportional position in another.
   - Useful in scaling, value remapping, UI normalization, or layered coordinate transformations.
   - Does not clamp output — extrapolated values are allowed if `init_interpolant` falls outside the initial range.

   Example:
   PCT_REMAP(0, 100, 75, 1, 5) → 4.0
   (75% of the range [0–100] corresponds to 75% of the range [1–5])
*/

PCT_REMAP = LAMBDA(init_lbound, init_ubound, init_interpolant, fin_lbound, fin_ubound, [precision],

LET(
    precision, IF(ISOMITTED(precision)+(precision<0), 3, precision),
    trans_pct, (init_interpolant - init_lbound)/(init_ubound - init_lbound),
    fin_interpolant, fin_lbound + (fin_ubound - fin_lbound) * trans_pct,
    round(fin_interpolant, precision)
)
);

/* PCT_REMAP_ARRAY:
   Purpose:
   Remaps a list of interpolated values from one numeric range to another,
   preserving each value's relative percentage position.

   Returns:
   A vertical array of remapped values corresponding to the input list.

   Parameters:
   - init_lbound (required): Lower bound of the original range.
   - init_ubound (required): Upper bound of the original range.
   - interpolants (required): A vertical array (column) of values to remap.
   - fin_lbound (required): Lower bound of the new range.
   - fin_ubound (required): Upper bound of the new range.
   - precision (optional): Decimal precision for rounding (default = 3).

   Notes:
   - Each input value is normalized to a percentage position in the initial range,
     then scaled into the final range using linear interpolation.
   - Useful for rescaling data sets, visual gradients, and statistical normalization.
   - Accepts reversed ranges in either the initial or final domain.
   - Values outside the original bounds will extrapolate proportionally.

   Example:
   PCT_REMAP_ARRAY(6000, 7350, A1:A10, 9, 0) → vertical array of remapped values

   Related:
   - PCT_REMAP (for scalar remapping)
   - PCT_POSITION, PCT_INTERPOLATE (for modular use)
*/


PCT_REMAP_ARRAY = LAMBDA(
    input_range, init_lbound, init_ubound, fin_lbound, fin_ubound, [precision],
    LET(
        precision, IF(ISOMITTED(precision) + (precision < 0), 3, precision),
        BYROW(
            input_range,
            LAMBDA(x,
                LET(
                    trans_pct, (x - init_lbound) / (init_ubound - init_lbound),
                    fin_interp, fin_lbound + (fin_ubound - fin_lbound) * trans_pct,
                    ROUND(fin_interp, precision)
                )
            )
        )
    )
);

/* 
RND_DIGITS
Returns a random whole number with a specified number of digits.

If no input is provided → defaults to 5.
If input is non-numeric → returns #VALUE!
If input < 1            → returns #NUM!

Arguments:
- [len] (optional) — Number of digits (must be numeric and ≥ 1)

Returns:
- A random whole number with exactly 'len' digits.

Examples:
- RND_DIGITS()       → 5-digit number (e.g. 49302)
- RND_DIGITS(3)      → 3-digit number (e.g. 218)
- RND_DIGITS(1)      → 0–9
- RND_DIGITS("dog")  → #VALUE!
- RND_DIGITS(-2)     → #NUM!
*/

RND_DIGITS = LAMBDA([len],
    LET(
        // Default to 5 if omitted
        len, IF(ISOMITTED(len), 5, len),

        // Check for numeric input
        valid, ISNUMBER(len),

        // Raise #VALUE! if not a number
        IF(NOT(valid), SQRT("a"),

            // Raise #NUM! if input < 1
            IF(len < 1, SQRT(-1),

                // Otherwise compute bounds and return random number
                LET(
                    min, IF(len = 1, 0, 10 ^ (len - 1)),
                    max, IF(len = 1, 9, 10 ^ len - 1),
                    RANDBETWEEN(min, max)
                )
            )
        )
    )
);


/*
RND_MIX
Generates a random string of mixed characters (letters, numbers, symbols).
If input is non-numeric → returns #VALUE!
If input is < 1          → returns #NUM!
If omitted or zero       → defaults to 5 characters.
*/

RND_MIX = LAMBDA([len],
    LET(
        len, IF(ISOMITTED(len), 5, len),
        valid, ISNUMBER(len),

        IF(NOT(valid), SQRT("a"),                      // #VALUE! if not numeric
            IF(len < 1, SQRT(-1),                      // #NUM! if < 1
                LET(
                    len, INT(len),                     // Truncate to whole number
                    small, SEQUENCE(26, , 97),
                    large, SEQUENCE(26, , 65),
                    numbers, SEQUENCE(10, , 48),
                    extras, {126; 33; 64; 35; 36; 37; 94; 38; 42; 40; 41; 95; 45; 43;
                             61; 123; 91; 125; 93; 124; 92; 58; 59; 60; 44; 62; 46; 63},
                    all_list, VSTACK(small, large, numbers, extras),
                    rand_list, INDEX(all_list, RANDARRAY(len, , 1, COUNTA(all_list), TRUE)),
                    output, CONCAT(BYROW(rand_list, LAMBDA(q, CHAR(q)))),
                    output
                )
            )
        )
    )
);




/*
RND_UNIQUE
Generates a list of unique random numbers by shuffling a generated sequence.

If any input is non-numeric → #VALUE!
If len < 1 or step = 0       → #NUM!
If omitted, defaults to: len = 5, start = 1, step = 1
*/

RND_UNIQUE = LAMBDA([len], [start], [step],
    LET(
        len, IF(ISOMITTED(len), 5, len),
        start, IF(ISOMITTED(start), 1, start),
        step, IF(ISOMITTED(step), 1, step),

        // Input validation
        valid, ISNUMBER(len) * ISNUMBER(start) * ISNUMBER(step),

        IF(NOT(valid), SQRT("a"),          // #VALUE!
            IF(OR(len < 1, step = 0), SQRT(-1),   // #NUM!

                // Generate and shuffle sequence
                LET(
                    len, INT(len),
                    start, INT(start),
                    step, INT(step),
                    base, SEQUENCE(len, , start, step),
                    output, SORTBY(base, RANDARRAY(len)),
                    output
                )
            )
        )
    )
);




/*
RND_STR
Generates a random alphabetic string of specified length.

Arguments:
- [len]  (optional) — Desired number of characters (default = 5)
- [mode] (optional) — Letter case:
    0 → mixed (default)
    1 → lowercase only
    2 → uppercase only

Returns:
- A string composed of randomly selected letters, case based on mode.

Examples:
- RND_STR()         → 5-letter mixed-case string (e.g. "aFbXz")
- RND_STR(8, 1)     → 8-letter lowercase (e.g. "qdnxeaot")
- RND_STR(6, 2)     → 6-letter uppercase (e.g. "HJMXTZ")
*/

RND_STR = LAMBDA([len], [mode],
    LET(
        mode, IF(OR(ISOMITTED(mode), mode > 2), 0, mode),
        len, IF(OR(ISOMITTED(len), len = 0), 5, len),
        valid, ISNUMBER(len) * ISNUMBER(mode),

        IF(NOT(valid), SQRT("a"),
            IF(len < 1, SQRT(-1),
                LET(
                    len, INT(len),
                    small, SEQUENCE(26, , 97, 1),
                    large, SEQUENCE(26, , 65, 1),
                    all_list, VSTACK(small, large),
                    rand_list, SWITCH(
                        mode,
                        0, INDEX(all_list, RANDARRAY(len, , 1, COUNTA(all_list), TRUE)),
                        1, INDEX(small, RANDARRAY(len, , 1, COUNTA(small), TRUE)),
                        2, INDEX(large, RANDARRAY(len, , 1, COUNTA(large), TRUE))
                    ),
                    output, CONCAT(BYROW(rand_list, LAMBDA(q, CHAR(q)))),
                    output
                )
            )
        )
    )
);


/*
RND_BY_SEED
Generates a deterministic pseudo-random number using Lehmer RNG (modulo 2^31−1).

Arguments:
- seed — A numeric seed (should be > 0 and < 2^31−1)

Returns:
- A reproducible pseudo-random value between 1 and 2,147,483,646

Properties:
- The same input seed will always return the same output.
- Useful for testing, reproducible simulations, or deterministic random workflows.

Example:
- RND_BY_SEED(12345) → 595905495
*/

RND_BY_SEED = LAMBDA(seed,
    LET(
        output, MOD(48271 * seed, 2^31 - 1),
        output
    )
);

/*
STAT_QNTILES
Returns equally spaced quantiles from a numeric range, with optional labels and bin-style slicing.

Arguments:
- range       — Numeric input range (e.g., A1:A100)
- [divisions] — (optional) Number of quantile intervals (default = 10)
- [mode]      — (optional) Use "LBL" to return labeled 2-column output (default = values only)
- [style]     — (optional) "ALL" (default) includes 0% and 100%; "BIN" excludes both boundaries
- [precision] — (optional) Decimal rounding precision (default = 3)

Returns:
- A vertical list of quantile values, or a 2-column labeled array, depending on mode.

Examples:
- STAT_QNTILES(A1:A100)                     → Deciles
- STAT_QNTILES(A1:A100, 4, "LBL")           → Quartiles with labels
- STAT_QNTILES(A1:A100, 10, , "BIN")        → Internal bin boundaries (10-tiles)
- STAT_QNTILES(A1:A100, 20, "LBL", "BIN", 2) → Labeled bin cuts with 2-digit rounding
*/

STAT_QNTILES = LAMBDA(range, [divisions], [mode], [style], [precision],
    LET(
        // Normalize optional arguments
        divisions, IF(ISOMITTED(divisions), 10, divisions),
        mode, IF(ISOMITTED(mode), "", UPPER(mode)),
        style, IF(ISOMITTED(style), "ALL", UPPER(style)),
        precision, IF(ISOMITTED(precision), 3, precision),

        // Validation
        countVals, COUNT(range),
        isValid, ISNUMBER(divisions) * ISNUMBER(precision),

        IF(countVals = 0, SQRT("a"),
            IF(OR(NOT(isValid), divisions < 1), SQRT(-1),

                LET(
                    // Percentile cut points based on style
                    pctiles, SWITCH(
                        style,
                        "BIN", SEQUENCE(divisions - 1, 1, 1) / divisions,
                        SEQUENCE(divisions + 1, 1, 0) / divisions  // Default = ALL
                    ),

                    // Label formatting
                    pct_labels, TEXT(pctiles, "0%"),

                    // Calculate quantile values
                    pct_vals, ROUND(PERCENTILE.INC(range, pctiles), precision),

                    // Output formatting
                    IF(mode = "LBL",
                        CHOOSE({1, 2}, pct_labels, VALUE(pct_vals)),
                        TOCOL(pct_vals)
                    )
                )
            )
        )
    )
);


/* STAT_STDERR

Returns the standard error of the mean (SEM) for a numeric array.

Arguments:
- array     = The dataset to evaluate
- mode      = Optional; "pop" for population (default), "samp" for sample
- label     = Optional; "LBL" to return a labeled string, otherwise returns numeric
- precision = Optional; number of decimal places to round result (default: 3)

Notes:
- Standard error reflects the expected variability of the sample mean, assuming the data represents a random sample.
- If the dataset represents the entire population, SEM is mathematically valid but not practically necessary—it models error that doesn’t exist.

Example:
=STAT_STDERR(A1:A100, "samp", "LBL", 2)
→ "Standard Error: 1.27"
*/

STAT_STDERR = LAMBDA(array, [mode], [label], [precision],
    LET(
        precision, IF(ISOMITTED(precision), 3, precision),
        label, IF(ISOMITTED(label), "", label),
        mode, IF(ISOMITTED(mode), "pop", LOWER(mode)),

        // Compute standard error based on mode
        stderr, SWITCH(
            mode,
            "pop", STDEV.P(array) / SQRT(COUNTA(array)),
            "samp", STDEV.S(array) / SQRT(COUNTA(array)),
            STDEV.P(array) / SQRT(COUNTA(array))  // fallback
        ),

        result, ROUND(stderr, precision),

        IF(label = "lbl", "Standard Error: " & result, result)
    )
);



/* STAT_MINMAX

Returns the minimum and maximum of a numeric array, optionally labeled as a two-column array.

Arguments:
- array  = The dataset to evaluate
- prec   = Optional; number of decimal places to round result (default: 3)
- label  = Optional; "LBL" returns two-column output with text and numeric values
- layout = Optional; "H" for horizontal, "V" for vertical (default: "V")

Returns:
- Default: {min; max} numeric array
- If label = "LBL": 
    Min     | value  
    Max     | value  
- Layout mode affects orientation only if label ≠ "LBL"

*/

STAT_MINMAX = LAMBDA(array, [prec], [label], [layout],
    LET(
        prec, IF(ISOMITTED(prec), 3, prec),
        label, IF(ISOMITTED(label), "", UPPER(label)),
        layout, IF(ISOMITTED(layout), "V", UPPER(layout)),

        min_val, ROUND(MIN(array), prec),
        max_val, ROUND(MAX(array), prec),

        result_lbl, VSTACK(
            HSTACK("Min", min_val),
            HSTACK("Max", max_val)
        ),

        result_raw, IF(layout = "H",
            HSTACK(min_val, max_val),
            VSTACK(min_val, max_val)
        ),

        IF(label = "LBL", result_lbl, result_raw)
    )
);

/* STAT_SUMMARY

Provides a concise statistical summary for a numeric array.

Arguments:
- range  = The dataset to evaluate
- mode   = Optional; "SMRY" or "SPAN" (default: SPAN)
           SMRY: Min, Mean, Median, Max, Stdev
           SPAN: Min, μ−σ, Mean, μ+σ, Max, Stdev
- label  = Optional; "LBL" returns a two-column labeled array
- prec   = Optional; number of decimal places (default: 3)

Returns:
- A vertical numeric array or labeled matrix depending on mode and label flag

Mode Descriptions:
- "SMRY": Balanced snapshot of center and spread
- "SPAN": Emphasizes distribution shape around the mean (μ ± σ),
          with clear labeling of Mean (μ) and Stdev (σ) only

*/

STAT_SUMMARY = LAMBDA(range, [mode], [label], [prec],
    LET(
        raw_mode, IF(ISOMITTED(mode), "SPAN", UPPER(mode)),
        mode, IF(OR(raw_mode = "SMRY", raw_mode = "SPAN"), raw_mode, 1/0),

        label, IF(ISOMITTED(label), "", UPPER(label)),
        prec, IF(ISOMITTED(prec), 3, prec),

        μ, AVERAGE(range),
        σ, STDEV.P(range),
        min_val, MIN(range),
        max_val, MAX(range),
        med_val, MEDIAN(range),
        μ_minus_σ, μ - σ,
        μ_plus_σ, μ + σ,

        // Summary mode: Min, Mean, Median, Max, Stdev
        smry_vals, VSTACK(
            min_val,
            μ,
            med_val,
            max_val,
            σ
        ),
        smry_labels, VSTACK("Min", "Mean (μ)", "Median", "Max", "Stdev (σ)"),

        // Span mode: Min, μ−σ, Mean, μ+σ, Max, σ
        span_vals, VSTACK(
            min_val,
            μ_minus_σ,
            μ,
            μ_plus_σ,
            max_val,
            σ
        ),
        span_labels, VSTACK("Min", "μ − σ", "Mean (μ)", "μ + σ", "Max", "Stdev (σ)"),

        selected_vals, IF(mode = "SPAN", span_vals, smry_vals),
        selected_labels, IF(mode = "SPAN", span_labels, smry_labels),

        rounded_vals, ROUND(selected_vals, prec),

        result, IF(label = "LBL",
            HSTACK(selected_labels, rounded_vals),
            rounded_vals
        ),

        result
    )
);

/* STAT_GEO5

Returns a geometric five-point summary of a numeric range.

This is NOT a percentile-based summary (like quartiles),
but a symmetric positional scaffold across the Min–Max span.

Arguments:
- range   : Required array of numeric values
- label   : Optional; use "LBL" for labeled 2-column output (default: unlabeled)
- prec    : Optional; number of decimal places (default: 3)

Returns:
- A vertical numeric array or labeled matrix including:
  {Min, Lower Mid, Midrange, Upper Mid, Max}

Formulas:
- Min         = MIN(range)
- Midrange    = (MIN + MAX) / 2
- Lower Mid   = (MIN + Midrange) / 2
- Upper Mid   = (Midrange + MAX) / 2
- Max         = MAX(range)

Note:
- This function is **distribution-agnostic**. It reports numeric position only, 
  without regard to the frequency or clustering of values. That means datasets 
  with highly skewed or repetitive values may still yield evenly spaced results 
  if Min and Max remain the same. It is best understood as a *symmetry scaffold*, 
  not a distributional analysis.

*/

STAT_GEO5 = LAMBDA(range, [label], [prec],
    LET(
        label, IF(ISOMITTED(label), "", UPPER(label)),
        prec, IF(ISOMITTED(prec), 3, prec),

        min_val, MIN(range),
        max_val, MAX(range),
        midrange, (min_val + max_val) / 2,
        lower_mid, (min_val + midrange) / 2,
        upper_mid, (midrange + max_val) / 2,

        raw_vals, VSTACK(min_val, lower_mid, midrange, upper_mid, max_val),
        rounded_vals, ROUND(raw_vals, prec),

        labels, VSTACK("Min", "Lower Mid", "Midrange", "Upper Mid", "Max"),

        output, IF(label = "LBL", HSTACK(labels, rounded_vals), rounded_vals),

        output
    )
);

/* STAT_VOLUME

Returns basic volumetric stats for a numeric range.

Arguments:
- range   : Required numeric array
- label   : Optional; use "LBL" for labeled 2-column output
- prec    : Optional; number of decimal places (default: 3)

Returns:
- Count
- Sum
- Mean (μ)

*/

STAT_VOLUME = LAMBDA(range, [label], [prec],
    LET(
        label, IF(ISOMITTED(label), "", UPPER(label)),
        prec, IF(ISOMITTED(prec), 3, prec),

        count_val, COUNT(range),
        sum_val, SUM(range),
        mean_val, IF(count_val > 0, AVERAGE(range), NA()),

        raw_vals, VSTACK(count_val, sum_val, mean_val),
        rounded_vals, ROUND(raw_vals, prec),

        labels, VSTACK("Count", "Sum", "Mean (μ)"),

        output, IF(label = "LBL", HSTACK(labels, rounded_vals), rounded_vals),

        output
    )
);

/* STAT_SHAPE

Returns central tendency and shape descriptors for a numeric array.

Arguments:
- range   : Required numeric array
- label   : Optional; use "LBL" for labeled 2-column output
- prec    : Optional; number of decimal places (default: 3)

Returns:
- Mean (μ)
- Median
- Skew.P
- Kurt.P

Note:
- Returns #N/A for Skew or Kurtosis if fewer than 3 values are present.

*/

STAT_SHAPE = LAMBDA(range, [label], [prec],
    LET(
        label, IF(ISOMITTED(label), "", UPPER(label)),
        prec, IF(ISOMITTED(prec), 3, prec),

        count_val, COUNT(range),

        μ, IF(count_val > 0, AVERAGE(range), NA()),
        med, IF(count_val > 0, MEDIAN(range), NA()),
        skew, IF(count_val > 2, SKEW.P(range), NA()),
        kurt, IF(count_val > 3, KURT(range), NA()),

        raw_vals, VSTACK(μ, med, skew, kurt),
        rounded_vals, ROUND(raw_vals, prec),

        labels, VSTACK("Mean (μ)", "Median", "Skew (P)", "Kurtosis (P)"),

        output, IF(label = "LBL", HSTACK(labels, rounded_vals), rounded_vals),

        output
    )
);





/* STAT_MIDRANGE

Returns the midrange of a numeric array: the average of its Min and Max.

Arguments:
- array : required numeric range
- prec  : optional number of decimal places (default = 3)

Returns:
- A single numeric value: (MIN + MAX) / 2

*/

STAT_MIDRANGE = LAMBDA(array, [prec],
    LET(
        prec, IF(ISOMITTED(prec), 3, prec),
        count_val, COUNT(array),
        midrange, IF(count_val = 0, NA(), AVERAGE(MIN(array), MAX(array))),
        ROUND(midrange, prec)
    )
);


/* STAT_FREQ_TABLE

Generates a frequency table from a numeric range.

Arguments:
- range : required numeric input
- mode  : optional keyword ("LBL" to include column headers; default = no headers)

Returns:
- A 3-column spilled array:
    • Column 1: Unique values
    • Column 2: Frequency (count)
    • Column 3: Weighted product (value × count)

Notes:
- Sorted in ascending order
- Includes headers if mode = "LBL"
- Useful for mode analysis, weighted means, and distribution overview

*/

STAT_FREQ_TABLE = LAMBDA(range, [mode],
    LET(
        // Handle label mode
        mode, IF(ISOMITTED(mode), "", UPPER(mode)),

        // Prepare unique values in sorted order
        u_vals, SORT(UNIQUE(range)),

        // Frequency counts per unique value
        weights, BYROW(u_vals, LAMBDA(a, COUNTIF(range, a))),

        // Weighted value × frequency
        products, u_vals * weights,

        // Add column headers if "LBL" mode
        values_col, IF(mode = "LBL", VSTACK("Value", u_vals), u_vals),
        weights_col, IF(mode = "LBL", VSTACK("Weight", weights), weights),
        products_col, IF(mode = "LBL", VSTACK("Product", products), products),

        // Final output
        HSTACK(values_col, weights_col, products_col)
    )
);


/* STAT_WTD_AVG

Returns the weighted average of a value set based on a matching weight set.

Arguments:
- wts    : array of weights
- values : array of values (same length as weights)

Returns:
- Weighted average = SUMPRODUCT(wts, values) / SUM(wts)
- Returns #N/A if input lengths mismatch or weight sum is zero

*/

STAT_WTD_AVG = LAMBDA(wts, values,
    LET(
        len_match, COUNTA(wts) = COUNTA(values),
        total_wt, SUM(wts),
        result, IF(
            NOT(len_match) + (total_wt = 0),
            NA(),
            SUMPRODUCT(wts, values) / total_wt
        ),
        result
    )
);

/* STAT_SELF_WTD_AVG

Returns a self-weighted average of values, where each value is treated as its own weight.

Arguments:
- range : numeric array

Returns:
- Σ(xᵢ²) / Σ(xᵢ)
- Returns #N/A if total sum = 0

*/

STAT_SELF_WTD_AVG = LAMBDA(range,
    LET(
        sum_vals, SUM(range),
        result, IF(sum_vals = 0, NA(), SUMPRODUCT(range, range) / sum_vals),
        result
    )
);


/* STAT_PCT_REMAP

Rescales a value from one numeric range into another, preserving its
relative position (percentile) between the two intervals.

Arguments:
- StartMin, StartMax : original numeric range
- Target             : value within the original range
- EndMin, EndMax     : destination range
- decprec (optional) : decimal precision (default = 15)

Returns:
- The percentile-equivalent value in the second range

Example:
    STAT_PCT_REMAP(3, 11, 5, 2, 19)
    → 6.25 (since 5 is 25% between 3–11, and 6.25 is 25% between 2–19)

*/

STAT_PCT_REMAP = LAMBDA(StartMin, StartMax, Target, EndMin, EndMax, [decprec],
    LET(
        decprec, IF(ISOMITTED(decprec), 15, decprec),
        pct, (Target - StartMin) / (StartMax - StartMin),
        calc, pct * (EndMax - EndMin) + EndMin,
        ROUND(calc, decprec)
    )
);


/* STAT_PCT_OF_RANGE

Returns the percentile (as a decimal fraction) that a value represents
within a specified numeric range.

Arguments:
- min      : lower bound of range
- max      : upper bound of range
- value    : value to evaluate
- decprec  : optional decimal precision (default = 15)

Returns:
- The proportional position of `value` in the range [min, max]

Example:
    STAT_PCT_OF_RANGE(3, 12, 7)
    → 0.444... (because 7 is 44.4% of the way from 3 to 12)

*/

STAT_PCT_OF_RANGE = LAMBDA(min, max, value, [decprec],
    LET(
        decprec, IF(ISOMITTED(decprec), 15, decprec),
        calc, (value - min) / (max - min),
        ROUND(calc, decprec)
    )
);


/* STAT_VALUE_OF_PCT

Returns the value that corresponds to a given percentage (as a decimal) 
within a specified numeric range.

Arguments:
- min      : lower bound of range
- max      : upper bound of range
- pct      : percentage expressed as a decimal (e.g. 0.4065 for 40.65%)
- decprec  : optional decimal precision (default = 15)

Returns:
- The value at the given percentile between min and max

Example:
    STAT_VALUE_OF_PCT(3, 12, 0.4065)
    → 6.6585 (which is 40.65% between 3 and 12)

*/

STAT_VALUE_OF_PCT = LAMBDA(min, max, pct, [decprec],
    LET(
        decprec, IF(ISOMITTED(decprec), 15, decprec),
        calc, pct * (max - min) + min,
        ROUND(calc, decprec)
    )
);


/* STAT_BENFORD_TABLE

Returns the theoretical Benford distribution probabilities for leading digits 1 through 9.

Arguments:
- mode (optional): 
    - "LBL" → returns a 2-column array: Digit | Probability
    - blank/omitted → returns raw probabilities only (1-column)

Returns:
- A vertical list of 9 Benford probabilities (log-based distribution)
- Optionally labeled with digits 1 through 9

Formula:
- P(d) = LOG10(1 + 1/d), for d in {1, 2, ..., 9}

Commonly used for:
- Detecting unnatural patterns in datasets
- Fraud detection and forensic accounting
- Modeling distributions of naturally occurring numerical data

*/

STAT_BENFORD_TABLE = LAMBDA([mode],
    LET(
        mode, IF(ISOMITTED(mode), "", UPPER(mode)),

        // Digits 1 through 9
        digits, SEQUENCE(9, , 1, 1),

        // Benford probabilities
        probs, BYROW(digits, LAMBDA(d, LOG10(1 + (1 / d)))),

        // Optional labeled output
        result, IF(
            mode = "LBL",
            HSTACK(digits, probs),
            probs
        ),

        result
    )
);

/* STAT_RND_BENFORD

Generates one or more random digits based on the Benford distribution.

Arguments:
- digits (optional): number of digits to return (default = 1)

Returns:
- A single-digit number if digits = 1
- A multi-digit number composed of Benford-distributed digits otherwise

Distribution:
- Based on leading digit probabilities:
    P(d) = LOG10(1 + 1/d) for d ∈ {1..9}

*/

STAT_RND_BENFORD = LAMBDA([digits],
    LET(
        digits, IF(ISOMITTED(digits), 1, digits),

        // Digit range 1–9
        numlist, SEQUENCE(9, , 1, 1),

        // Cumulative Benford probabilities
        problist, {0.301, 0.477, 0.602, 0.699, 0.778, 0.845, 0.903, 0.954, 1},

        // Generate random array of percentiles
        rand_nums, RANDARRAY(digits, 1),

        // Match to digit via percentile mapping
        indices, MATCH(XLOOKUP(rand_nums, problist, problist, , 1), problist, 1),
        digits_generated, INDEX(numlist, indices),

        // Output as numeric value
        output, IF(
            digits = 1,
            VALUE(digits_generated),
            VALUE(TEXTJOIN("", TRUE, digits_generated))
        ),

        output
    )
);

/* STAT_VAL_BRACKET

Returns the values in a dataset that bracket a specified target value.

Arguments:
- TestArray : array of numeric values
- Target    : the value to find bracketing bounds for
- incl      : optional, "INC" (default) includes target in result, "EXC" excludes it
- mode      : optional layout:
    "VER" = vertical array (default)
    "HOR" = horizontal array
    "STR" = string format "(lower : [target] : upper)"
- lbl       : optional keyword "LBL" to include labels in output (ignored in "STR" mode)
- prec      : optional decimal precision to round to (default = 3)

Returns:
- The values immediately above and below the target (or also the target, if "INC")
- Output as array (vertical or horizontal), string, or labeled array

*/

STAT_VAL_BRACKET = LAMBDA(TestArray, Target, [incl], [mode], [lbl], [prec],
    LET(
        prec, IF(ISOMITTED(prec), 3, prec),
        mode, UPPER(IF(ISOMITTED(mode), "VER", mode)),
        lbl, UPPER(IF(ISOMITTED(lbl), "", lbl)),
        lbl_val, lbl = "LBL",
        incl, UPPER(IF(ISOMITTED(incl), "INC", incl)),

        // Compute bounding values
        lower, MAX(FILTER(TestArray, TestArray < Target)),
        upper, MIN(FILTER(TestArray, TestArray > Target)),

        // Build value list based on inclusion
        val_array, IF(incl = "INC", VSTACK(lower, Target, upper), VSTACK(lower, upper)),
        val_array_r, ROUND(val_array, prec),

        // Corresponding label list
        lbl_array, IF(incl = "INC",
            {"Lower"; "Target"; "Upper"},
            {"Lower"; "Upper"}
        ),

        // Output selector
        output, SWITCH(
            mode,
            "STR", "(" & TEXTJOIN(" : ", , FIXED(val_array_r, prec)) & ")",
            "HOR", IF(lbl_val,
                VSTACK(TRANSPOSE(lbl_array), TRANSPOSE(val_array_r)),
                TRANSPOSE(val_array_r)
            ),
            "VER", IF(lbl_val,
                HSTACK(lbl_array, val_array_r),
                val_array_r
            ),
            val_array_r  // fallback default
        ),

        output
    )
);



/* STR_GETDIGITS
   Purpose:
   Extracts all digit characters (0–9) from a text string and returns them as a single string.

   Behavior:
   - Returns a string containing only the digits from the input text.
   - If no digits are found, returns a fallback value (optional).
   - Defaults to "#NONE!" if no digits are found and no fallback is provided.
   - Preserves digit order; ignores non-numeric characters (including decimal points, symbols, etc.)

   Inputs:
   - input      : Text string to parse for digits.
   - [fallback] : Optional. Value to return if no digits are found (default: "#NONE!")

   Example:
   STR_GETDIGITS("Room 42B")          → "42"
   STR_GETDIGITS("Code: abc")        → "#NONE!"
   STR_GETDIGITS("abc", "")          → ""
*/

STR_GETDIGITS = LAMBDA(input, [fallback],
    LET(
        // Break the input into an array of individual characters
        arr_chars, MID(input, SEQUENCE(LEN(input)), 1),

        // Keep only those characters that are valid digits (0–9)
        arr_digits, IF(ISNUMBER(VALUE(arr_chars)), arr_chars, ""),

        // Concatenate the remaining digits into a single string
        result, TEXTJOIN("", TRUE, arr_digits),

        // Return fallback if result is empty
        IF(result = "", IF(ISOMITTED(fallback), "#NONE!", fallback), result)
    )
);


/* STR_GETCHARS
   Purpose:
   Extracts all non-digit characters from a text string and returns them as a single string.

   Behavior:
   - Returns a string containing only characters that are *not* numeric digits (0–9).
   - Preserves character order.
   - If no non-digit characters remain, returns fallback value (default: "#NONE!")

   Inputs:
   - input      : Text string to process.
   - [fallback] : Optional. Value to return if all characters are digits (default: "#NONE!")

   Example:
   STR_GETCHARS("abc123")        → "abc"
   STR_GETCHARS("404")           → "#NONE!"
   STR_GETCHARS("404", "")       → ""
*/

STR_GETCHARS = LAMBDA(input, [fallback],
    LET(
        // Break input into array of single characters
        arr_chars, MID(input, SEQUENCE(LEN(input)), 1),

        // Keep only characters that fail numeric coercion
        arr_nondigits, IF(ISNUMBER(VALUE(arr_chars)), "", arr_chars),

        // Combine remaining characters into a single string
        result, TEXTJOIN("", TRUE, arr_nondigits),

        // Return fallback if no non-digit characters were found
        IF(result = "", IF(ISOMITTED(fallback), "#NONE!", fallback), result)
    )
);

/* STR_FILTERCHARS
   Purpose:
   Filters characters from a string based on a named mode.

   Modes:
   "DGT" or "DIG" → Keep only digit characters (0–9)
   "LTR"          → Keep only letter characters (A–Z, a–z)
   "ELS"          → Keep only characters that are NOT digits, letters, or whitespace

   Behavior:
   - Characters are evaluated one-by-one using ASCII codes.
   - Whitespace includes standard spaces, tabs, line breaks, NBSP, ZWSP, and NNBSP.
   - If no characters match the mode, returns fallback value (default: "#NONE!")

   Inputs:
   - input      : Text string to process.
   - [mode]     : Filtering mode (default: "DGT")
   - [fallback] : Optional value to return if result is empty (default: "#NONE!")

   Example:
   STR_FILTERCHARS("abc123!? ", "ELS") → "!?"
*/

STR_FILTERCHARS = LAMBDA(input, [mode], [fallback],
    LET(
        // Normalize mode input
        mode, IF(ISOMITTED(mode), "DGT", UPPER(mode)),

        // Break string into array of characters
        arr_chars, MID(input, SEQUENCE(LEN(input)), 1),
        arr_code, CODE(arr_chars),

        // Logic flags
        arr_isDigit, (arr_code >= 48) * (arr_code <= 57),
        arr_isUpper, (arr_code >= 65) * (arr_code <= 90),
        arr_isLower, (arr_code >= 97) * (arr_code <= 122),
        arr_isLetter, arr_isUpper + arr_isLower,
        arr_isWhitespace,
            (arr_code = 32) + (arr_code = 9) + (arr_code = 160) +
            (arr_code = 10) + (arr_code = 13) +
            (arr_chars = UNICHAR(8203)) + (arr_chars = UNICHAR(8239)),

        // Filter characters based on mode
        arr_filtered, SWITCH(
            mode,
            "DGT", IF(arr_isDigit, arr_chars, ""),
            "DIG", IF(arr_isDigit, arr_chars, ""),
            "LTR", IF(arr_isLetter, arr_chars, ""),
            "ELS", IF(NOT(arr_isDigit + arr_isLetter + arr_isWhitespace), arr_chars, ""),
            arr_chars // fallback mode: return original string unfiltered
        ),

        // Join and finalize output
        result, TEXTJOIN("", TRUE, arr_filtered),
        IF(result = "", IF(ISOMITTED(fallback), "#NONE!", fallback), result)
    )
);

/* STR_SANITIZE
   Purpose:
   Replaces problematic or invisible whitespace characters with a standard ASCII space character (CHAR(32)).
   This is useful for normalizing copy-pasted or imported text from browsers, PDFs, or systems like Banner.

   Characters replaced with " " (CHAR(32)):
   - CHAR(9)    : Tab
   - CHAR(10)   : Line Feed (LF)
   - CHAR(13)   : Carriage Return (CR)
   - CHAR(160)  : Non-breaking Space (NBSP)
   - CHAR(8203) : Zero-width Space (ZWSP)
   - CHAR(8239) : Narrow No-break Space (NNBSP)

   Input:
   - text : The string to sanitize

   Output:
   - A string with all problematic whitespace replaced by normal spaces

   Example:
   STR_SANITIZE_WHITESPACE("hello" & CHAR(160) & "world") → "hello world"
*/

STR_SANITIZE = LAMBDA(text,
    LET(
        step1, SUBSTITUTE(text, CHAR(160), " "),
        step2, SUBSTITUTE(step1, CHAR(9), " "),
        step3, SUBSTITUTE(step2, CHAR(10), " "),
        step4, SUBSTITUTE(step3, CHAR(13), " "),
        step5, SUBSTITUTE(step4, UNICHAR(8203), " "),
        step6, SUBSTITUTE(step5, UNICHAR(8239), " "),
        step6
    )
);


/* STR_SPLITCHARS
   Purpose:
   Splits a text string into its individual characters and returns them
   as either a column (vertical) or row (horizontal) array.

   Modes:
   "C" (default) – column output (vertical array)
   "R"           – row output (horizontal array)

   Inputs:
   - input : Text string to split into characters
   - [mode]: Optional. "C" for column, "R" for row (default: "C")

   Examples:
   STR_SPLITCHARS("abc")        → {"a"; "b"; "c"}
   STR_SPLITCHARS("abc", "R")   → {"a", "b", "c"}
*/

STR_SPLITCHARS = LAMBDA(input, [mode],
    LET(
        mode, IF(ISOMITTED(mode), "R", UPPER(mode)),
        arr_chars, MID(input, SEQUENCE(LEN(input)), 1),
        IF(mode = "C", arr_chars, TRANSPOSE(arr_chars))
    )
)
;

/* STR_UNIQUECHARS
   Purpose:
   Returns the unique characters from a string, with optional case normalization and sorting.

   Inputs:
   - input  : Text string to analyze
   - [style]: Optional. Case control (default: "RAW")
       "RAW" = preserve original case
       "LO"  = convert to lowercase
       "UP"  = convert to uppercase

   - [mode] : Optional. Deduplication control (default: "ALL")
       "ALL" = keep all characters, including duplicates
       "UNS" = unique characters in original order
       "SRT" = sorted unique characters

   Behavior:
   - Removes all spaces before processing
   - Case-insensitive parameter values (e.g., "lo", "Lo", "LO" all valid)
   - Useful for character set audits, alphabet extraction, or deduplication tasks

   Example:
   STR_UNIQUECHARS("banana", "UP", "SRT") → "ABN"
*/

STR_UNIQUECHARS = LAMBDA(input, [style], [mode],
    LET(
        // Normalize style and mode inputs to uppercase
        style, IF(ISOMITTED(style), "RAW", UPPER(style)),
        mode, IF(ISOMITTED(mode), "ALL", UPPER(mode)),

        // Remove spaces and split into array of characters
        stripped, SUBSTITUTE(input, " ", ""),
        arr_chars, MID(stripped, SEQUENCE(LEN(stripped)), 1),

        // Apply case style
        arr_styled, SWITCH(
            style,
            "LO", LOWER(arr_chars),
            "UP", UPPER(arr_chars),
            arr_chars
        ),

        // Apply deduplication/sorting mode
        result, SWITCH(
            mode,
            "UNS", CONCAT(UNIQUE(arr_styled)),
            "SRT", CONCAT(SORT(UNIQUE(arr_styled))),
            CONCAT(arr_styled) // default: ALL
        ),

        result
    )
)
;

/* STR_HASCAP_AFTERFIRST
   Purpose:
   Returns TRUE if a string contains an uppercase letter *after* the first character.
   Useful for detecting camelCase names, prefixes, or embedded proper fragments in strings.

   Input:
   - word : Text string (usually a name)

   Output:
   - TRUE if there is a capital letter beyond the first character; FALSE otherwise

   Example:
   STR_HASCAP_AFTERFIRST("vanCamp") → TRUE
   STR_HASCAP_AFTERFIRST("Smith")   → FALSE
   STR_HASCAP_AFTERFIRST("DeLaRosa") → TRUE
*/

STR_HASCAP_AFTERFIRST = LAMBDA(word,
    LET(
        count, LEN(word),
        subword, RIGHT(word, count - 1),
        letter, LEFT(subword, 1),
        code, CODE(letter),
        test, AND(code >= 65, code <= 90),
        IF(AND(NOT(test), LEN(subword) > 1), STR_HASCAP_AFTERFIRST(subword), test)
    )
)
;


/* STR_TEXTBETWEEN
   Purpose:
   Extracts the substring between two delimiters.
   Supports optional inclusion of the delimiters and defaults to symmetric matching.

   Inputs:
   - input         : Full text string to search
   - delim1        : Starting delimiter
   - [delim2]      : Optional. Ending delimiter (defaults to delim1)
   - [includeDelims]: Optional. TRUE to include both delimiters in output (default: FALSE)

   Behavior:
   - If either delimiter is not found, returns "#DELIM!"
   - Only extracts the first matching occurrence
   - Case-sensitive delimiter matching
   - Symmetric behavior if only one delimiter provided

   Examples:
   STR_TEXTBETWEEN("A [target] B", "[", "]")        → "target"
   STR_TEXTBETWEEN("A [target] B", "[", "]", TRUE)  → "[target]"
   STR_TEXTBETWEEN("No closing brace here", "[")    → "#DELIM!"
*/

STR_TEXTBETWEEN = LAMBDA(input, delim1, [delim2], [includeDelims],
    LET(
        delim2, IF(ISOMITTED(delim2), delim1, delim2),
        includeDelims, IF(ISOMITTED(includeDelims), FALSE, includeDelims),

        startPos, FIND(delim1, input),
        endPos, FIND(delim2, input, startPos + LEN(delim1)),

        midText, MID(input, startPos + LEN(delim1), endPos - startPos - LEN(delim1)),

        result, IF(includeDelims, delim1 & midText & delim2, midText),
        output, IFERROR(result, "#DELIM!"),
        output
    )
)
;

/* STR_REMOVE_ENCLOSED
   Purpose:
   Recursively removes all substrings enclosed in parentheses, including the parentheses themselves.

   Inputs:
   - input : Text string potentially containing one or more (...) structures

   Behavior:
   - Searches for the first "(" and ")" pair
   - Removes the enclosed substring including the delimiters
   - Repeats recursively until no parentheses remain
   - Does not handle nested parentheses correctly (i.e., treats them as flat pairs)

   Example:
   STR_REMOVE_ENCLOSED("Hello (world), this is (Myndhre)") → "Hello , this is "
   STR_REMOVE_ENCLOSED("Name (P)")                         → "Name "

   Limitations:
   - Assumes well-formed input (i.e., every open paren has a matching close)
   - Not intended for nested or mismatched structures

   See also:
   - STR_TEXTBETWEEN for extraction, not removal
   - STR_SANITIZE_WHITESPACE for non-structural cleaning
*/

STR_REMOVE_ENCLOSED = LAMBDA(input,
    IF(ISERROR(SEARCH("(", input)),
        input,
        LET(
            first_find, SEARCH("(", input),
            second_find, SEARCH(")", input),
            new_string,
                LEFT(input, first_find - 1) &
                MID(input, second_find + 1, LEN(input)),
            STR_REMOVE_ENCLOSED(new_string)
        )
    )
)
;

/* STR_COUNTCHAR
   Purpose:
   Counts how many times a given character appears in a string.

   Inputs:
   - input  : Text string to search
   - target : Character to count (only the first character is used if input is longer)

   Behavior:
   - Case-sensitive comparison
   - Strips input into characters and compares each to the target
   - Returns the count of exact matches

   Examples:
   STR_COUNTCHAR("banana", "a") → 3
   STR_COUNTCHAR("banana", "n") → 2
   STR_COUNTCHAR("banana", "na") → 3 (only the first char "n" is used)
*/

STR_COUNTCHAR = LAMBDA(input, target,
    LET(
        char, LEFT(target, 1),
        arr_chars, MID(input, SEQUENCE(LEN(input)), 1),
        matches, arr_chars = char,
        result, SUM(--matches),
        result
    )
);


/* SUM_N_TERMS:
   Purpose: Calculates the sum of an arithmetic progression.
   Returns: Total sum of the sequence (scalar) or its upper bound if mode = 1.

   Parameters:
   - lbound (required): The starting value of the sequence.
   - length (required): The number of items in the sequence.
   - increment (optional): Step between values (default is 1).
   - mode (optional): 0 = return sum (default), 1 = return upper bound only.

   Notes:
   - Uses the arithmetic series formula.
   - Useful for calculating uniform intervals in controlled progressions.

   Example:
   SUM_N_TERMS(4, 15, 5) → 585
   (Sums 4 + 9 + 14 + ... + 74, incrementing by 5)
*/

SUM_N_TERMS = LAMBDA(lbound, length, [increment], [mode],
    LET(
        mode, IF(OR(ISOMITTED(mode), mode > 1), 0, mode),             /* Default mode = 0 (sum) */
        increment, IF(ISOMITTED(increment), 1, increment),            /* Default increment = 1 */
        ubound, lbound + (length - 1) * increment,                    /* Calculate upper bound of the series */
        total, (length / 2) * ((2 * lbound) + ((length - 1) * increment)), /* Arithmetic progression sum formula */
        SWITCH(mode,
            0, total,     /* Return full sum */
            1, ubound     /* Return upper bound only */
        )
    )
);


/* SUM_INTEGERS:
   Purpose: Calculates the sum of natural, even, or odd numbers up to a given value.
   Returns: Sum of numbers from 1 to n, or only even/odd numbers, depending on mode.

   Parameters:
   - input (required): Upper limit of summation.
   - mode (optional): 
     0 = sum of all integers from 1 to input (default),
     1 = sum of all even numbers ≤ input,
     2 = sum of all odd numbers ≤ input.

   Notes:
   - Uses closed-form formulas for performance.
   - Designed for quick access to basic sequence sums.

   Example:
   SUM_INTEGERS(10) → 55  (1+2+3+...+10)
   SUM_INTEGERS(10, 1) → 30  (2+4+6+8+10)
   SUM_INTEGERS(10, 2) → 25  (1+3+5+7+9)
*/

SUM_INTEGERS = LAMBDA(input, [mode],
    LET(
        mode, IF(OR(ISOMITTED(mode), mode > 2), 0, mode),    /* Default to mode 0 (all integers) */
        
        even_ubound, IF(ISEVEN(input), input, input - 1),     /* Nearest even ≤ input */
        odd_ubound, IF(ISODD(input), input, input - 1),       /* Nearest odd ≤ input */
        
        output, SWITCH(
            mode,
            0, (input * (input + 1)) / 2,                     /* Sum of all integers from 1 to n */
            1, (even_ubound * (even_ubound + 2)) / 4,         /* Sum of even numbers: n(n+2)/4 */
            2, ((odd_ubound + 1) / 2) ^ 2                     /* Sum of odd numbers: ((n+1)/2)^2 */
        ),
        output
    )
);

/* SUM_RANGE:
   Purpose: Calculates the sum of an arithmetic series, either by specifying a full range
            (lower and upper bounds and optional increment) or just a single upper bound
            for a 1-to-n sum.

   Returns: A single number representing the arithmetic sum.

   Parameters:
   - lbound (required): Lower bound of the sequence. If `ubound` is omitted, treated as 1.
   - ubound (optional): Upper bound of the sequence. If omitted, `lbound` is treated as the upper bound and 1 is used as the lower bound.
   - increment (optional): The amount to increase each step by (default = 1).

   Notes:
   - Handles both ascending and descending sequences.
   - Can be used as a direct replacement for SERIES_SUM and SUM_INTEGERS with `increment = 1`.

   Example:
   SUM_RANGE(1, 10) → 55
   SUM_RANGE(3, 15, 3) → 45 (3 + 6 + 9 + 12 + 15)
   SUM_RANGE(10) → 55 (same as SUM_RANGE(1, 10))
*/

SUM_RANGE = LAMBDA(lbound, [ubound], [increment],
    LET(
        // Handle default usage: SUM_RANGE(10) → sum 1 to 10
        ubound_internal, IF(ISOMITTED(ubound), lbound, ubound),
        lbound_internal, IF(ISOMITTED(ubound), 1, lbound),

        // Default increment is 1 if omitted
        step, IF(ISOMITTED(increment), 1, increment),

        // Calculate number of terms in the sequence (inclusive)
        length, TRUNC((ubound_internal - lbound_internal) / step) + 1,

        // Apply arithmetic series formula:
        // sum = (n / 2) * (2a + (n - 1)d)
        total, (length / 2) * ((2 * lbound_internal) + ((length - 1) * step)),

        total
    )
);


/* SUM_BETWEEN_BOUNDS:
   Purpose:
   Returns the sum of an arithmetic sequence starting from a lower bound and increasing by a fixed increment up to an upper bound.

   Returns:
   A scalar value representing the total of all valid terms in the range.

   Parameters:
   - lbound (required): The starting value of the sequence.
   - ubound (optional): The maximum value the sequence may reach (default = lbound, i.e., single-term sum).
   - increment (optional): The step size between terms (default = 1).

   Notes:
   - If only lbound is provided, returns that value (single term).
   - If increment is omitted, defaults to 1.
   - Uses the arithmetic series sum formula to avoid iteration.
   - Result reflects only full steps that do not exceed the upper bound.

   Example:
   SUM_BETWEEN_BOUNDS(4, 20, 3) → 69
   (Sums: 4 + 7 + 10 + 13 + 16 + 19)
*/

SUM_BETWEEN_BOUNDS = LAMBDA(lbound, [ubound], [increment],
    LET(
        // Default to single term if ubound is omitted
        u_bound, IF(ISOMITTED(ubound), lbound, ubound),

        // Default lbound to 1 if only one argument was passed (for symmetry)
        lbound, IF(ISOMITTED(ubound), 1, lbound),

        // Default increment to 1 if omitted
        increment, IF(ISOMITTED(increment), 1, increment),

        // Calculate the number of terms in the sequence that do not exceed u_bound
        length, TRUNC((u_bound - lbound) / increment) + 1,

        // Use arithmetic series sum formula
        total, (length / 2) * ((2 * lbound) + ((length - 1) * increment)),

        total
    )
);

/* TIME_UNITS_TO_DECIMAL:
   Purpose:
   Converts a combination of time units (years, days, hours, minutes, seconds)
   into a single decimal value in the specified output unit.

   Returns:
   Either a numeric value or a formatted string (e.g., "123.45h"), depending on output mode.

   Parameters:
   - unit (required): Output unit (Y, D, H, M, S). Accepts Y, D, H, M, S or their full words.
   - y, d, h, m, s (optional): Components of time (default = 0)
   - outputMode (optional): 
       0 (default) = numeric decimal result  
       1 = text string with unit suffix (e.g., `12.5h`)

   Notes:
   - Uses astronomical year definitions (1 year = 365.25 days = 8766 hours).
   - Useful for converting structured time components to a single value.
   - Returns `"Invalid Unit"` if `unit` is not recognized.
   - Always lowercases the unit suffix in text mode.

   Examples:
     TIME_UNITS_TO_DECIMAL("H", 0, 1, 2, 30, 0) → 26.5  
     TIME_UNITS_TO_DECIMAL("H", 0, 1, 2, 30, 1) → "26.5h"
*/

TIME_UNITS_TO_DECIMAL = LAMBDA(unit, [y], [d], [h], [m], [s], [outputMode],
    LET(
        // Normalize optional inputs to 0
        y, N(y),
        d, N(d),
        h, N(h),
        m, N(m),
        s, N(s),
        outputMode, IF(ISOMITTED(outputMode), 0, outputMode),

        // Normalize and validate unit code
        code, UPPER(LEFT(unit, 1)),

        // Compute result based on unit type
        raw, SWITCH(
            code,
            "S", (y*31557600) + (d*86400) + (h*3600) + (m*60) + s,
            "M", (y*525960) + (d*1440) + (h*60) + m + (s/60),
            "H", (y*8766) + (d*24) + h + (m/60) + (s/3600),
            "D", (y*365.25) + d + (h/24) + (m/1440) + (s/86400),
            "Y", y + (d/365.25) + (h/8766) + (m/525960) + (s/31557600),
            "Invalid Unit"
        ),

        // Output as number or string
        result, IF(
            outputMode = 1,
            IF(ISNUMBER(raw), FIXED(raw, 9) & LOWER(code), raw),
            raw
        ),

        result
    )
);

/* TIME_DECIMAL_TO_UNITS
   Purpose:
   Converts a decimal duration (in years, days, hours, etc.) into a human-readable
   unit breakdown. Output can be verbose (e.g., "0y 0d 1h 59m 59.999s") or
   colon-delimited (e.g., "00:000:01:59:59.999").

   Parameters:
   - unit (required): Time unit of the input value — one of:
       "Y" = years
       "D" = days
       "H" = hours
       "M" = minutes
       "S" = seconds
   - value (required): The numeric duration to convert.
   - mode (optional):
       "TEXT" or 1  → verbose output (default)
       "FORMAT" or 0 → colon-delimited format
   - decimalPlaces (optional): Number of digits to show after the decimal in seconds (default: 3)

   Returns:
   A single text string representing the duration in split units.

   Notes:
   - Safely clamps seconds to avoid rounding up to 60s.
   - All units are internally converted to seconds using average year length (365.25 days).
   - If an invalid unit is supplied, returns "Invalid Input".
   - Verbose output uses suffixes: "y", "d", "h", "m", "s"
   - Colon format is always: "yy:ddd:hh:mm:ss.sss"

   Examples:
     TIME_DECIMAL_TO_UNITS("H", 1.999999997)
     → "0y 0d 1h 59m 59.999s"

     TIME_DECIMAL_TO_UNITS("H", 1.999999997, "FORMAT", 3)
     → "00:000:01:59:59.999"
*/


TIME_DECIMAL_TO_UNITS = LAMBDA(unit, value, [mode], [decimalPlaces],
    LET(
        // === Handle optional arguments ===
        decimalPlaces, IF(ISOMITTED(decimalPlaces), 3, decimalPlaces),

        // Allow both text or numeric mode
        modeText, IF(
            ISOMITTED(mode), "TEXT",
            IF(OR(mode = 0, mode = "FORMAT"), "FORMAT", "TEXT")
        ),

        // === Unit multiplier to seconds ===
        factor, SWITCH(unit,
            "Y", 31557600,   // 365.25 days
            "D", 86400,
            "H", 3600,
            "M", 60,
            "S", 1,
            NA()
        ),

        // === Total seconds from input ===
        totalSeconds, value * factor,

        // === Breakdown of time units ===
        y, INT(totalSeconds / 31557600),
        d, INT(MOD(totalSeconds, 31557600) / 86400),
        h, INT(MOD(totalSeconds, 86400) / 3600),
        m, INT(MOD(totalSeconds, 3600) / 60),
        s, MOD(totalSeconds, 60),

        // === Clamp seconds to prevent rounding to 60 ===
        s_clamped, IF(ROUND(s, decimalPlaces) >= 60, 60 - 10^(-decimalPlaces), ROUND(s, decimalPlaces)),

        // === Output: verbose mode
        formattedY, y & "y",
        formattedD, d & "d",
        formattedH, h & "h",
        formattedM, m & "m",
        formattedS, TEXT(s_clamped, "0." & REPT("0", decimalPlaces)) & "s",
        textMode, TEXTJOIN(" ", TRUE, formattedY, formattedD, formattedH, formattedM, formattedS),

        // === Output: colon-delimited
        colonS, TEXT(s_clamped, "00." & REPT("0", decimalPlaces)),
        formatMode, TEXT(y, "00") & ":" & TEXT(d, "000") & ":" & TEXT(h, "00") & ":" &
                     TEXT(m, "00") & ":" & colonS,

        // === Final output
        result, IF(modeText = "FORMAT", formatMode, textMode),

        IFERROR(result, "Invalid Input")
    )
);

/* TIME_DIFF:
   Purpose:
   Calculates the difference between two time values (start and end),
   returning the result in one of three formats.

   Returns:
   - A string (hh:mm:ss), a decimal hour value, or a labeled time string,
     depending on selected mode.

   Parameters:
   - start (required): Start time (Excel time or datetime format).
   - end (required): End time (Excel time or datetime format).
   - mode (optional):
       0 = "hh:mm:ss" formatted string (default)
       1 = decimal hours (rounded)
       2 = labeled components string (e.g., "2h 30m 0s")
   - roundPlaces (optional): Number of decimal places for mode = 1 (default = 9)

   Notes:
   - Automatically handles cases where the end time is after midnight.
   - Outputs "0" or "00:00:00" for equal times.
   - Ideal for logging, tracking durations, and comparative reports.

   Examples:
     TIME_DIFF(A1, B1) → "02:45:10"
     TIME_DIFF(A1, B1, 1, 2) → 2.75
     TIME_DIFF(A1, B1, 2) → "2h 45m 10s"
*/

TIME_DIFF = LAMBDA(start, end, [mode], [roundPlaces],
    LET(
        // === Optional parameter defaults ===
        mode, IF(ISOMITTED(mode), 0, mode),
        roundPlaces, IF(ISOMITTED(roundPlaces), 9, roundPlaces),

        // === Time value conversion to total seconds ===
        startSec, HOUR(start) * 3600 + MINUTE(start) * 60 + SECOND(start),
        endSec, HOUR(end) * 3600 + MINUTE(end) * 60 + SECOND(end),

        // === Calculate difference (mod 86400 to handle midnight wrap) ===
        diffSec, MOD(endSec - startSec, 86400),

        // === Decompose into components ===
        hh, INT(diffSec / 3600),
        mm, INT(MOD(diffSec, 3600) / 60),
        ss, MOD(diffSec, 60),

        // === Construct result per mode ===
        result, SWITCH(
            mode,
            1, TEXT(ROUND(diffSec / 3600, roundPlaces), "0." & REPT("0", roundPlaces)),             // Decimal hours
            2, hh & "h " & mm & "m " & ss & "s",                // Labeled output
            TEXT(hh, "00") & ":" & TEXT(mm, "00") & ":" & TEXT(ss, "00")  // "hh:mm:ss"
        ),

        result
    )
);

/* TIME_MIL12_TO_MIL24:
   Purpose:
   Converts a compact "military-style 12-hour" time string (e.g., "0830AM", "1245PM")
   into a standard military 24-hour format ("HHMM").

   Returns:
   A four-digit string representing the time in 24-hour military format.

   Parameters:
   - incoming (required): A 6-character string in the form "hhmmAM" or "hhmmPM"

   Notes:
   - Supports values from "0100AM" to "1200PM" with correct zero-padding.
   - Handles edge cases:
       "1200AM" → "0000"  
       "1200PM" → "1200"
   - Ideal for converting class schedules or shift logs from legacy military 12-hour systems.

   Example:
   TIME_MIL12_TO_MIL24("0830PM") → "2030"
   TIME_MIL12_TO_MIL24("1200AM") → "0000"
*/

TIME_MIL12_TO_MIL24 = LAMBDA(incoming,
    LET(
        // Extract suffix and time portion
        ampm, RIGHT(incoming, 2),
        hhmm, LEFT(incoming, 4),

        // Parse hour and minute components
        hour, VALUE(LEFT(hhmm, 2)),
        minute, RIGHT(hhmm, 2),

        // Adjust for 24-hour conversion rules
        hr, SWITCH(ampm,
            "AM", IF(hour = 12, "00", TEXT(hour, "00")),
            "PM", IF(hour = 12, "12", TEXT(hour + 12, "00"))
        ),

        // Combine hour and minute into final string
        output, TEXTJOIN("", , hr, minute),
        output
    )
);


/* TIME_MIL24_TO_MIL12:
   Purpose:
   Converts a 24-hour military time string (e.g., "1345", "0000") into a
   compact 12-hour military-style format with AM/PM suffix (e.g., "0145PM", "1200AM").

   Returns:
   A 6-character string in the form "hhmmAM" or "hhmmPM".

   Parameters:
   - incoming (required): A 4-digit string representing military time ("HHMM").

   Notes:
   - Midnight ("0000") is returned as "1200AM"
   - Noon ("1200") is returned as "1200PM"
   - Hours are always zero-padded to 2 digits.
   - Ideal for reversing time transformations for display or exports.

   Example:
   TIME_MIL24_TO_MIL12("1345") → "0145PM"
   TIME_MIL24_TO_MIL12("0000") → "1200AM"
*/

TIME_MIL24_TO_MIL12 = LAMBDA(incoming,
    LET(
        // Extract hour and minute components
        hour, VALUE(LEFT(incoming, 2)),
        minute, RIGHT(incoming, 2),
        
        // Determine AM/PM based on 24-hour time
        ampm, IF(hour < 12, "AM", "PM"),
        
        // Convert hour to 12-hour format
        hr, SWITCH(hour,
            0, "12",                                  // Midnight → 12 AM
            12, "12",                                 // Noon stays 12 PM
            IF(hour > 12, TEXT(hour - 12, "00"), TEXT(hour, "00"))
        ),

        // Concatenate output string: hhmmAM/PM
        output, TEXTJOIN("", , hr, minute, ampm),
        output
    )
);



/* TIME_MIL12_TO_CLOCK12:
   Purpose:
   Converts a compact military-style 12-hour time string (e.g., "0930AM", "1245PM")
   into a human-readable 12-hour clock format with colon (e.g., "9:30AM", "12:45PM").

   Returns:
   A time string in the format "h:mmAM" or "h:mmPM".

   Parameters:
   - incoming (required): A 6-character string in the format "hhmmAM" or "hhmmPM".

   Notes:
   - Input hour "12" is preserved for both midnight and noon.
   - Input hour "00" is converted to "12" to maintain valid 12-hour formatting.
   - This function is intended for display purposes, not serial time arithmetic.
   - Useful when parsing legacy scheduling systems or time exports into clean display formats.

   Example:
   TIME_MIL12_TO_CLOCK12("0930AM") → "9:30AM"
   TIME_MIL12_TO_CLOCK12("1245PM") → "12:45PM"
*/

TIME_MIL12_TO_CLOCK12 = LAMBDA(incoming,
    LET(
        // Extract AM/PM suffix and time portion
        ampm, RIGHT(incoming, 2),
        hhmm, LEFT(incoming, 4),

        // Extract numeric hour and minute
        hour, VALUE(LEFT(hhmm, 2)),
        minute, RIGHT(hhmm, 2),

        // Convert to clock-friendly 12-hour format
        hr, SWITCH(hour,
            12, "12",                                  // Noon & Midnight stay "12"
            0, "12",                                    // Handle edge case "00" as "12"
            IF(ampm = "PM", TEXT(hour, "0"), TEXT(hour, "0"))  // Drop leading zero
        ),

        // Format final time string
        output, TEXTJOIN(":", , hr, minute) & ampm,
        output
    )
);


/* TIME_CLOCK12_TO_MIL12:
   Purpose:
   Converts a standard 12-hour clock string (e.g., "9:30 AM", "12:45 PM") into a compact
   military-style 12-hour string with no delimiters (e.g., "0930AM", "1245PM").

   Returns:
   A 6-character string: "hhmmAM" or "hhmmPM"

   Parameters:
   - incoming (required): An Excel-readable 12-hour time string, e.g. "9:30 AM" or a serial time value.

   Notes:
   - Leading zeros are added to hours and minutes to ensure proper "hhmm" formatting.
   - Accepts either text-based time ("9:30 AM") or serial time values.
   - Ideal for converting user-friendly time formats into fixed-width military input for scheduling or export systems.

   Example:
   TIME_CLOCK12_TO_MIL12("9:30 AM") → "0930AM"
   TIME_CLOCK12_TO_MIL12("12:00 PM") → "1200PM"
*/

TIME_CLOCK12_TO_MIL12 = LAMBDA(incoming,
    LET(
        // Format as "hh:mm AM/PM" text regardless of input type
        toText, TEXT(incoming, "HH:MM AM/PM"),

        // Extract suffix
        ampm, UPPER(RIGHT(toText, 2)),

        // Extract hour and minute components with leading zeros
        hr, TEXT(TEXTBEFORE(toText, ":"), "00"),
        mn, TEXT(TEXTBEFORE(TEXTAFTER(toText, ":"), RIGHT(toText, 2)), "00"),

        // Concatenate to final format
        output, hr & mn & ampm,
        output
    )
);


/* TIME_MIL12_SHIFT:
   Purpose:
   Shifts a time in compact 12-hour military-style format (e.g., "0900AM")
   forward or backward by a specified number of hours (can be fractional).

   Returns:
   A new time string in "hhmmAM" or "hhmmPM" format, wrapping correctly over midnight if needed.

   Parameters:
   - incoming (required): A 12-hour time string in the format "hhmmAM" or "hhmmPM"
     (e.g., "0930AM", "1245PM").
   - adjustment (required): Number of hours to add (can be negative or fractional).

   Common Use Cases:
   - Calculate end time of a class or event by adding class duration to a start time.
     → e.g., TIME_MIL12_SHIFT("0930AM", 2.25) → "1145AM"
   - Determine when a class must start to finish by a certain time.
     → e.g., TIME_MIL12_SHIFT("1145AM", -2.25) → "0930AM"
   - Adjust static schedule blocks without converting to serial or formatted times.

   Notes:
   - Input time is parsed as Excel-readable, then converted internally to decimal time.
   - Result wraps over midnight correctly using `MOD(...)`.
   - Output preserves compact formatting used in some scheduling systems.

   Examples:
     TIME_MIL12_SHIFT("0900AM", 2.5)  → "1130AM"
     TIME_MIL12_SHIFT("1130PM", 2)    → "0130AM"
     TIME_MIL12_SHIFT("0100AM", -3)   → "1000PM"
*/

TIME_MIL12_SHIFT = LAMBDA(incoming, adjustment,
    LET(
        // === Extract components from incoming time ===
        ampm, RIGHT(incoming, 2),
        hhmm, LEFT(incoming, 4),
        hour, VALUE(LEFT(hhmm, 2)),
        minute, VALUE(RIGHT(hhmm, 2)) / 60,

        // === Convert to Excel serial time
        excelTime, TIME(hour + IF(AND(ampm = "PM", hour < 12), 12, 0), minute * 60, 0),

        // === Apply adjustment in hours and wrap around midnight
        newTime, MOD(excelTime + adjustment / 24, 1),

        // === Extract components of new time
        newHour, HOUR(newTime),
        newMin, MINUTE(newTime),
        suffix, IF(newHour >= 12, "PM", "AM"),

        // === Format to 12-hour compact style
        formattedHour, TEXT(MOD(newHour, 12), "00"),
        finalHour, IF(formattedHour = "00", "12", formattedHour),
        finalMin, TEXT(newMin, "00"),

        TEXTJOIN("", , finalHour, finalMin, suffix)
    )
);



/* TIME_STD12_SHIFT:
   Purpose:
   Shifts a standard 12-hour Excel time value (e.g., "9:30 AM") by a given number of hours.
   Optionally returns the result as a formatted text string or as a raw serial time.

   Returns:
   - A new time either as a numeric Excel serial (default), or as a formatted "hh:mm AM/PM" string if `formatted = TRUE`.

   Parameters:
   - startTime (required): An Excel 12-hour time value (e.g., TIME(9,30,0) or "9:30 AM").
   - adjustment (required): Number of hours to add (can be fractional or negative).
   - formatted (optional): 
       - TRUE → return result as "hh:mm AM/PM" text
       - FALSE or omitted → return raw Excel time value

   Notes:
   - Uses `MOD(..., 1)` to ensure wraparound over 24-hour boundaries.
   - Compatible with Excel’s native time system (fractional days).
   - Ideal for calculating adjusted times in scheduling tools or dashboards.

   Examples:
     TIME_STD12_SHIFT("9:30 AM", 2.5) → 0.52083 (Excel time for 12:00 PM)
     TIME_STD12_SHIFT("9:30 AM", 2.5, TRUE) → "12:00 PM"
     TIME_STD12_SHIFT("11:45 PM", 1.25, TRUE) → "01:00 AM"
*/

TIME_STD12_SHIFT = LAMBDA(startTime, adjustment, [formatted],
    LET(
        // === Apply hour-based adjustment and wrap around 24h clock ===
        newTime, MOD(startTime + (adjustment / 24), 1),

        // === Return based on output mode ===
        IF(
            ISOMITTED(formatted), 
            newTime,  // Default: Return Excel time serial
            TEXT(newTime, "hh:mm AM/PM")  // If TRUE, return formatted string
        )
    )
);
