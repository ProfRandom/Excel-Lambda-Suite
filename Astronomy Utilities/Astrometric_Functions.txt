ORBIT_HAB_INDEX = LAMBDA(d, n, [prec],

LET(
    prec, IF(ISOMITTED(prec), 3, prec),
    case, if(d<n, 0, 1),
    index, switch(case,
        0, ((2*d)/n)-1,
        1, (d/(-3.85*n))+(4.85/3.85)
        ),
    output, if(index<=0,
        "U/I",
        round(index,prec)
    ),
    output
)
);



ASTRO_SPECTRAL_DISTRIBUTION = LAMBDA([anchor_class], [anchor_count], [decimal_places],
    LET(
        // === Default handling and normalization ===
        anchor_class, IF(
            OR(ISOMITTED(anchor_class), ISERROR(SEARCH(anchor_class, "OBAFGKM"))),
            "$",  // Sentinel to indicate full baseline mode
            UPPER(anchor_class)
        ),

        anchor_count, IF(ISOMITTED(anchor_count), 1, anchor_count),
        decimal_places, IF(ISOMITTED(decimal_places), 3, decimal_places),





SPECTRAL_CLASS_FREQ = LAMBDA([type], [count], [precision],
    LET(
        precision, IF(ISOMITTED(precision), 3, precision),
        allclasses, "OBAFGKM",
        type, IF(OR(ISOMITTED(type), ISERROR(SEARCH(type, allclasses))), "$", UPPER(type)),
        count, IF(ISOMITTED(count), 1, count),
        classifications, {"O"; "B"; "A"; "F"; "G"; "K"; "M"},
        table, {3000000; 800; 160; 33; 13; 8; 1.31531603010874},
        freq, XLOOKUP(type, classifications, table),
        factors, BYROW(table, LAMBDA(x, freq / x)),
        values, IF(type <> "$", BYROW(factors, LAMBDA(x, count * x)), BYROW(table, LAMBDA(x, 1 / x))),
        CHOOSE({1, 2}, classifications, round(values, precision))
        /*type&" "&count*/
        
    )
);

SPECTRAL_DISTRIBUTION = LAMBDA(total, [precision],
    LET(
        precision, IF(ISOMITTED(precision), 3, precision),
        classifications, {"Total"; "O"; "B"; "A"; "F"; "G"; "K"; "M"},
        table, {3000000; 800; 160; 33; 13; 8; 1.31531603010874},
        factors, BYROW(table, LAMBDA(x,1/x)),
        values, byrow(factors,lambda(x,round(x*total,precision))),
        results, vstack(total, values),
        CHOOSE({1, 2}, classifications, results)
        /*type&" "&count*/
        
    )
);

/* STAR_SCALE_TEMP

Returns star attributes calculated from solar temp
*/
STAR_SCALE_TEMP = LAMBDA(temp, [precision],
    LET(
        precision, IF(ISOMITTED(precision), 6, precision),
        t_temp, "T-> " & ROUND(temp, precision),
        kelvin, "K: " & ROUND(temp * 5800, precision),
        radius, "R: " & ROUND(temp ^ 1.8, precision),
        luminosity, "L: " & ROUND(temp ^ 7.5778, precision),
        mass, "M: " & ROUND(temp ^ 2, precision),
        lifetime, "V: " & ROUND(temp ^ -5, precision),
        list, TEXTJOIN("|", , kelvin, t_temp, mass, radius, luminosity, lifetime),
        TOCOL(TEXTSPLIT(list, "|"))
    )
);

STAR_SCALE_KTEMP = LAMBDA(kelvin, [precision],
    LET(
        precision, IF(ISOMITTED(precision), 6, precision),
        k_temp, "K-> " & ROUND(kelvin, precision),
        temp, kelvin / 5800,
        solar, "T: " & ROUND(temp, precision),
        radius, "R: " & ROUND(temp ^ 1.8, precision),
        luminosity, "L: " & ROUND(temp ^ 7.5778, precision),
        mass, "M: " & ROUND(temp ^ 2, precision),
        lifetime, "V: " & ROUND(temp ^ -5, precision),
        list, TEXTJOIN("|", , k_temp, solar, mass, radius, luminosity, lifetime),
        TOCOL(TEXTSPLIT(list, "|"))
    )
);

STAR_CLASS_STATS = LAMBDA(in, [precision],
    LET(
        input, SUBSTITUTE(in, " ", ""),
        precision, IF(ISOMITTED(precision), 6, precision),
        class, LEFT(input, 1),
        sub, RIGHT(input, LEN(input) - 1),
        thresholds, {55000, 25000, 10000, 7500, 6000, 5000, 3500, 2400, 1300, 600},
        classifications, {"O", "B", "A", "F", "G", "K", "M", "L", "T", "Y"},
        q_vals, {3000, 1500, 250, 150, 100, 150, 110, 110, 70, 30},
        max_temp, XLOOKUP(class, classifications, thresholds),
        q_factor, XLOOKUP(class, classifications, q_vals),
        k_temp, max_temp - (sub * q_factor),
        temp, k_temp / 5800,
        kelvin, "K: " & ROUND(k_temp, precision),
        solar, "T: " & ROUND(temp, precision),
        radius, "R: " & ROUND(temp ^ 1.8, precision),
        luminosity, "L: " & ROUND(temp ^ 7.5778, precision),
        mass, "M: " & ROUND(temp ^ 2, precision),
        lifetime, "V: " & ROUND(temp ^ -5, precision),
        list, TEXTJOIN("|", , "-> " & input, kelvin, solar, mass, radius, luminosity, lifetime),
        TOCOL(TEXTSPLIT(list, "|"))
    )
);


STAR_MASS = LAMBDA(mass, [precision],
    LET(
        precision, IF(ISOMITTED(precision), 6, precision),
        s_mass, "M-> " & ROUND(mass, precision),
        temperature, "T: " & ROUND(SQRT(mass), precision),
        solar, SQRT(mass) * 5800,
        kelvin, "K: " & ROUND(solar, precision),
        radius, "R: " & ROUND(mass ^ 0.9, precision),
        luminosity, "L: " & ROUND(mass ^ 3.7889, precision),
        lifetime, "V: " & ROUND(SQRT(mass) ^ -5, precision),
        list, TEXTJOIN("|", , kelvin, temperature, s_mass, radius, luminosity, lifetime),
        TOCOL(TEXTSPLIT(list, "|"))
    )
);


STAR_RADS = LAMBDA(radius, [precision],
    LET(
        precision, IF(ISOMITTED(precision), 6, precision),
        solar, "R-> " & ROUND(radius, precision),
        temperature, "T: " & ROUND(radius ^ (1 / 1.8), precision),
        kelvin, "K: " & ROUND((radius ^ (1 / 1.8)) * 5800, precision),
        luminosity, "L: " & ROUND(radius ^ 4.22, precision),
        mass, "M: " & ROUND(radius ^ 1.114270017777780, precision),
        lifetime, "V: " & ROUND(radius ^ (1 / -0.36), precision),
        list, TEXTJOIN("|", , kelvin, temperature, mass, solar, luminosity, lifetime),
        TOCOL(TEXTSPLIT(list, "|"))
    )
);


STAR_LUMS = LAMBDA(luminosity, [precision],
    LET(
        precision, IF(ISOMITTED(precision), 6, precision),
        temperature, "T: " & ROUND(luminosity ^ (1 / 7.6), precision),
        kelvin, "K: " & ROUND((luminosity ^ (1 / 7.5778)) * 5800, precision),
        s_lum, "L-> " & ROUND(luminosity, precision),
        radius, "R: " & ROUND(luminosity ^ (1 / 4.22), precision),
        mass, "M: " & ROUND(luminosity ^ (1 / 3.7889), precision),
        lifetime, "V: " & ROUND(luminosity ^ (1 / -1.52), precision),
        list, TEXTJOIN("|", , kelvin, temperature, mass, radius, s_lum, lifetime),
        TOCOL(TEXTSPLIT(list, "|"))
    )
);

STARLUMS = LAMBDA(luminosity, [precision],
    LET(
        precision, IF(ISOMITTED(precision), 6, precision),
        labels, TRANSPOSE({"K:", "T:", "M:", "R:", "L}", "V:"}),
        T, ROUND(luminosity ^ (1 / 7.5778), precision),
        K, ROUND((luminosity ^ (1 / 7.5778)) * 5800, precision),
        L, ROUND(luminosity, precision),
        R, ROUND(luminosity ^ (1 / 4.22), precision),
        M, ROUND(luminosity ^ (1 / 3.7889), precision),
        V, ROUND(luminosity ^ (1 / -1.52), precision),
        attribs, TEXTJOIN(",", , K, T, M, R, L, V),
        values, TRANSPOSE(TEXTSPLIT(attribs, ",")),
        CHOOSE({1, 2}, labels, values)
    )
);


STAR_LIFE = LAMBDA(lifetime, [precision],
    LET(
        precision, IF(ISOMITTED(precision), 6, precision),
        solar, "V-> " & ROUND(lifetime, precision),
        temperature, "T: " & ROUND(lifetime ^ (1 / -5), precision),
        kelvin, "K: " & ROUND((lifetime ^ (1 / -5)) * 5800, precision),
        radius, "R: " & ROUND(lifetime ^ (-0.36), precision),
        mass, "M: " & ROUND(lifetime ^ (1 / -2.5), precision),
        luminosity, "L: " & ROUND(lifetime ^ -1.52, precision),
        list, TEXTJOIN("|", , kelvin, temperature, mass, radius, luminosity, solar),
        TOCOL(TEXTSPLIT(list, "|"))
    )
);


TYPE_FROM_TEMP = LAMBDA(temp, [mode], [prec],
    LET(
        temp, ifs(temp<600,600,
                temp>55000,55000,
                TRUE, temp),
        mode, IF(OR(ISOMITTED(mode), mode > 1), 0, mode),
        prec, IF(OR(ISOMITTED(prec), prec < 0), 3, prec),
        thresholds, {55000, 25000, 10000, 7500, 6000, 5000, 3500, 2400, 1300, 600, 300},
        classifications, {"O", "B", "A", "F", "G", "K", "M", "L", "T", "Y"},
        q_vals, {3000, 1500, 250, 150, 100, 150, 110, 110, 70, 30},
        index, MATCH(TRUE, temp > thresholds, 0) - 1,
        s_type, INDEX(classifications, index),
        k_max, INDEX(thresholds, index),
        q_val, INDEX(q_vals, index),
        class_num, (k_max - temp) / q_val,
        s_class, IF(class_num = 10, 9.999, class_num),
        output, SWITCH(mode,
            0, s_type & " " & FIXED(s_class, prec),
            1, temp & " = " & s_type & FIXED(s_class, prec), ),
        output
    )
);

TEMP_FROM_TYPE = LAMBDA(in, [mode],
    LET(
        mode, IF(OR(ISOMITTED(mode), mode > 1), 0, mode),
        input, SUBSTITUTE(in, " ", ""),
        class, LEFT(input, 1),
        sub, RIGHT(input, LEN(input) - 1),
        thresholds, {55000, 25000, 10000, 7500, 6000, 5000, 3500, 2400, 1300, 600},
        classifications, {"O", "B", "A", "F", "G", "K", "M", "L", "T", "Y"},
        q_vals, {3000, 1500, 250, 150, 100, 150, 110, 110, 70, 30},
        max_temp, XLOOKUP(class, classifications, thresholds),
        q_factor, XLOOKUP(class, classifications, q_vals),
        k_temp, max_temp - (sub * q_factor),
        SWITCH(mode, 0, k_temp, 1, input & " = " & k_temp)
    )
);

SPECTRAL_CLASS_DATA = LAMBDA([null],
    LET(
        headers, {"Type"; "Min"; "Max"; "Span"; "q"},
        types, VSTACK(INDEX(headers, 1), {"O"; "B"; "A"; "F"; "G"; "K"; "M"; "L"; "T"; "Y"}),
        min, VSTACK(INDEX(headers, 2), {25000; 10000; 7500; 6000; 5000; 3500; 2400; 1300; 600; 300}),
        max, VSTACK(INDEX(headers, 3), {55000; 25000; 10000; 7500; 6000; 5000; 3500; 2400; 1300; 600}),
        q_vals, VSTACK(INDEX(headers, 5), {3000; 1500; 250; 150; 100; 150; 110; 110; 70; 30}),
        ranges, {30000; 15000; 2500; 1500; 1000; 1500; 1100; 1100; 700; 300},
        span, VSTACK(INDEX(headers, 4), ranges),
        CHOOSE({1, 2, 3, 4, 5}, types, min, max, span, q_vals)
    )
);

SPEC_LIST = LAMBDA([null],
    LET(
        classifications, {
            "O: 25000 - 55000";
            "B: 10000 - 25000";
            "A: 7500 - 10000";
            "F: 6000 - 7500";
            "G: 5000 - 6000";
            "K: 3500 - 5000";
            "M: 2400 - 3500";
            "L: 1300 - 2400";
            "T: 600 - 1300";
            "Y: 300 - 600"
        },
        classifications
    )
);

HABITABLE_ZONES_TABLE = LAMBDA([null],
    LET(
        dec, 3,
        headers, {"Zone"; "Inner"; "Outer"; "Average"; "Span"},
        labels, {"Z0 (Ignio-)"; "Z1 (Caloro-)"; "Z2 (Helio-)"; "Z3 (Solara-)"; "Z4 (Surya-)"; "Z5 (Frio-)"},
        inner, {0; 0.5; 0.75; 0.95; 1.385; 1.77},
        outer, {0.5; 0.75; 0.95; 1.385; 1.77; 4.85},
        average, {0.25; 0.625; 0.85; 1.1675; 1.5775; 3.31},
        span, {0.5; 0.25; 0.2; 0.435; 0.385; 3.08},
        col_1, VSTACK(INDEX(headers, 1), labels),
        col_2, VSTACK(INDEX(headers, 2), ROUND(inner, dec)),
        col_3, VSTACK(INDEX(headers, 3), ROUND(outer, dec)),
        col_4, VSTACK(INDEX(headers, 4), ROUND(average, dec)),
        col_5, VSTACK(INDEX(headers, 5), ROUND(span, dec)),
        CHOOSE({1, 2, 3, 4, 5}, col_1, col_2, col_3, col_4, col_5)
    )
);

HABZONES = LAMBDA(lum, [precision],
    LET(
        precision, IF(ISOMITTED(precision), 3, precision),
        nucleal, ROUND(SQRT(lum), precision),
        N, "N-> " & ROUND(SQRT(lum), precision),
        Zone0, "0: " & ROUND(0.5 * nucleal, precision),
        Zone1, "1: " & ROUND(0.75 * nucleal, precision),
        Zone2, "2: " & ROUND(0.95 * nucleal, precision),
        Zone3, "3: " & ROUND(1.385 * nucleal, precision),
        Zone4, "4: " & ROUND(1.77 * nucleal, precision),
        Zone5, "5: " & ROUND(4.85 * nucleal, precision),
        list, TEXTJOIN("|", , Zone0, Zone1, Zone2, N, Zone3, Zone4, Zone5),
        TOCOL(TEXTSPLIT(list, "|"))
    )
);

HAB_ZONES = LAMBDA(lum, [precision],
    LET(
        labels, {"0: ", "1: ", "2: ", "N-> ", "3: ", "4: ", "5: "},
        precision, IF(ISOMITTED(precision), 3, precision),
        nucleal, ROUND(SQRT(lum), precision),
        Z_0, ROUND(0.5 * nucleal, precision),
        Z_1, ROUND(0.75 * nucleal, precision),
        Z_2, ROUND(0.95 * nucleal, precision),
        Z_N, nucleal,
        Z_3, ROUND(1.385 * nucleal, precision),
        Z_4, ROUND(1.77 * nucleal, precision),
        Z_5, ROUND(4.85 * nucleal, precision),
        Zone0, VSTACK(INDEX(labels, 1), Z_0),
        Zone1, VSTACK(INDEX(labels, 2), Z_1),
        Zone2, VSTACK(INDEX(labels, 3), Z_2),
        ZoneN, VSTACK(INDEX(labels, 4), Z_N),
        Zone3, VSTACK(INDEX(labels, 5), Z_3),
        Zone4, VSTACK(INDEX(labels, 6), Z_4),
        Zone5, VSTACK(INDEX(labels, 7), Z_5),
        TRANSPOSE(CHOOSE({1, 2, 3, 4, 5, 6, 7}, Zone0, Zone1, Zone2, ZoneN, Zone3, Zone4, Zone5))
    )
);

STARS_PER_CUBIC_VOL = LAMBDA(input, [prec], [mode],

LET(
    mode, if(
        (isomitted(mode))+
        (mode<0)+
        (mode>1),
        0,
        mode),
    prec, if(
        (isomitted(prec))+
        (prec<0),
        3,
        prec),
    volume, switch(mode,
        0, input,
        1, (4/3)*pi()*input^3
        ),
    radius, switch(mode,
        0, round(power((volume*3)/(4*pi()),1/3), prec),
        1, input
        ),
    stars, round(volume/250, prec),
    output, switch(mode,
        0, tocol(textsplit(textjoin("; ",, stars, radius),"; ")),
        1, tocol(textsplit(textjoin("; ",, round(stars,0), round(volume,0)),"; "))
        ),
    output
    )
);


CUBIC_VOLUME_PER_STARS = LAMBDA(stars, [prec], [mode],

LET(
    mode, if(
        (isomitted(mode))+
        (mode<0)+
        (mode>2),
        0,
        mode),
    prec, if(
        (isomitted(prec))+
        (prec<0),
        3,
        prec),
    volume, round(stars*250, prec),
    side, round(power(volume,1/3), prec),
    radius, round(power((volume*3)/(4*pi()),1/3), prec),
    output, switch(mode,
        0, volume,
        1, tocol(textsplit(textjoin("; ",, volume, side),"; ")),
        2, tocol(textsplit(textjoin("; ",, volume, side, radius),"; "))
        ),
    output
    )
);

PLANET_ASTROMETRICS = LAMBDA(first, second, [mode], [prec],

/* MODES

    0: m, d
    1: m, r
    2: m, g
    3: r, d
    4: r, g
    5: d, g
    6: d, v
    7: g, v
    8: m, v
    9: r, v

*/
LET(
    prec, if(
        (isomitted(prec))+
        (prec<0),
        5,
        prec
        ),
    mode, if(
        (isomitted(mode)+
        (mode<0)+
        (mode>9)),
        0,
        mode
        ), 
    labels, switch(mode, 
        0, "M>;R:;d>;g:;v:",
        1, "M>;R>;d:;g:;v:",
        2, "M>;R:;d:;g>;v:",
        3, "M:;R>;d>;g:;v:",
        4, "M:;R>;d:;g>;v:",
        5, "M:;R:;d>;g>;v:",
        6, "M:;R:;d>;g:;v>",
        7, "M:;R:;d:;g>;v>",
        8, "M>;R:;d:;g:;v>",
        9, "M:;R>;d:;g:;v>"
        ),
    output, switch(mode,
        0, LET(
            mass, first,
            density, second,
            radius, power(mass/density,3^-1),
            gravity, power(mass*density^2,3^-1),
            escape, power(mass*sqrt(density),3^-1),
            textjoin(";",,mass, radius, density, gravity, escape)
            ),
        1, LET(
            mass, first,
            radius, second,
            density, mass/radius^3,
            gravity, mass/radius^2,
            escape, sqrt(mass/radius),
            textjoin(";",,mass, radius, density, gravity, escape)
            ),
        2, LET(
            mass, first,
            gravity, second,
            radius, sqrt(mass/gravity),
            density, sqrt(gravity^3/mass),
            escape, power(mass*gravity,4^-1),
            textjoin(";",,mass, radius, density, gravity, escape)
            ),
        3, LET(
            radius, first,
            density, second,
            gravity, radius*density,
            mass, density*radius^3,
            escape, radius*sqrt(density),
            textjoin(";",,mass, radius, density, gravity, escape)
            ),
        4, LET(
            radius, first,
            gravity, second,
            density, gravity/radius,
            mass, gravity*radius^2,
            escape, sqrt(gravity*radius),
            textjoin(";",,mass, radius, density, gravity, escape)
            ),
        5, LET(
            density, first,
            gravity, second,
            radius, gravity/density,
            mass, gravity^3/density^2,
            escape, gravity/sqrt(density),
            textjoin(";",,mass, radius, density, gravity, escape)
            ),
        6, LET(
            density, first,
            escape, second,
            mass, escape^3/sqrt(density),
            radius, escape/sqrt(density),
            gravity, escape*sqrt(density),
            textjoin(";",,mass, radius, density, gravity, escape)
            ),
        7, LET(
            gravity, first,
            escape, second,
            mass, escape^4/gravity,
            radius, escape^2/gravity,
            density, (gravity/escape)^2,
            textjoin(";",,mass, radius, density, gravity, escape)
            ),
        8, LET(
            mass, first,
            escape, second,
            gravity, escape^4/mass,
            radius, mass/escape^2,
            density, escape^6/mass^2,
            textjoin(";",,mass, radius, density, gravity, escape)
            ),
        9, LET(
            radius, first,
            escape, second,
            gravity, escape^2/radius,
            mass, radius*escape^2,
            density, (escape/radius)^2,
            textjoin(";",,mass, radius, density, gravity, escape)
            ),                                                                            
        ),
    label_list, transpose(textsplit(labels,";")),
    value_list, transpose(textsplit(output, ";")),
    //value_list
    choose({1,2}, label_list, round(value(value_list),prec))
    )
);


SYNODIC = LAMBDA(p, q,

    (p * q) / ABS(p - q)
    
);

SMALLANGLE = LAMBDA(diameter, distance,

    0.532904294 * (diameter / distance)
    
);

ORB_AXIS = LAMBDA(mass1, mass2, period,

LET(
    mass2, IF((ISOMITTED(mass2))+(mass2 = 1), 0, mass2*3.003E-6),
    axis, POWER((POWER(period, 2) * (mass1 + mass2)), 1 / 3),
    axis
    )
);

ORB_PERIOD = LAMBDA(mass1, mass2, axis,

LET(
    mass2, IF((ISOMITTED(mass2))+(mass2 = 1), 0, (mass2 * 3.00273e-6)),
    period, SQRT(POWER(axis, 3) / (mass1 + mass2)),
    period
    )
);

CROSSING_ORBIT_PARAMETER = LAMBDA(mass1, mass2,

ABS(mass1 - mass2)/ABS(mass1 +mass2)

);



PERIOD_AXIS = LAMBDA(input,

    POWER(POWER(input, 2), (1 / 3))

);

ORB_SUM_MASSES = LAMBDA(axis, period,

POWER(axis, 3) / POWER(period, 2)
);

SPHERICAL_TO_CARTESIAN = LAMBDA(phi, theta, r, [prec],

LET(
   prec, if(
        (isomitted(prec))+
        (prec<0),
        3,
        prec),    
    z_mod, sign(theta),
    y_mod, sign(phi),
    x_mod, if(abs(phi)<90, 1, -1),
    //x_mod
    //textjoin(",",,x_mod, y_mod, z_mod)
    ang_x, radians(mod(phi,90)),
    ang_z, radians(abs(theta)),
    d, cos(ang_z)*r,
    x, round(cos(ang_x)*d*x_mod, prec),
    y, round(sin(ang_x)*d*y_mod, prec),
    z, round(sin(ang_z)*r*z_mod, prec),
    result, textjoin("|",,x, y, z),
    //result
    torow(textsplit(result,"|"))
)

);

DEG_DEC_DMS = LAMBDA(DecimalDegrees,
    LET(
        Deg, TRUNC(DecimalDegrees),
        FracPortion, ABS(DecimalDegrees - Deg),
        Minutes, FracPortion * 60,
        Min_part, TRUNC(Minutes) / 100,
        IntMin, INT(Minutes),
        FracMin, ABS(Minutes - IntMin),
        Seconds, FracMin * 60,
        sec_part, Seconds / 10000,
        output, Deg + Min_part + sec_part,
        FIXED(output, 7)
    )
);

DEG_DMS = LAMBDA(DecimalDegrees, [precision],

LET(
    decprec, IF(ISOMITTED(Precision), 3, Precision),
    Deg, TRUNC(DecimalDegrees),
    FracPortion, ABS(DecimalDegrees - Deg),
    Minutes, FracPortion * 60,
    IntMin, INT(Minutes),
    FracMin, ABS(Minutes - IntMin),
    Seconds, FracMin * 60,
    Deg & "° " & IntMin & CHAR(39) & CHAR(32) & FIXED(Seconds, decprec) & CHAR(34)
)
);

DEG_DMS_DEC = LAMBDA(input,
    LET(
        degrees, TRUNC(input),
        minutes, TRUNC((input - degrees) * 100),
        fractional_seconds, ((input * 100) - TRUNC(input * 100)) / 0.6,
        /*  */
        result, degrees + ((minutes + fractional_seconds) / 60),
        result
    )
);

AXIS_PERIOD = LAMBDA(input,

    SQRT(POWER(input, 3))
    
);

