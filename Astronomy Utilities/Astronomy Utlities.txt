/* ASTRO_HAB_INDEX:
   Purpose: Calculates a normalized habitability index based on a planet's orbital distance
            relative to a star's nucleal (habitable zone anchor) radius.
   Returns: A scalar habitability index (number), or "U/I" if uninhabitable

   Parameters:
   - orbital_dist (required): Orbital distance (in AU)
   - nucleal_radius (optional): Nucleal zone radius (in AU); defaults to 1.0
   - prec (optional): Number of decimal places to round the output (default = 3)

   Notes:
   - Index ≈ 1.0 indicates ideal alignment with habitable zone.
   - Values < 1 are inside the optimal band (potentially too hot).
   - Values > 1 are outside the optimal band (potentially too cold).
   - If the orbit is too deep inside the inner boundary, returns "U/I".
   - Uses a piecewise function for smooth falloff across boundary.

   Example:
   ASTRO_HAB_INDEX(1.0)              → 1.000  (assumes nucleal_radius = 1)
   ASTRO_HAB_INDEX(0.75, 1.0)        → 0.500
   ASTRO_HAB_INDEX(2.5, 1.0)         → 1.628
   ASTRO_HAB_INDEX(0.25, 1.0)        → "U/I"
*/

ASTRO_HAB_INDEX = LAMBDA(orbital_dist, [nucleal_radius], [prec],
    LET(
        rounding_precision, IF(ISOMITTED(prec), 3, prec),             /* Default to 3 decimals */
        nucleal_radius, IF(ISOMITTED(nucleal_radius), 1, nucleal_radius), /* Default to 1 AU if omitted */

        is_inner_orbit, IF(orbital_dist < nucleal_radius, TRUE, FALSE),  /* Determine position */

        habitability_index,                                           /* Piecewise function */
            IF(
                is_inner_orbit,
                (2 * orbital_dist / nucleal_radius) - 1,              /* Inside HZ model */
                (orbital_dist / (-3.85 * nucleal_radius)) + (4.85 / 3.85)  /* Outside HZ model */
            ),

        final_result,                                                 /* Handle invalid/valid cases */
            IF(habitability_index <= 0, "U/I", ROUND(habitability_index, rounding_precision)),

        final_result
    )
);

/* ASTRO_SPECTRAL_DISTRIBUTION
   ------------------------------------------
   Distributes a total stellar population across the seven primary spectral classes
   (O, B, A, F, G, K, M) based on inverse population factors. Returns a two-column
   array of class labels and calculated star counts.

   Syntax:
     ASTRO_SPECTRAL_DISTRIBUTION(total, [precision])

   Parameters:
     total      : Total number of stars to be distributed.
     precision  : Optional (default = 3). Number of decimal places to round each count.

   Returns:
     A vertical array with two columns:
       - Column 1: Spectral class labels (Total, O, B, A, F, G, K, M)
       - Column 2: Number of stars in each class (rounded to the specified precision)

   Examples:
     ASTRO_SPECTRAL_DISTRIBUTION(1000)
       → {"Total", "O", "B", "A", "F", "G", "K", "M"} paired with {1000, 0.333, 1.25, ...}

     ASTRO_SPECTRAL_DISTRIBUTION(5000, 0)
       → {"Total", "O", "B", "A", "F", "G", "K", "M"} paired with rounded integers

   Notes:
     - The distribution is based on inverse weighting factors:
         O: 1/3000000
         B: 1/800
         A: 1/160
         F: 1/33
         G: 1/13
         K: 1/8
         M: 1/1.3153...
     - These values approximate relative frequency and abundance of star types.
     - "Total" is included as the first row of the output for easy summation/audit.
     - Intended for use in modeling star system populations, galaxy seeding, or teaching the distribution of stellar types.
*/


ASTRO_SPECTRAL_DISTRIBUTION = LAMBDA([anchor_class], [anchor_count], [decimal_places],
    LET(
        // === Default parameters ===
        anchor_class, IF(ISOMITTED(anchor_class), "$", UPPER(anchor_class)),
        anchor_count, IF(ISOMITTED(anchor_count), 1, anchor_count),
        decimal_places, IF(ISOMITTED(decimal_places), 3, decimal_places),

        // === Spectral class array and base frequencies (empirical) ===
        arr_classes, {"O"; "B"; "A"; "F"; "G"; "K"; "M"},
        arr_base_pct, {0.00003; 0.13; 0.6; 3.0; 7.6; 12.1; 76.27},
        arr_base_frac, BYROW(arr_base_pct, LAMBDA(x, x / 100)),

        // === Lookup scaling factor for a specific anchor type
        anchor_freq, XLOOKUP(anchor_class, arr_classes, arr_base_frac, 1),
        scaling_factor, anchor_count / anchor_freq,

        // === Scaled distribution — normalize or apply user-defined scale
        scaled, IF(anchor_class = "$", arr_base_frac, BYROW(arr_base_frac, LAMBDA(x, x * scaling_factor))),

        // === Final output
        output, HSTACK(arr_classes, ROUND(scaled, decimal_places)),
        output
    )
);


/* ASTRO_CALC_TEMP:
   Purpose: Returns the interpolated effective temperature (in Kelvin) for a given stellar subclass
            (e.g. "G7.3"), using hardcoded high-temperature anchors and span values between subclasses.

   Returns: A numeric temperature in Kelvin, interpolated using linear scaling within the specified subclass.

   Parameters:
   - subclass (required): A string representing a spectral subclass. Accepts formats like "F5", "K2.6", "M8.9", etc.

   Notes:
   - Temperature data is based on empirical subclass anchors for types O3 through M9.
   - The function supports fractional subclass input and assumes linear falloff between subclass temperature anchors.
   - The high temperature (`T_high`) is retrieved for the base subclass (e.g., "G7"), and interpolation uses:
       T = T_high - (fraction * span)
   - Handles inputs with or without a decimal point (e.g., "F6" = "F6.0").
   - Internally uses XLOOKUP over a matrix built from hardcoded subclass labels, temperatures, and spans.

   Example:
   ASTRO_CALC_TEMP("G7.3")   → 5529
   ASTRO_CALC_TEMP("O4.4")   → 42300
   ASTRO_CALC_TEMP("F8.45")  → 6121.5
   ASTRO_CALC_TEMP("M8.6")   → 2456
*/


ASTRO_CALC_TEMP = LAMBDA(subclass,
  LET(
    // --- Hardcoded spectral subclass arrays ---

    arrTypes, {
      "O3"; "O4"; "O5"; "O6"; "O7"; "O8"; "O9";
      "B0"; "B1"; "B2"; "B3"; "B4"; "B5"; "B6"; "B7"; "B8"; "B9";
      "A0"; "A1"; "A2"; "A3"; "A4"; "A5"; "A6"; "A7"; "A8"; "A9";
      "F0"; "F1"; "F2"; "F3"; "F4"; "F5"; "F6"; "F7"; "F8"; "F9";
      "G0"; "G1"; "G2"; "G3"; "G4"; "G5"; "G6"; "G7"; "G8"; "G9";
      "K0"; "K1"; "K2"; "K3"; "K4"; "K5"; "K6"; "K7"; "K8"; "K9";
      "M0"; "M1"; "M2"; "M3"; "M4"; "M5"; "M6"; "M7"; "M8"; "M9"
    },

    // High effective temperatures (K) for each subclass
    arrTHigh, {
      44900; 42900; 41400; 39500; 37100; 35100; 33300;
      31400; 26000; 20600; 17000; 16400; 15700; 14500; 14000; 12300; 10700;
      9700; 9300; 8800; 8600; 8250; 8100; 7910; 7760; 7590; 7400;
      7220; 7020; 6820; 6750; 6670; 6550; 6350; 6280; 6180;
      6050; 5930; 5860; 5770; 5720; 5680; 5660; 5600; 5550; 5480;
      5380; 5270; 5170; 5100; 4830; 4600; 4440; 4300; 4100; 3990;
      3930; 3850; 3660; 3560; 3430; 3210; 3060; 2810; 2680; 2570; 2380
    },

    // Temperature span to the next subclass (K)
    arrSpan, {
      2000; 1500; 1900; 2400; 2000; 1800; 1900;
      5400; 5400; 3600; 600; 700; 1200; 500; 1700; 1600; 1000;
      400; 500; 200; 350; 150; 190; 150; 170; 190; 180;
      200; 200; 70; 80; 120; 200; 70; 100; 130;
      120; 70; 90; 50; 40; 20; 60; 50; 70; 100;
      110; 100; 70; 270; 230; 160; 140; 200; 110; 60;
      80; 190; 100; 130; 220; 150; 250; 130; 110; 190; 280
    },

    // Bundle into a single matrix for clean lookup
    mtxStars, HSTACK(arrTypes, arrTHigh, arrSpan),

    // --- Input normalization and parsing ---

    no_space, SUBSTITUTE(subclass, " ", ""),                  // Trim whitespace
    dot_pos, FIND(".", no_space & ".0"),                      // Ensure fractional part is detected even for whole subclasses
    base, LEFT(no_space, dot_pos - 1),                        // Extract root subclass, e.g., "G7" from "G7.3"
    f, VALUE("0." & MID(no_space, dot_pos + 1, LEN(no_space))), // Convert decimal string to numeric (e.g., 0.3)

    // --- Lookup high temp and span from matrix ---

    T_high, XLOOKUP(base, INDEX(mtxStars,,1), INDEX(mtxStars,,2)), // e.g. 5550 for "G7"
    span,   XLOOKUP(base, INDEX(mtxStars,,1), INDEX(mtxStars,,3)), // e.g. 70 for "G7"

    // --- Interpolation: T = T_high - f * span ---

    result, T_high - (f * span),

    result
  )
);

/* ASTRO_TYPE_FROM_TEMP:
   Purpose: Returns the interpolated stellar spectral subclass (e.g. "G7.3") for a given effective temperature in Kelvin.

   Returns: A string representing the estimated spectral subclass, optionally with decimal precision.

   Parameters:
   - temp (required): A numeric temperature in Kelvin.
   - decimals (optional): Number of decimal places to include in the subclass (default = 3).

   Notes:
   - The function matches the temperature to the correct spectral subclass range by checking which high-temp band it falls within.
   - It then linearly interpolates the decimal portion of the subclass using:
       fractional = (T_high - temp) / span
   - Uses hardcoded temperature anchors and spans across spectral types O3–M9.
   - Supports high precision and normalization for fractional subclasses like "K4.376".

   Example:
   ASTRO_TYPE_FROM_TEMP(42300)   → "O4.400"
   ASTRO_TYPE_FROM_TEMP(5529)    → "G7.300"
   ASTRO_TYPE_FROM_TEMP(6121.5)  → "F8.450"
   ASTRO_TYPE_FROM_TEMP(2456, 1) → "M8.6"

   Dependencies:
   - Uses XMATCH + MAP for logical range detection.
   - Assumes temperature decreases monotonically across subclass sequence.
*/


ASTRO_TYPE_FROM_TEMP = LAMBDA(temp, [decimals],
  LET(
    // --- Hardcoded spectral subclass data ---
    arrTypes, {
      "O3"; "O4"; "O5"; "O6"; "O7"; "O8"; "O9";
      "B0"; "B1"; "B2"; "B3"; "B4"; "B5"; "B6"; "B7"; "B8"; "B9";
      "A0"; "A1"; "A2"; "A3"; "A4"; "A5"; "A6"; "A7"; "A8"; "A9";
      "F0"; "F1"; "F2"; "F3"; "F4"; "F5"; "F6"; "F7"; "F8"; "F9";
      "G0"; "G1"; "G2"; "G3"; "G4"; "G5"; "G6"; "G7"; "G8"; "G9";
      "K0"; "K1"; "K2"; "K3"; "K4"; "K5"; "K6"; "K7"; "K8"; "K9";
      "M0"; "M1"; "M2"; "M3"; "M4"; "M5"; "M6"; "M7"; "M8"; "M9"
    },

    arrTHigh, {
      44900; 42900; 41400; 39500; 37100; 35100; 33300;
      31400; 26000; 20600; 17000; 16400; 15700; 14500; 14000; 12300; 10700;
      9700; 9300; 8800; 8600; 8250; 8100; 7910; 7760; 7590; 7400;
      7220; 7020; 6820; 6750; 6670; 6550; 6350; 6280; 6180;
      6050; 5930; 5860; 5770; 5720; 5680; 5660; 5600; 5550; 5480;
      5380; 5270; 5170; 5100; 4830; 4600; 4440; 4300; 4100; 3990;
      3930; 3850; 3660; 3560; 3430; 3210; 3060; 2810; 2680; 2570; 2380
    },

    arrSpan, {
      2000; 1500; 1900; 2400; 2000; 1800; 1900;
      5400; 5400; 3600; 600; 700; 1200; 500; 1700; 1600; 1000;
      400; 500; 200; 350; 150; 190; 150; 170; 190; 180;
      200; 200; 70; 80; 120; 200; 70; 100; 130;
      120; 70; 90; 50; 40; 20; 60; 50; 70; 100;
      110; 100; 70; 270; 230; 160; 140; 200; 110; 60;
      80; 190; 100; 130; 220; 150; 250; 130; 110; 190; 280
    },

    // --- Determine match index ---
    temp_in_range,
      MAP(SEQUENCE(ROWS(arrTHigh)),
        LAMBDA(i,
          AND(
            INDEX(arrTHigh, i) >= temp,
            temp > INDEX(arrTHigh, i) - INDEX(arrSpan, i)
          )
        )
      ),
    idx, XMATCH(TRUE, temp_in_range),

    // --- Lookup type and compute fraction ---
    full_type, INDEX(arrTypes, idx),
    T_high, INDEX(arrTHigh, idx),
    span, INDEX(arrSpan, idx),
    f, (T_high - temp) / span,

    // --- Format fractional part ---
    dec, IF(ISOMITTED(decimals), 3, decimals),
    format_string, "." & REPT("0", dec),
    subclass, full_type & TEXT(f, format_string),

    subclass
  )
);


/* ASTRO_DISPLAY_SPECTRAL:
   Purpose: Displays spectral subclass temperature and span data across stellar classifications.
            Can return either the full spectral matrix (O3–M9) or a filtered two-column view.

   Returns: 
   - If type is omitted: Wide matrix of spectral classes (O to M), 10 subclasses each
   - If type is provided: Two-column table with Temperature and Span for the requested class

   Parameters:
   - type (optional): One of {"O","B","A","F","G","K","M"} to limit output to that spectral group

   Notes:
   - Temperatures are high-end values for each subclass (real-world inspired, smoothed data).
   - Span is the Kelvin difference between a subclass and the next cooler one.
   - If no type is specified, output is organized as a visual reference table.
   - Uses VSTACK and HSTACK internally for clean structure; replaces previous separated versions.
   - This function supersedes: ASTRO_DISPLAY_BASE_DATA, _SEPARATED, and _BY_TYPE.

   Example:
   ASTRO_DISPLAY_SPECTRAL()        → Returns full O3–M9 subclass chart
   ASTRO_DISPLAY_SPECTRAL("G")     → Returns temperature and span for G0–G9
   ASTRO_DISPLAY_SPECTRAL("F")     → F0–F9 classification metrics
*/

ASTRO_DISPLAY_SPECTRAL = LAMBDA([type],
  LET(
    // --- Define spectral types and build helpers ---
    Types, {"O";"B";"A";"F";"G";"K";"M"},
    Headers, TRANSPOSE(VSTACK(" ", Types)),
    FindCol, MAKEARRAY(COUNTA(Types), 2, LAMBDA(r, c, IF(c = 1, INDEX(Types, r), r))),

    // --- Raw star subclass data ---
    arrTypes, {
      "O"; "O"; "O"; "O3"; "O4"; "O5"; "O6"; "O7"; "O8"; "O9";
      "B0"; "B1"; "B2"; "B3"; "B4"; "B5"; "B6"; "B7"; "B8"; "B9";
      "A0"; "A1"; "A2"; "A3"; "A4"; "A5"; "A6"; "A7"; "A8"; "A9";
      "F0"; "F1"; "F2"; "F3"; "F4"; "F5"; "F6"; "F7"; "F8"; "F9";
      "G0"; "G1"; "G2"; "G3"; "G4"; "G5"; "G6"; "G7"; "G8"; "G9";
      "K0"; "K1"; "K2"; "K3"; "K4"; "K5"; "K6"; "K7"; "K8"; "K9";
      "M0"; "M1"; "M2"; "M3"; "M4"; "M5"; "M6"; "M7"; "M8"; "M9"
    },

    arrTHigh, {
      ""; ""; ""; 44900; 42900; 41400; 39500; 37100; 35100; 33300;
      31400; 26000; 20600; 17000; 16400; 15700; 14500; 14000; 12300; 10700;
      9700; 9300; 8800; 8600; 8250; 8100; 7910; 7760; 7590; 7400;
      7220; 7020; 6820; 6750; 6670; 6550; 6350; 6280; 6180;
      6050; 5930; 5860; 5770; 5720; 5680; 5660; 5600; 5550; 5480;
      5380; 5270; 5170; 5100; 4830; 4600; 4440; 4300; 4100; 3990;
      3930; 3850; 3660; 3560; 3430; 3210; 3060; 2810; 2680; 2570; 2380
    },

    arrSpan, {
      ""; ""; ""; 2000; 1500; 1900; 2400; 2000; 1800; 1900;
      5400; 5400; 3600; 600; 700; 1200; 500; 1700; 1600; 1000;
      400; 500; 200; 350; 150; 190; 150; 170; 190; 180;
      200; 200; 70; 80; 120; 200; 70; 100; 130;
      120; 70; 90; 50; 40; 20; 60; 50; 70; 100;
      110; 100; 70; 270; 230; 160; 140; 200; 110; 60;
      80; 190; 100; 130; 220; 150; 250; 130; 110; 190; 280
    },

    // --- If no type is specified, display full table ---
    formattedData, BYROW(HSTACK(arrTypes, arrTHigh, arrSpan),
      LAMBDA(row, TEXTJOIN("; ", TRUE, TEXT(INDEX(row, 2), "0"), TEXT(INDEX(row, 3), "0")))
    ),

    Numbers, SEQUENCE(10,1,0,1),
    O_Stars, FILTER(formattedData, LEFT(arrTypes,1)="O"),
    B_Stars, FILTER(formattedData, LEFT(arrTypes,1)="B"),
    A_Stars, FILTER(formattedData, LEFT(arrTypes,1)="A"),
    F_Stars, FILTER(formattedData, LEFT(arrTypes,1)="F"),
    G_Stars, FILTER(formattedData, LEFT(arrTypes,1)="G"),
    K_Stars, FILTER(formattedData, LEFT(arrTypes,1)="K"),
    M_Stars, FILTER(formattedData, LEFT(arrTypes,1)="M"),

    fullTable, VSTACK(Headers, HSTACK(Numbers,O_Stars, B_Stars, A_Stars, F_Stars, G_Stars, K_Stars, M_Stars)),

    // --- If type is specified, just return two-column breakdown ---
    temps, FILTER(arrTHigh, LEFT(arrTypes, 1) = type),
    spans, FILTER(arrSpan, LEFT(arrTypes, 1) = type),
    typeHead, HSTACK(type, "span"),
    slimTable, VSTACK(typeHead, HSTACK(temps, spans)),

    // --- Final output: full table or filtered columns
    result, IF(ISBLANK(type), fullTable, slimTable),

    result
  )
);

/* ASTRO_STAR_ATTRIBUTES

   Purpose:
   Calculates all key stellar parameters from a single known value — temperature, mass, radius,
   luminosity, or lifetime — using empirical power-law scaling relationships based on the Sun.

   Parameters:
   - mode     (required): A string indicating the input attribute type:
       "K" — Effective temperature (Kelvin)
       "T" — Normalized temperature (T / 5770 K)
       "M" — Mass (solar units)
       "R" — Radius (solar units)
       "L" — Luminosity (solar units)
       "V" — Main-sequence lifetime (solar units)
   - input    (required): A numeric value representing the input attribute (must match the mode).
   - precision (optional): Number of decimal places to round output values. Default = 6.

   Returns:
   A two-column array with labeled stellar parameters (K, T, M, R, L, V),
   with the input attribute flagged with a ➔ arrow for clarity.

   Method:
   The function normalizes the input value to a solar-relative temperature (`Tnorm`)
   and derives the remaining parameters from empirical exponents:

   - K = Tnorm × 5770
   - M = Tnorm²
   - R = Tnorm^1.8
   - L = Tnorm^7.6
   - V = Tnorm^(-5)

   Example:
   ASTRO_STAR_ATTRIBUTES("K", 9170.6052, 3)

   Output:
     K ➔   9170.605
     T     1.588
     M     2.523
     R     2.296
     L     33.006
     V     0.101

   Notes:
   - Based on simplified stellar scaling laws used in astrophysics and worldbuilding.
   - Effective temperature is scaled to 5770 K for the Sun (standard solar reference).
   - Lifetime is approximated as a power inverse of temperature: V ∝ T⁻⁵.
   - Designed for educational, speculative, and modeling purposes.

*/

ASTRO_STAR_ATTRIBUTES = LAMBDA(mode, input, [precision],
  LET(
    // Set default rounding precision
    prec, IF(ISOMITTED(precision), 6, precision),

    // Normalize input mode to upper-case for consistency
    mode, UPPER(mode),

    // Normalize input to solar-relative temperature (Tnorm)
    Tnorm, SWITCH(
      mode,
      "T", input,
      "K", input / 5770,
      "M", SQRT(input),
      "R", input ^ (1 / 1.8),
      "L", input ^ (1 / 7.6),
      "V", input ^ (-1 / 5),
      NA()
    ),

    // Now derive all other attributes from Tnorm
    K, Tnorm * 5770,
    M, Tnorm ^ 2,
    R, Tnorm ^ 1.8,
    L, Tnorm ^ 7.6,
    V, Tnorm ^ -5,

    // Round everything and format as strings
    labels, TRANSPOSE({"K", "T", "M", "R", "L", "V"}),
        output_values, VSTACK(
        ROUND(K, prec),
        ROUND(Tnorm, prec),
        ROUND(M, prec),
        ROUND(R, prec),
        ROUND(L, prec),
        ROUND(V, prec)
        ),

    // --- Labels with arrow on selected mode ---
        flagged_labels, BYROW(labels, LAMBDA(row, IF(row = mode, row & " ➔", row))),


    // Return labeled table
    CHOOSE({1, 2}, flagged_labels, output_values)
  )
);


/* ASTRO_HABITABLE_ZONES:
   Purpose: Returns habitable zone data based on stellar luminosity.

   Modes:
   - "TABLE"    → Returns a full table of inner/outer/avg/span distances for zones Z0–Z5.
   - "VERTICAL" → Returns a vertical list of scaled distances, with N-> marking the nucleal radius.
   - "HORIZONTAL" → Returns a horizontal row of the same values for use in inline display.

   Parameters:
   - mode (required): One of "TABLE", "VERTICAL", or "HORIZONTAL".
   - lum (optional): Stellar luminosity in solar units. Required for VERTICAL and HORIZONTAL.
   - precision (optional): Number of decimal places (default = 3)

   Zones (Z0–Z5) represent nested circumstellar habitability bands:
   - Z0: (too hot)
   - Z1: (inner edge)
   - Z2: (inner temperate)
   - Z3: (outer temperate)
   - Z4: (outer edge)
   - Z5: (too cold)

   Example usage:
   ASTRO_HABITABLE_ZONES("TABLE")            → Returns base reference chart
   ASTRO_HABITABLE_ZONES("VERTICAL", 1.25)   → Returns vertical distances scaled to star with L = 1.25
   ASTRO_HABITABLE_ZONES("HORIZONTAL", 1.25) → Returns same as row

   Notes:
   - Nucleal radius is sqrt(L) and used as anchor between Z2–Z3.
   - Input is ignored for mode "TABLE".
*/

ASTRO_HABITABLE_ZONES = LAMBDA(mode, [lum], [precision],
  LET(
    mode, UPPER(mode),
    prec, IF(ISOMITTED(precision), 3, precision),

    // Zone coefficients
    zone_labels, {"Z0"; "Z1"; "Z2"; "Z3"; "Z4"; "Z5"},
    inner_factors, {0; 0.5; 0.75; 0.95; 1.385; 1.77},
    outer_factors, {0.5; 0.75; 0.95; 1.385; 1.77; 4.85},

    // Precompute average and span
    avg_factors, (inner_factors + outer_factors) / 2,
    span_factors, outer_factors - inner_factors,

    // Nucleal (for scaling)
    nucleal, SQRT(IF(ISOMITTED(lum), 1, lum)),

    // Compute scaled distances
    inner_scaled, ROUND(nucleal * inner_factors, prec),
    outer_scaled, ROUND(nucleal * outer_factors, prec),
    avg_scaled, ROUND(nucleal * avg_factors, prec),
    span_scaled, ROUND(nucleal * span_factors, prec),

    // Formatted output
    vertical_labels, {"0: ", "1: ", "2: ", "N ➔", "3: ", "4: ", "5: "},
    vertical_values, VSTACK(
    ROUND(INDEX(inner_factors, 2) * nucleal, prec),
    ROUND(INDEX(inner_factors, 3) * nucleal, prec),
    ROUND(INDEX(inner_factors, 4) * nucleal, prec),
    ROUND(nucleal, prec),
    ROUND(INDEX(outer_factors, 4) * nucleal, prec),
    ROUND(INDEX(outer_factors, 5) * nucleal, prec),
    ROUND(INDEX(outer_factors, 6) * nucleal, prec)
    ),

    // Return logic
    result,
      SWITCH(
        mode,
        "STANDARD", CHOOSE(
          {1, 2, 3, 4, 5},
          VSTACK("Zone", zone_labels),
          VSTACK("Inner", inner_factors),
          VSTACK("Outer", outer_factors),
          VSTACK("Average", avg_factors),
          VSTACK("Span", span_factors)
        ),
        "VERTICAL", 
          LET(
            labels, {"0:", "1:", "2:", "N ➔", "3:", "4:", "5:"},
            scaled_values, ROUND(nucleal * {0.5, 0.75, 0.95, 1, 1.385, 1.77, 4.85}, prec),
            TRANSPOSE(VSTACK(labels, scaled_values))
        ),
        "HORIZONTAL", HSTACK(
        ROUND(INDEX(inner_factors, 2) * nucleal, prec),
        ROUND(INDEX(inner_factors, 3) * nucleal, prec),
        ROUND(INDEX(inner_factors, 4) * nucleal, prec),
        ROUND(nucleal, prec),
        ROUND(INDEX(outer_factors, 4) * nucleal, prec),
        ROUND(INDEX(outer_factors, 5) * nucleal, prec),
        ROUND(INDEX(outer_factors, 6) * nucleal, prec)
        ),
        "Invalid mode"
      ),

    result
  )
);

/* NASTRO_HABITABLE_ZONES:
   Purpose: Provides information about stellar habitable zones across multiple display modes:
            - STANDARD: Returns a fixed table of inner/outer bounds for Z0–Z5 zones in AU
            - TABLE: Scales the STANDARD zones based on stellar luminosity
            - VERTICAL: Returns a vertical list of zone labels and distances based on luminosity
            - HORIZONTAL: Returns a single-row summary of scaled distances

   Parameters:
   - mode (required): "STANDARD", "TABLE", "VERTICAL", or "HORIZONTAL"
   - lum (optional): Stellar luminosity in solar units (only required for TABLE, VERTICAL, or HORIZONTAL modes)
   - prec (optional): Number of decimal places to round distances to (default = 3)

   Example:
   ASTRO_HABITABLE_ZONES("STANDARD")
   ASTRO_HABITABLE_ZONES("TABLE", 3)
   ASTRO_HABITABLE_ZONES("VERTICAL", 3)
   ASTRO_HABITABLE_ZONES("HORIZONTAL", 3)
*/

NASTRO_HABITABLE_ZONES = LAMBDA(mode, [lum], [prec],
  LET(
    // --- Defaults ---
    dec, IF(ISOMITTED(prec), 3, prec),
    L, IF(ISOMITTED(lum), 1, lum),
    nuc, SQRT(L),

    // --- Zone base data ---
    zone_labels, {"Z0", "Z1", "Z2", "Z3", "Z4", "Z5"},
    inner_factors, {0, 0.5, 0.75, 0.95, 1.385, 1.77},
    outer_factors, {0.5, 0.75, 0.95, 1.385, 1.77, 4.85},
    avg_factors,   {0.25, 0.625, 0.85, 1.1675, 1.5775, 3.31},
    span_factors,  {0.5, 0.25, 0.2, 0.435, 0.385, 3.08},

    // --- Scaled values ---
    inner_scaled, ROUND(nuc * inner_factors, dec),
    outer_scaled, ROUND(nuc * outer_factors, dec),
    avg_scaled,   ROUND(nuc * avg_factors, dec),
    span_scaled,  ROUND(nuc * span_factors, dec),

    // --- Table: STANDARD and TABLE modes ---
    row_1, VSTACK("Zone", zone_labels),
    row_2, VSTACK("Inner", IF(mode="STANDARD", inner_factors, inner_scaled)),
    row_3, VSTACK("Outer", IF(mode="STANDARD", outer_factors, outer_scaled)),
    row_4, VSTACK("Average", IF(mode="STANDARD", avg_factors, avg_scaled)),
    row_5, VSTACK("Span", IF(mode="STANDARD", span_factors, span_scaled)),

    // --- Vertical mode output ---
    vertical_labels, {"0:", "1:", "2:", "N ➔", "3:", "4:", "5:"},
    vertical_values, ROUND({0.5, 0.75, 0.95, 1, 1.385, 1.77, 4.85} * nuc, dec),

    // --- Horizontal mode output ---
    horizontal_values, HSTACK(
      ROUND(0.5 * nuc, dec),
      ROUND(0.75 * nuc, dec),
      ROUND(0.95 * nuc, dec),
      ROUND(1 * nuc, dec),
      ROUND(1.385 * nuc, dec),
      ROUND(1.77 * nuc, dec),
      ROUND(4.85 * nuc, dec)
    ),

    // --- Final output based on mode ---
    SWITCH(
      UPPER(mode),
      "STANDARD", HSTACK(row_1, row_2, row_3, row_4, row_5),
      "TABLE",    HSTACK(row_1, row_2, row_3, row_4, row_5),
      "VERTICAL", HSTACK(vertical_labels, vertical_values),
      "HORIZONTAL", horizontal_values,
      "Invalid mode"
    )
  )
)
;

/* ASTRO_STAR_DENSITY_VOLUME
   Purpose: Given a spherical volume (or radius), calculate how many stars fit at 1 star per 250 cubic light-years.

   Parameters:
   - input (required): Either a spherical radius or a volume, depending on mode.
   - prec (optional): Decimal places for output precision (default = 3).
   - mode (optional): 
       0 = input is a volume in cubic light-years (default),
       1 = input is a radius in light-years.

   Returns:
   - A vertical array containing either:
       • [number of stars; radius] if mode = 0
       • [number of stars; volume] if mode = 1

   Example:
   ASTRO_STAR_DENSITY_VOLUME(1000)          → {4.000; 6.203}
   ASTRO_STAR_DENSITY_VOLUME(5, 2, 1)       → {2.62; 523.60}
*/

ASTRO_STAR_DENSITY_VOLUME = LAMBDA(input, [prec], [mode],
  LET(
    mode, IF(ISOMITTED(mode) + (mode < 0) + (mode > 1), 0, mode),
    prec, IF(ISOMITTED(prec) + (prec < 0), 3, prec),

    volume, IF(mode = 0, input, (4/3) * PI() * input ^ 3),
    radius, IF(mode = 1, input, ROUND(((3 * volume) / (4 * PI())) ^ (1/3), prec)),
    stars, ROUND(volume / 250, prec),

    output, SWITCH(mode,
      0, TOCOL(TEXTSPLIT(TEXTJOIN("; ", , "Stars: "&stars, "Radius: "&radius), "; ")),
      1, TOCOL(TEXTSPLIT(TEXTJOIN("; ", , "Stars: "&stars, "Volume: "&volume), "; "))
    ),

    output
  )
);

/* ASTRO_PLANET_METRICS_SAFETY
   Purpose: Calculates planetary mass, radius, density, surface gravity, and escape velocity
            from any valid pair of two known parameters.

   Parameters:
   - mode (required): A string indicating the known input pair. Acceptable values:
       "md" = Mass + Density
       "mr" = Mass + Radius
       "mg" = Mass + Gravity
       "rd" = Radius + Density
       "rg" = Radius + Gravity
       "dg" = Density + Gravity
       "dv" = Density + Escape Velocity
       "gv" = Gravity + Escape Velocity
       "mv" = Mass + Escape Velocity
       "rv" = Radius + Escape Velocity
   - param_1 (required): The first numeric input, meaning depends on mode
   - param_2 (required): The second numeric input, meaning depends on mode
   - prec (optional): Decimal precision for output rounding (default = 5)

   Returns:
   - A labeled 5-row table with values for: Mass (M), Radius (R), Density (d),
     Gravity (g), Escape Velocity (v)
*/

ASTRO_PLANET_METRICS_SAFETY = LAMBDA(mode, param_1, param_2, [prec],
  LET(
    // Default precision
    prec, IF(ISOMITTED(prec), 5, prec),

    // Normalize input mode to lowercase
    mode, LOWER(mode),

    // Compute based on selected mode
    output, SWITCH(
      mode,
      
      // Mass + Density
      "md", LET(
        M, param_1,
        d, param_2,
        R, (M / d) ^ (1/3),
        g, (M * d^2) ^ (1/3),
        v, (M * SQRT(d)) ^ (1/3),
        HSTACK(M, R, d, g, v)
      ),

      // Mass + Radius
      "mr", LET(
        M, param_1,
        R, param_2,
        d, M / R^3,
        g, M / R^2,
        v, SQRT(M / R),
        HSTACK(M, R, d, g, v)
      ),

      // Mass + Gravity
      "mg", LET(
        M, param_1,
        g, param_2,
        R, SQRT(M / g),
        d, SQRT(g^3 / M),
        v, (M * g) ^ 0.25,
        HSTACK(M, R, d, g, v)
      ),

      // Radius + Density
      "rd", LET(
        R, param_1,
        d, param_2,
        M, d * R^3,
        g, d * R,
        v, R * SQRT(d),
        HSTACK(M, R, d, g, v)
      ),

      // Radius + Gravity
      "rg", LET(
        R, param_1,
        g, param_2,
        M, g * R^2,
        d, g / R,
        v, SQRT(g * R),
        HSTACK(M, R, d, g, v)
      ),

      // Density + Gravity
      "dg", LET(
        d, param_1,
        g, param_2,
        R, g / d,
        M, g^3 / d^2,
        v, g / SQRT(d),
        HSTACK(M, R, d, g, v)
      ),

      // Density + Escape Velocity
      "dv", LET(
        d, param_1,
        v, param_2,
        R, v / SQRT(d),
        M, v^3 / SQRT(d),
        g, v * SQRT(d),
        HSTACK(M, R, d, g, v)
      ),

      // Gravity + Escape Velocity
      "gv", LET(
        g, param_1,
        v, param_2,
        R, v^2 / g,
        M, v^4 / g,
        d, (g / v)^2,
        HSTACK(M, R, d, g, v)
      ),

      // Mass + Escape Velocity
      "mv", LET(
        M, param_1,
        v, param_2,
        R, M / v^2,
        g, v^4 / M,
        d, v^6 / M^2,
        HSTACK(M, R, d, g, v)
      ),

      // Radius + Escape Velocity
      "rv", LET(
        R, param_1,
        v, param_2,
        g, v^2 / R,
        M, R * v^2,
        d, (v / R)^2,
        HSTACK(M, R, d, g, v)
      ),

      // Default fallback
      NA()
    ),

    // Format with headers and rounding
    headers, {"M", "R", "d", "g", "v"},
    values, ROUND(output, prec),
    CHOOSE({1, 2}, TRANSPOSE(headers), TRANSPOSE(values))
  )
);

/* ASTRO_PLANET_METRICS
   Purpose:
   Calculates planetary mass, radius, density, surface gravity, and escape velocity
   based on any two known values, and flags the provided inputs with an arrow (➔).

   Parameters:
   - mode (required): A string indicating the two known values. Accepted values:
       "md" = Mass + Density
       "mr" = Mass + Radius
       "mg" = Mass + Gravity
       "rd" = Radius + Density
       "rg" = Radius + Gravity
       "dg" = Density + Gravity
       "dv" = Density + Escape Velocity
       "gv" = Gravity + Escape Velocity
       "mv" = Mass + Escape Velocity
       "rv" = Radius + Escape Velocity
   - param_1 (required): First known parameter (meaning depends on mode)
   - param_2 (required): Second known parameter (meaning depends on mode)
   - prec (optional): Decimal precision for output (default = 5)

   Returns:
   - A 2-column vertical table with headers {"M", "R", "d", "g", "v"} and calculated values.
     Input values are flagged with a ➔ to indicate their origin.
     Units are assumed to be consistent and relative (e.g., Earth = 1.0).

   Notes:
   - Designed for use in modeling, planetary physics simulations, and educational applications.
   - Outputs are internally calculated based on basic physical relationships:
       - M = mass
       - R = radius
       - d = density
       - g = surface gravity
       - v = escape velocity
   - Handles input permutations flexibly via mode string parsing.

   Example:
   ASTRO_PLANET_METRICS_FLAGGED("rd", 1.2, 0.75)
     →
       M      0.675
       R ➔    1.2
       d ➔    0.75
       g      0.9
       v      1.039

*/


ASTRO_PLANET_METRICS = LAMBDA(mode, param_1, param_2, [prec],
  LET(
    // Default precision
    prec, IF(ISOMITTED(prec), 5, prec),

    // Normalize input mode to lowercase
    mode, LOWER(mode),

    // Compute based on selected mode
    output, SWITCH(
      mode,
      
      // Mass + Density
      "md", LET(
        M, param_1,
        d, param_2,
        R, (M / d) ^ (1/3),
        g, (M * d^2) ^ (1/3),
        v, (M * SQRT(d)) ^ (1/3),
        HSTACK(M, R, d, g, v)
      ),

      // Mass + Radius
      "mr", LET(
        M, param_1,
        R, param_2,
        d, M / R^3,
        g, M / R^2,
        v, SQRT(M / R),
        HSTACK(M, R, d, g, v)
      ),

      // Mass + Gravity
      "mg", LET(
        M, param_1,
        g, param_2,
        R, SQRT(M / g),
        d, SQRT(g^3 / M),
        v, (M * g) ^ 0.25,
        HSTACK(M, R, d, g, v)
      ),

      // Radius + Density
      "rd", LET(
        R, param_1,
        d, param_2,
        M, d * R^3,
        g, d * R,
        v, R * SQRT(d),
        HSTACK(M, R, d, g, v)
      ),

      // Radius + Gravity
      "rg", LET(
        R, param_1,
        g, param_2,
        M, g * R^2,
        d, g / R,
        v, SQRT(g * R),
        HSTACK(M, R, d, g, v)
      ),

      // Density + Gravity
      "dg", LET(
        d, param_1,
        g, param_2,
        R, g / d,
        M, g^3 / d^2,
        v, g / SQRT(d),
        HSTACK(M, R, d, g, v)
      ),

      // Density + Escape Velocity
      "dv", LET(
        d, param_1,
        v, param_2,
        R, v / SQRT(d),
        M, v^3 / SQRT(d),
        g, v * SQRT(d),
        HSTACK(M, R, d, g, v)
      ),

      // Gravity + Escape Velocity
      "gv", LET(
        g, param_1,
        v, param_2,
        R, v^2 / g,
        M, v^4 / g,
        d, (g / v)^2,
        HSTACK(M, R, d, g, v)
      ),

      // Mass + Escape Velocity
      "mv", LET(
        M, param_1,
        v, param_2,
        R, M / v^2,
        g, v^4 / M,
        d, v^6 / M^2,
        HSTACK(M, R, d, g, v)
      ),

      // Radius + Escape Velocity
      "rv", LET(
        R, param_1,
        v, param_2,
        g, v^2 / R,
        M, R * v^2,
        d, (v / R)^2,
        HSTACK(M, R, d, g, v)
      ),

      // Default fallback
      NA()
    ),

    // Format with headers and rounding
    headers, SWITCH(
        mode,
        "md", {"M ➔", "R", "d ➔", "g", "v"},
        "mr", {"M ➔", "R ➔", "d", "g", "v"},
        "mg", {"M ➔", "R", "d", "g ➔", "v"},
        "rd", {"M", "R ➔", "d ➔", "g", "v"},
        "rg", {"M", "R ➔", "d", "g ➔", "v"},
        "dg", {"M", "R", "d ➔", "g ➔", "v"},
        "dv", {"M", "R", "d ➔", "g", "v ➔"},
        "gv", {"M", "R", "d", "g ➔", "v ➔"},
        "mv", {"M ➔", "R", "d", "g", "v ➔"},
        "rv", {"M", "R ➔", "d", "g", "v ➔"},
        {"M", "R", "d", "g", "v"}  // fallback
        ),
    values, ROUND(output, prec),
    CHOOSE({1, 2}, TRANSPOSE(headers), TRANSPOSE(values))
  )
);

// ASTRO_SYNODIC = 
// LAMBDA(p, q, prec,
//   LET(
//     result,
//     IF(p = q,
//        NA(),
//        LET(
//          num, p * q,
//          den, ABS(p - q),
//          raw, num / den,
//          ROUND(raw, prec)
//        )
//     ),
//     result
//   )
// );

// ASTRO_SYNODIC_SOLVED =
// LAMBDA(val_1, val_2, [mode], [prec],
//   LET(
//     mode, IF(ISOMITTED(mode), "pq", IF(mode = "", "pq", mode)),
//     prec, IF(ISOMITTED(prec), 4, prec),

//     p, IF(OR(mode="pq", mode="ps"), val_1, NA()),
//     q, IF(mode="pq", val_2, IF(mode="qs", val_1, NA())),
//     s, IF(OR(mode="ps", mode="qs"), val_2, NA()),

//     a, IF(AND(ISNUMBER(p), ISNUMBER(q)), MAX(p, q), p),
//     b, IF(AND(ISNUMBER(p), ISNUMBER(q)), MIN(p, q), q),

//     result,
//       SWITCH(
//         mode,
//         "pq", IF(a = b, NA(), ROUND((a * b) / (a - b), prec)),
//         "ps", IF(OR(NOT(ISNUMBER(a)), NOT(ISNUMBER(s))), NA(),
//                  ROUND((a * s) / (a - s), prec)),
//         "qs", IF(OR(NOT(ISNUMBER(b)), NOT(ISNUMBER(s))), NA(),
//                  ROUND((b * s) / (b - s), prec)),
//         NA()
//       ),
//     result
//   )
// );

/* ASTRO_SYNODIC_SOLVER
   Purpose:
   A comprehensive synodic period solver that calculates the third value (P, Q, or S)
   when any two of the three are provided. Supports multiple input/output modes for
   scientific modeling, pedagogical use, and flexible presentation.

   Parameters:
   - val_1 (required): First input value. Meaning depends on the selected mode.
   - val_2 (required): Second input value. Meaning depends on the selected mode.
   - mode (optional): 2-letter string indicating known inputs. Accepts any case or order.
       - "pq" = solve for S (synodic period)
       - "ps" = solve for Q (outer sidereal orbit)
       - "qs" = solve for P (inner sidereal orbit)
     Default is "pq" if omitted or invalid.
   - format (optional): Output format (default = "bare")
       - "bare"    → returns the solved value only
       - "labeled" → returns "P = 365.25", "S = 779.88", etc., depending on mode
       - "verbose" → returns inline text of all three values with ☞ on solved value
       - "row"     → returns 1x3 array with P, Q, and S labels and values
       - "col"     → returns 3x2 vertical array: {"P =", 365.25; "Q =", 687; "S ☞", 779.88}
   - prec (optional): Decimal precision to round results (default = 4)

   Returns:
   - A scalar value or a labeled/spill array depending on selected format.
   - In all cases, the calculated (solved) value is flagged with a right arrow (☞).

   Notes:
   - Synodic period formula: S = (P * Q) / |P - Q|
   - Inverse solutions:
       - Q = (P * S) / |P - S|
       - P = (Q * S) / |Q - S|
   - Inputs are auto-ordered as needed for stability (e.g., P = max(val1, val2) in "pq" mode).
   - Mode is case-insensitive and auto-normalized (e.g., "QS", "sq", and "sQ" all → "qs").
   - Output formats support human-readable results and structured table integration.
   - Designed as a general-purpose engine for use in astronomy models and educational tools.

   Example 1:
     ASTRO_SYNODIC_SOLVER(365.25, 687, "pq", "bare", 4)
       → 779.8811

   Example 2:
     ASTRO_SYNODIC_SOLVER(365.25, 687, "pq", "verbose")
       → "P = 365.25, Q = 687, S = ☞ 779.8811"

   Example 3:
     ASTRO_SYNODIC_SOLVER(687, 779.8811, "qs", "col")
       →
         P ☞    365.25
         Q =    687
         S =    779.8811

   Recommendation:
   - For general users, consider using one of the simpler wrapper functions:
       - ASTRO_SYNODIC_PQ(P, Q)
       - ASTRO_SYNODIC_PS(P, S)
       - ASTRO_SYNODIC_QS(Q, S)
   - This function is intended for advanced use cases and UI-integrated output.

*/


ASTRO_SYNODIC_SOLVER =
LAMBDA(val_1, val_2, [mode], [format], [prec],
  LET(
    // Handle optional arguments
    raw_mode, IF(ISOMITTED(mode) + (mode = ""), "PQ", mode),
    norm_mode, TEXTJOIN("",,SORT(MID(LOWER(raw_mode),SEQUENCE(LEN(raw_mode)),1))),
    mode, norm_mode,

    format, IF(ISOMITTED(format) + (format = ""), "bare", LOWER(format)),
    prec, IF(ISOMITTED(prec), 4, prec),

    // Input unpacking by mode
    P_in, IF(OR(mode="pq", mode="ps"), val_1, NA()),
    Q_in, IF(mode="pq", val_2, IF(mode="qs", val_1, NA())),
    S_in, IF(OR(mode="ps", mode="qs"), val_2, NA()),

    // P and Q ordering only used in 'pq' mode
    P, IF(AND(ISNUMBER(P_in), ISNUMBER(Q_in)), MAX(P_in, Q_in), P_in),
    Q, IF(AND(ISNUMBER(P_in), ISNUMBER(Q_in)), MIN(P_in, Q_in), Q_in),

    // Synodic period calculation
    S_calc, IF(P = Q, NA(), ROUND((P * Q) / (P - Q), prec)),

    // Direction-aware inverse calculations
    Q_calc, IF(OR(NOT(ISNUMBER(P)), NOT(ISNUMBER(S_in))), NA(),
                ROUND((P * S_in) / ABS(P - S_in), prec)),

    P_calc, IF(OR(NOT(ISNUMBER(Q)), NOT(ISNUMBER(S_in))), NA(),
                ROUND((Q * S_in) / ABS(Q - S_in), prec)),

    // Selected result values
    P_val, IF(mode = "qs", P_calc, P),
    Q_val, IF(mode = "ps", Q_calc, Q),
    S_val, IF(mode = "pq", S_calc, S_in),

    // Solved label
    label, SWITCH(mode, "pq", "S", "ps", "Q", "qs", "P", "?"),

    // Primary scalar result
    result, SWITCH(mode, "pq", S_calc, "ps", Q_calc, "qs", P_calc, NA()),

    // Verbose text output
    verbose_out,
      "P = " & IF(ISNUMBER(P_val), IF(mode = "qs", "☞ " & P_val, P_val), "—") & ", " &
      "Q = " & IF(ISNUMBER(Q_val), IF(mode = "ps", "☞ " & Q_val, Q_val), "—") & ", " &
      "S = " & IF(ISNUMBER(S_val), IF(mode = "pq", "☞ " & S_val, S_val), "—"),

    // Spillable tabular outputs
    row_out,
      VSTACK(
        HSTACK(
          IF(mode="qs", "P ☞", "P ="),
          IF(mode="ps", "Q ☞", "Q ="),
          IF(mode="pq", "S ☞", "S =")
        ),
        HSTACK(P_val, Q_val, S_val)
      ),

    col_out,
      VSTACK(
        HSTACK(IF(mode="qs", "P ☞", "P ="), P_val),
        HSTACK(IF(mode="ps", "Q ☞", "Q ="), Q_val),
        HSTACK(IF(mode="pq", "S ☞", "S ="), S_val)
      ),

    // Final switch for return type
    output,
      SWITCH(format,
        "bare", result,
        "labeled", label & " = " & result,
        "verbose", verbose_out,
        "row", row_out,
        "col", col_out,
        "Invalid format"
      ),

    output
  )
);

/* ASTRO_SYNODIC_PQ
   Purpose:
   Calculates the synodic period (S) between two planetary bodies
   based on their sidereal orbital periods P and Q.

   Parameters:
   - P (required): Sidereal orbital period of the inner (faster) body
   - Q (required): Sidereal orbital period of the outer (slower) body
   - output (optional): Output format. 
       - "bare" = Returns synodic period only (default)
       - "verbose" = Returns a 2-column vertical table: P, Q, S, with the result flagged (☞)
   - prec (optional): Decimal precision (default = 4)

   Returns:
   - Synodic period (bare), or
   - Verbose 2-column array with labeled P, Q, and S values
     (S is flagged with a ☞ to indicate it's the solved value)

   Notes:
   - S = (P × Q) / |P − Q|, assuming P ≠ Q
   - Inputs may be provided in any order; the function internally assigns P/Q for correct calculation
   - Useful for predicting conjunction intervals or orbital resonance modeling

   Example:
   ASTRO_SYNODIC_PQ(365.25, 687, "verbose", 4)
     →
       P =      365.25
       Q =      687
       S ☞ =    779.8811
*/


ASTRO_SYNODIC_PQ =
LAMBDA(P, Q, [output], [prec],
  LET(
    // Handle optional arguments
    mode, IF(ISOMITTED(output) + (output = ""), "bare", LOWER(output)),
    digits, IF(ISOMITTED(prec), 4, prec),

    // Sort for stability in synodic calculation
    A, MAX(P, Q),
    B, MIN(P, Q),

    // Calculate synodic period
    S, ROUND((A * B) / (A - B), digits),

    // Two-column verbose output (labels preserved)
    verbose,
      VSTACK(
        HSTACK("P =", P),
        HSTACK("Q =", Q),
        HSTACK("S ☞", S)
      ),

    // Output selection
    result, IF(mode = "verbose", verbose, S),

    result
  )
);

/* ASTRO_SYNODIC_PS
   Purpose:
   Calculates the sidereal orbital period Q of the outer body
   based on the synodic period (S) and the known inner orbital period (P).

   Parameters:
   - P (required): Sidereal orbital period of the inner (faster) body
   - S (required): Synodic period (observed interval between conjunctions)
   - output (optional): Output format. 
       - "bare" = Returns Q only (default)
       - "verbose" = Returns a 2-column vertical table: P, Q, S, with Q flagged (☞)
   - prec (optional): Decimal precision (default = 4)

   Returns:
   - Sidereal period Q (bare), or
   - Verbose 2-column array with labeled P, Q, and S values
     (Q is flagged with ☞ to indicate it's the solved value)

   Notes:
   - Q = (P × S) / (P − S)
   - Assumes S < P (synodic period must be shorter than slower body's orbit)
   - Designed for systems where synodic intervals are measured and inner body is known

   Example:
   ASTRO_SYNODIC_PS(365.25, 779.8811, "verbose", 4)
     →
       P =      365.25
       Q ☞ =    687
       S =      779.8811
*/


ASTRO_SYNODIC_PS =
LAMBDA(P, S, [output], [prec],
  LET(
    // Optional argument handling
    mode, IF(ISOMITTED(output) + (output = ""), "bare", LOWER(output)),
    digits, IF(ISOMITTED(prec), 4, prec),

    // Compute Q (outer orbit)
    Q, ROUND((P * S) / ABS(P - S), digits),

    // Verbose spill output
    verbose,
      VSTACK(
        HSTACK("P =", P),
        HSTACK("Q ☞", Q),
        HSTACK("S =", S)
      ),

    // Output choice
    result, IF(mode = "verbose", verbose, Q),

    result
  )
);

/* ASTRO_SYNODIC_QS
   Purpose:
   Calculates the sidereal orbital period P of the inner (faster) body
   based on the synodic period (S) and the known outer orbital period (Q).

   Parameters:
   - Q (required): Sidereal orbital period of the outer (slower) body
   - S (required): Synodic period (observed interval between conjunctions)
   - output (optional): Output format. 
       - "bare" = Returns P only (default)
       - "verbose" = Returns a 2-column vertical table: P, Q, S, with P flagged (☞)
   - prec (optional): Decimal precision (default = 4)

   Returns:
   - Sidereal period P (bare), or
   - Verbose 2-column array with labeled P, Q, and S values
     (P is flagged with ☞ to indicate it's the solved value)

   Notes:
   - P = (Q × S) / (Q + S)
   - Used when the synodic period and slower orbit are known (e.g., observational astronomy)
   - Output layout is consistent across all synodic solver functions

   Example:
   ASTRO_SYNODIC_QS(687, 779.8811, "verbose", 4)
     →
       P ☞ =    365.25
       Q =      687
       S =      779.8811
*/


ASTRO_SYNODIC_QS =
LAMBDA(Q, S, [output], [prec],
  LET(
    mode, IF(ISOMITTED(output) + (output = ""), "bare", LOWER(output)),
    digits, IF(ISOMITTED(prec), 4, prec),

    // Correct formula: P = (Q * S) / (Q + S)
    P, ROUND((Q * S) / (Q + S), digits),

    verbose,
      VSTACK(
        HSTACK("P ☞", P),
        HSTACK("Q =", Q),
        HSTACK("S =", S)
      ),

    result, IF(mode = "verbose", verbose, P),
    result
  )
);

/* ASTRO_APPARENT_SOLAR_SIZE
   Purpose:
   Calculates the apparent angular diameter of a star (or other object) as seen from a specified distance,
   expressed as a multiple of the Sun’s apparent size from Earth.

   Inputs:
   - radius (required): Radius of the object, in solar radii (R☉)
   - distance (required): Distance to the object, in astronomical units (AU)
   - format (optional): Output mode.
       "raw"       → returns numeric scalar (e.g., 1.545)
       "formatted" → returns string formatted as (e.g., "1.545☉")
       Default     → "formatted"
   - prec (optional): Number of decimal places to round to (default = 4)

   Returns:
   - Apparent angular size of the object as a multiple of the Sun’s.
     1.0 means the object appears exactly the same size as the Sun in Earth's sky.
     >1.0 means larger; <1.0 means smaller.

   Notes:
   - Assumes that inputs are in solar radii and AU, which cancel naturally to a unitless ratio.
   - Useful for worldbuilding, visual storytelling, and comparative astronomy.
   - May be expanded in future to support true angular units (arcmin, degrees, etc.)
*/

ASTRO_APPARENT_SOLAR_SIZE =
LAMBDA(radius, distance, [format], [prec],
  LET(
    // Set default precision if omitted
    p, IF(ISOMITTED(prec), 4, prec),

    // Core calculation: ratio of radius to distance
    raw, radius / distance,

    // Conditional output formatting
    result,
      IF(
        OR(ISOMITTED(format), format = "formatted"),
        TEXT(raw, "0." & REPT("0", p)) & "☉",  // e.g., "1.5450☉"
        raw                                     // return scalar
      ),

    result
  )
);


/* ASTRO_ORBIT_CONFIGURATION_INDEX
   Purpose:
   Computes a dimensionless index that characterizes the configuration
   of a two-body orbital system based on mass asymmetry. This index
   predicts whether orbits will be nested, tangential, or crossing.

   Inputs:
   - mass1: First body mass (solar masses)
   - mass2: Second body mass (solar masses)

   Returns:
   - Configuration index ¤p = |m1 − m2| / (m1 + m2), range [0, 1)

   Interpretation:
   - < 0.4142 (√2 − 1) → Crossing orbits
   - = 0.4142          → Tangential boundary (silver ratio)
   - > 0.4142          → Nested orbits

   Notes:
   - This index is scale-invariant and symmetric.
   - Useful in worldbuilding, classification, and binary system modeling.
*/

ASTRO_ORBIT_CONFIGURATION_INDEX =
LAMBDA(mass1, mass2,
  ABS(mass1 - mass2) / (mass1 + mass2)
);


/* ASTRO_SPHERICAL_TO_CARTESIAN
   Purpose:
   Converts spherical coordinates to Cartesian (x, y, z),
   assuming phi is inclination from the vertical axis and theta is azimuth.

   Inputs:
   - phi:    Inclination angle (degrees), 0 = north pole, 90 = equator, 180 = south pole
   - theta:  Azimuthal angle (degrees), 0 = prime meridian, 90 = east
   - r:      Radial distance
   - prec (optional): Decimal precision (default = 3)

   Returns:
   - 1×3 array: {x, y, z}, rounded to [prec] digits

   Notes:
   - Compatible with mapping and simulation systems using spherical geometry.
   - Assumes standard right-handed coordinate system.
*/

ASTRO_SPHERICAL_TO_CARTESIAN =
LAMBDA(phi, theta, r, prec,
  LET(
    // Handle default precision
    prec, IF(ISOMITTED(prec) + (prec < 0), 3, prec),

    // Convert degrees to radians
    phi_rad, RADIANS(phi),
    theta_rad, RADIANS(theta),

    // Trig calculations
    x_raw, r * SIN(phi_rad) * COS(theta_rad),
    y_raw, r * SIN(phi_rad) * SIN(theta_rad),
    z_raw, r * COS(phi_rad),

    // Round and return as 1×3 array
    x, ROUND(x_raw, prec),
    y, ROUND(y_raw, prec),
    z, ROUND(z_raw, prec),

    HSTACK(x, y, z)
  )
);

/* ASTRO_CARTESIAN_TO_SPHERICAL
   Purpose:
   Converts Cartesian coordinates (x, y, z) into spherical coordinates:
   inclination (phi), azimuth (theta), and radius (r).

   Inputs:
   - x, y, z: Cartesian coordinates
   - prec (optional): Decimal precision (default = 3)

   Returns:
   - 1×3 array: {phi, theta, r}, rounded to [prec] digits

   Notes:
   - phi = inclination from vertical (0 = pole, 90 = equator)
   - theta = azimuthal direction from x-axis, 0–360°
*/

ASTRO_CARTESIAN_TO_SPHERICAL =
LAMBDA(x, y, z, prec,
  LET(
    // Handle default rounding precision
    prec, IF(ISOMITTED(prec) + (prec < 0), 3, prec),

    // Compute radial distance from origin
    r, SQRT(x^2 + y^2 + z^2),

    // Compute inclination angle from vertical axis (z)
    phi, DEGREES(ACOS(z / r)),

    // Compute azimuthal angle in x-y plane, normalized to [0, 360)
    theta, MOD(DEGREES(ATAN2(y, x)), 360),

    // Round all outputs
    phi_out, ROUND(phi, prec),
    theta_out, ROUND(theta, prec),
    r_out, ROUND(r, prec),

    // Return as 1×3 array
    HSTACK(phi_out, theta_out, r_out)
  )
);


DEG_DEC_DMS = LAMBDA(DecimalDegrees,
    LET(
        Deg, TRUNC(DecimalDegrees),
        FracPortion, ABS(DecimalDegrees - Deg),
        Minutes, FracPortion * 60,
        Min_part, TRUNC(Minutes) / 100,
        IntMin, INT(Minutes),
        FracMin, ABS(Minutes - IntMin),
        Seconds, FracMin * 60,
        sec_part, Seconds / 10000,
        output, Deg + Min_part + sec_part,
        FIXED(output, 7)
    )
);

DEG_DMS = LAMBDA(DecimalDegrees, [precision],

LET(
    decprec, IF(ISOMITTED(Precision), 3, Precision),
    Deg, TRUNC(DecimalDegrees),
    FracPortion, ABS(DecimalDegrees - Deg),
    Minutes, FracPortion * 60,
    IntMin, INT(Minutes),
    FracMin, ABS(Minutes - IntMin),
    Seconds, FracMin * 60,
    Deg & "° " & IntMin & CHAR(39) & CHAR(32) & FIXED(Seconds, decprec) & CHAR(34)
)
);

DEG_DMS_DEC = LAMBDA(input,
    LET(
        degrees, TRUNC(input),
        minutes, TRUNC((input - degrees) * 100),
        fractional_seconds, ((input * 100) - TRUNC(input * 100)) / 0.6,
        /*  */
        result, degrees + ((minutes + fractional_seconds) / 60),
        result
    )
);

/* ASTRO_ORBIT_AXIS
   Purpose:
   Computes the semi-major axis (in AU) of a two-body system
   based on total mass (in solar masses) and orbital period (in years).

   Inputs:
   - mass1: Primary mass (in solar masses)
   - mass2 (optional): Secondary mass (in solar masses; defaults to 0 if omitted or = 1)
   - period: Orbital period (in years)

   Returns:
   - Orbital axis in astronomical units (AU)

   Notes:
   - Uses Newtonian form of Kepler's Third Law.
   - mass2 is converted from solar masses if present.
*/

ASTRO_ORBIT_AXIS = LAMBDA(mass1, mass2, period,
  LET(
    m_2, IF((ISOMITTED(mass2)) + (mass2 = 1), 0, mass2 * 3.003E-6),
    axis, POWER((POWER(period, 2) * (mass1 + m_2)), 1 / 3),
    axis
  )
);


/* ASTRO_ORBIT_PERIOD
   Purpose:
   Computes the orbital period (in years) of a two-body system
   based on total mass (in solar masses) and semi-major axis (in AU).

   Inputs:
   - mass1: Primary mass (in solar masses)
   - mass2 (optional): Secondary mass (in solar masses; defaults to 0 if omitted or = 1)
   - axis: Orbital axis (in AU)

   Returns:
   - Orbital period in years
*/

ASTRO_ORBIT_PERIOD = LAMBDA(mass1, mass2, axis,
  LET(
    m_2, IF((ISOMITTED(mass2)) + (mass2 = 1), 0, mass2 * 3.00273E-6),
    period, SQRT(POWER(axis, 3) / (mass1 + m_2)),
    period
  )
);


/* ASTRO_ORBIT_SUM_MASSES
   Purpose:
   Computes the combined mass (in solar masses) of a two-body system
   from orbital axis (in AU) and period (in years).

   Inputs:
   - axis: Semi-major axis (AU)
   - period: Orbital period (years)

   Returns:
   - Total system mass (in solar masses)
*/

ASTRO_ORBIT_SUM_MASSES = LAMBDA(axis, period,
  POWER(axis, 3) / POWER(period, 2)
);


/* ASTRO_ORBIT_SOLVER
   Purpose:
   Unified solver for orbital axis, period, or total mass in a two-body system.
   Selects appropriate formula based on mode.

   Inputs:
   - mode: One of "axis", "period", or "mass"
   - val_1: First known value (depends on mode)
   - val_2: Second known value (depends on mode)
   - mass2 (optional): Secondary mass (in solar masses; defaults to 0 if omitted or = 1)
   - precision (optional): Decimal places for formatted output (default = 4)

   Returns:
   - Result as a number or labeled string, depending on mode and format

   Notes:
   - mass2 is only relevant for "axis" and "period" modes.
*/

ASTRO_ORBIT_SOLVER =
LAMBDA(mode, val_1, val_2, mass2, precision,
  LET(
    m_2, IF(ISOMITTED(mass2) + (mass2 = 1), 0, mass2 * 3.003E-6),
    prec, IF(ISOMITTED(precision), 4, precision),

    result,
      SWITCH(LOWER(mode),
        "axis", POWER((POWER(val_2, 2) * (val_1 + m_2)), 1 / 3),
        "period", SQRT(POWER(val_2, 3) / (val_1 + m_2)),
        "mass", POWER(val_1, 3) / POWER(val_2, 2),
        NA()
      ),

    label,
      SWITCH(LOWER(mode),
        "axis", "Axis = ",
        "period", "Period = ",
        "mass", "Mass = ",
        "?"
      ),

    TEXT(result, "0." & REPT("0", prec)) & " " & label
  )
);

/* ASTRO_DEGREES_TO_DMS_NUM
   Purpose:
   Converts decimal degrees into a compact D.MMSS numeric representation.

   Input:
   - DecimalDegrees: Angle in decimal degrees

   Returns:
   - Numeric result in D.MMSS format
*/

ASTRO_DEGREES_TO_DMS_NUM =
LAMBDA(DecimalDegrees,
  LET(
    Deg, TRUNC(DecimalDegrees),                         // Whole degrees
    FracPortion, ABS(DecimalDegrees - Deg),             // Fractional part
    Minutes, FracPortion * 60,                          // Convert to minutes
    Min_part, TRUNC(Minutes) / 100,                     // Integer minutes / 100
    IntMin, INT(Minutes),
    FracMin, ABS(Minutes - IntMin),                     // Remainder minutes
    Seconds, FracMin * 60,                              // Convert to seconds
    sec_part, Seconds / 10000,                          // Seconds / 10000
    output, Deg + Min_part + sec_part,                  // Add all together
    FIXED(output, 7)                                    // Return fixed decimal text
  )
);


/* ASTRO_DEGREES_TO_DMS_TEXT
   Purpose:
   Converts decimal degrees into a formatted D° M' S" string.

   Inputs:
   - DecimalDegrees: Angle in decimal degrees
   - precision (optional): Decimal places for seconds (default = 3)

   Returns:
   - String in "D° M' S.SS\"" format
*/

ASTRO_DEGREES_TO_DMS_TEXT =
LAMBDA(DecimalDegrees, precision,
  LET(
    decprec, IF(ISOMITTED(precision), 3, precision),
    Deg, TRUNC(DecimalDegrees),
    FracPortion, ABS(DecimalDegrees - Deg),
    Minutes, FracPortion * 60,
    IntMin, INT(Minutes),
    FracMin, ABS(Minutes - IntMin),
    Seconds, FracMin * 60,
    Deg & "° " & IntMin & CHAR(39) & CHAR(32) & FIXED(Seconds, decprec) & CHAR(34)
  )
);


/* ASTRO_DMS_NUM_TO_DEGREES
   Purpose:
   Converts a D.MMSS-style numeric format into decimal degrees.

   Input:
   - input: Angle in D.MMSS format (e.g., 123.3015)

   Returns:
   - Decimal degrees
*/

ASTRO_DMS_NUM_TO_DEGREES =
LAMBDA(input,
  LET(
    degrees, TRUNC(input),                             // Whole degrees
    minutes, TRUNC((input - degrees) * 100),           // Minutes portion
    fractional_seconds, ((input * 100) - TRUNC(input * 100)) / 0.6, // Convert from decimal minutes to seconds
    result, degrees + ((minutes + fractional_seconds) / 60),
    result
  )
);