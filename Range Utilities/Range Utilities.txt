/* SET_COMPARE:
   Purpose:
   Classifies the relationship between two sets:
     - EQUAL, EQUIV, PRSUB, INTER, or FAILURE

   Returns:
   A symbolic or verbose label describing the overlap between two ranges.

   Parameters:
   - universal (required): Reference set (U).
   - check (required): Set to compare against U (A).
   - verbose (optional): 
       0 = return symbolic tag only (default)
       1 = return descriptive explanation

   Possible Output Tags:
   - "EQUAL"   → identical content and length
   - "EQUIV"   → equal length, no overlapping items
   - "PRSUB"   → proper subset (all A ∈ U)
   - "INTER"   → partial overlap, not full containment
   - "FAILURE" → unclassified/ambiguous relationship

   Notes:
   - Input ranges are normalized using TOCOL(..., 3).
   - Duplicates are factored into the logic.
   - Use for diagnostics, validation, or set comparison logic.

   Examples:
     SET_COMPARE(A1:A10, B1:B5) → "PRSUB"
     SET_COMPARE(A1:A10, B1:B5, 1) → "Proper subset: All elements from check found in universal."
*/

SET_COMPARE = LAMBDA(universal, check, [verbose],
    LET(
        verbose, IF(OR(ISOMITTED(verbose), verbose > 1), 0, verbose),

        // Normalize both ranges
        u, TOCOL(universal, 3),
        c, TOCOL(check, 3),

        // Counts for comparison
        uCount, COUNTA(u),
        cCount, COUNTA(c),

        // Matches and uniqueness
        x, XMATCH(c, u),
        matchCount, COUNT(x),
        matchCountA, COUNTA(x),
        matchUnique, COUNT(UNIQUE(x)),

        // Classification logic
        relate, IF(
            AND(matchCount = 0, cCount = uCount),
            "EQUIV",
            IFS(
                AND(matchUnique = matchCount, cCount = matchCount, matchCount = matchCountA, cCount = uCount),
                "EQUAL",

                AND(matchUnique <= matchCount, cCount = matchCount, matchCount = matchCountA, cCount <= uCount),
                "PRSUB",

                AND(matchUnique <= matchCount, cCount > matchCount, matchCount < matchCountA),
                "INTER",

                TRUE,
                "FAILURE"
            )
        ),

        // Return format based on verbosity
        result, IF(
            verbose = 1,
            SWITCH(
                relate,
                "EQUAL", "Equal sets: All elements matched with no extras.",
                "EQUIV", "Equivalent size, but no shared elements.",
                "PRSUB", "Proper subset: All elements from check found in universal.",
                "INTER", "Intersection: Some shared elements, but not fully equivalent.",
                "FAILURE", "Unclassified relationship or invalid input.",
                "Unknown"
            ),
            relate
        ),

        result
    )
);



/* SET_COMPLEMENT:
   Purpose:
   Returns the relative or absolute complement between two sets of values.

   Returns:
   A single-column array of values that appear in one range but not the other.

   Parameters:
   - universal (required): The complete reference set (commonly thought of as U).
   - check (required): The set to be compared against U.
   - mode (optional): 
       "REL" (default) → relative complement: U \ A
       "ABS"           → absolute complement: A \ U
   - showHeader (optional): 
       TRUE (default) → includes symbolic label ("U \ A" or "A \ U") at top
       FALSE          → returns only the complement list

   Notes:
   - All inputs are automatically normalized to one-column arrays via `TOCOL(..., 3)`.
   - Supports full rectangular Excel ranges with blanks.
   - This function does not throw errors on partial overlap or full match — it returns "NONE" if no values are found.
   - Header is a text label and will be included even if result is empty.
   - Use `SORT(...)` externally if needed; the header will stay on top.

   Examples:
     SET_COMPLEMENT(A1:A10, B1:B5) → U \ A
     SET_COMPLEMENT(B1:B5, A1:A10, "ABS", FALSE) → {values in A1:A10 not in B1:B5}
*/

SET_COMPLEMENT = LAMBDA(universal, check, [mode], [showHeader],
    LET(
        mode, IF(ISOMITTED(mode), "REL", UPPER(mode)),
        showHeader, IF(ISOMITTED(showHeader), TRUE, showHeader),
        a, TOCOL(IF(mode = "REL", universal, check), 3),
        b, TOCOL(IF(mode = "REL", check, universal), 3),
        result, ISNA(BYROW(a, LAMBDA(x, XLOOKUP(x, b, b)))),
        core, IFERROR(FILTER(a, result = TRUE), "NONE"),
        label, IF(mode = "REL", "# U \\ A", "# A \\ U"),
        IF(showHeader, VSTACK(label, core), core)
    )
);




/* SET_INTERSECT:
   Purpose:
   Returns the intersection of two ranges — only values present in both.

   Returns:
   A single-column array of shared values between `universal` and `check`.

   Parameters:
   - universal (required): The first set of values.
   - check (required): The second set to compare against.
   - sortMode (optional): 
       0 = preserve order (default)
       1 = alphabetic sort
   - showHeader (optional): 
       TRUE = add "U ∩ A" as symbolic label (default)
       FALSE = no header

   Notes:
   - Inputs are normalized with `TOCOL(..., 3)` to ensure uniform columnar arrays.
   - If no intersection exists, function returns `"NONE"` (optionally with header).
   - Sorting applies after deduplication.
   - Header is always fixed to the first row when shown.

   Examples:
     SET_INTERSECT(A1:A10, B1:B5) → values in both A and B
     SET_INTERSECT(A1:A10, B1:B5, 1, TRUE) → sorted list with header
*/

SET_INTERSECT = LAMBDA(universal, check, [sortMode], [showHeader],
    LET(
        sortMode, IF(ISOMITTED(sortMode), 0, sortMode),
        showHeader, IF(ISOMITTED(showHeader), TRUE, showHeader),
        u, TOCOL(universal, 3),
        c, TOCOL(check, 3),
        overlap_flags, NOT(ISNA(XMATCH(c, u))),
        raw, FILTER(c, overlap_flags),
        result, IF(sortMode = 1, SORT(UNIQUE(raw)), UNIQUE(raw)),
        final, IF(showHeader, VSTACK("# U ∩ A", IFERROR(result, "NONE")), IFERROR(result, "NONE")),
        final
    )
);



/* SET_SYMDIFF:
   Purpose:
   Returns the symmetric difference between two ranges — values unique to each.

   Returns:
   A list of all values that appear in only one of the two ranges, not both.

   Parameters:
   - universal (required): First set of values (U).
   - check (required): Second set to compare (A).
   - sortMode (optional): 
       0 = preserve order (default)
       1 = sort alphabetically
   - showHeader (optional): 
       TRUE = include "# U △ A" label (default)
       FALSE = return only results

   Notes:
   - Inputs are normalized to single-column arrays via `TOCOL(..., 3)`.
   - If no unique values are found, returns `"NONE"`.
   - Header always appears first and stays in place even if externally sorted.
   - Function is useful for identifying mismatches or divergence between lists.

   Example:
     SET_SYMDIFF(A1:A10, B1:B5) → values in A or B but not both
*/

SET_SYMDIFF = LAMBDA(universal, check, [sortMode], [showHeader],
    LET(
        sortMode, IF(ISOMITTED(sortMode), 0, sortMode),
        showHeader, IF(ISOMITTED(showHeader), TRUE, showHeader),

        // Normalize both input ranges
        u, TOCOL(universal, 3),
        c, TOCOL(check, 3),

        // Values in U not in A
        onlyU_flags, ISNA(XMATCH(u, c)),
        onlyU, FILTER(u, onlyU_flags),

        // Values in A not in U
        onlyA_flags, ISNA(XMATCH(c, u)),
        onlyA, FILTER(c, onlyA_flags),

        // Combine the two unique lists
        combined, VSTACK(onlyU, onlyA),

        // Sort if needed, otherwise preserve order
        cleaned, IFERROR(IF(sortMode = 1, SORT(combined), combined), "NONE"),

        // Add symbolic header if enabled
        result, IF(showHeader, VSTACK("# U △ A", cleaned), cleaned),

        result
    )
);



/* SET_UNION:
   Purpose:
   Returns the union of two ranges — all unique values from both.

   Returns:
   A single-column array containing all distinct elements from both `universal` and `check`.

   Parameters:
   - universal (required): First range to include.
   - check (required): Second range to include.
   - sortMode (optional): 
       0 = preserve input order (default)
       1 = alphabetic sort
   - showHeader (optional): 
       TRUE = adds a symbolic label ("U ∪ A") at top
       FALSE (default) = no header

   Notes:
   - Inputs are flattened using `TOCOL(..., 3)` to handle any rectangular range.
   - Duplicates across both inputs are automatically removed.
   - Header is fixed and will remain atop sorted output if present.
   - Use for merging distinct value lists in dashboards or conditional logic pipelines.

   Examples:
     SET_UNION(A1:A10, B1:B5) → merged unique list
     SET_UNION(A1:A10, B1:B5, 1, TRUE) → sorted union with label
*/

SET_UNION = LAMBDA(universal, check, [sortMode], [showHeader],
    LET(
        sortMode, IF(ISOMITTED(sortMode), 0, sortMode),
        showHeader, IF(ISOMITTED(showHeader), FALSE, showHeader),
        u, TOCOL(universal, 3),
        c, TOCOL(check, 3),
        raw, UNIQUE(VSTACK(u, c)),
        result, IF(sortMode = 1, SORT(raw), raw),
        final, IF(showHeader, VSTACK("# U ∪ A", result), result),
        final
    )
);


/* SET_ISIN:
   Purpose:
   Tests whether one or more values in `check` exist in the `universal` range.

   Returns:
   - A single result or array indicating membership status.
   - Output format depends on the `mode` selected.

   Parameters:
   - universal (required): The reference range or list to check against.
   - check (required): A value or array of values to evaluate.
   - mode (optional):
       0 = Boolean TRUE/FALSE (default)
       1 = "YES"/"NO" text output
       2 = Numeric 1/0 flag
       3 = Verbose output — a two-column array showing check + result

   Notes:
   - All inputs are automatically normalized to single-column arrays using `TOCOL(..., 3)`.
   - This allows compatibility with multi-row, multi-column, or irregular input ranges.
   - Results are returned in the same order as the `check` array.

   Examples:
     SET_ISIN(A1:A10, "apple") → TRUE
     SET_ISIN(A1:A10, {"apple", "pear"}, 1) → {"YES"; "NO"}
     SET_ISIN(A1:A10, {"apple", "pear"}, 3) → {"apple", TRUE; "pear", FALSE}
*/

SET_ISIN = LAMBDA(universal, check, [mode],
    LET(
        // Normalize optional mode input
        mode, IF(OR(ISOMITTED(mode), mode > 3), 0, mode),

        // Normalize input ranges to single-column arrays
        u, TOCOL(universal, 3),
        c, TOCOL(check, 3),

        // Perform membership check for each item in `check`
        raw, NOT(ISNA(XMATCH(c, u))),

        // Switch result format based on selected mode
        result, SWITCH(
            mode,
            0, raw,                    // Boolean (TRUE/FALSE)
            1, IF(raw, "YES", "NO"),   // Textual result
            2, IF(raw, 1, 0),          // Numeric flag
            3, HSTACK(c, raw),         // Two-column {value, result}
            raw                        // Fallback: default to Boolean
        ),

        result
    )
);


